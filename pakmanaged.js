var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:kind-of
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var toString = Object.prototype.toString;
    
    /**
     * Get the native `typeof` a value.
     *
     * @param  {*} `val`
     * @return {*} Native javascript type
     */
    
    module.exports = function kindOf(val) {
      // primitivies
      if (typeof val === 'undefined') {
        return 'undefined';
      }
      if (val === null) {
        return 'null';
      }
      if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
      }
      if (typeof val === 'string' || val instanceof String) {
        return 'string'
      }
      if (typeof val === 'number' || val instanceof Number) {
        return 'number'
      }
    
      // functions
      if (typeof val === 'function' || val instanceof Function) {
        return 'function'
      }
    
      // array
      if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
      }
    
      // check for instances of RegExp and Date before calling `toString`
      if (val instanceof RegExp) {
        return 'regexp';
      }
      if (val instanceof Date) {
        return 'date';
      }
    
      // other objects
      var type = toString.call(val);
    
      if (type === '[object RegExp]') {
        return 'regexp';
      }
      if (type === '[object Date]') {
        return 'date';
      }
      if (type === '[object Arguments]') {
        return 'arguments';
      }
    
      // buffer
      if (typeof Buffer !== 'undefined' && Buffer.isBuffer(val)) {
        return 'buffer';
      }
    
      // es6: Map, WeakMap, Set, WeakSet
      if (type === '[object Set]') {
        return 'set';
      }
      if (type === '[object WeakSet]') {
        return 'weakset';
      }
      if (type === '[object Map]') {
        return 'map';
      }
      if (type === '[object WeakMap]') {
        return 'weakmap';
      }
      if (type === '[object Symbol]') {
        return 'symbol';
      }
    
      // must be a plain object
      return 'object';
    };
    
  provide("kind-of", module.exports);
}(global));

// pakmanager:longest
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * longest <https://github.com/jonschlinkert/longest>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function(arr) {
      if (!arr) {
        return null;
      }
    
      var len = arr.length;
      if (!len) {
        return null;
      }
    
      var c = 0;
      var i = 0;
      var ele;
      var elen;
      var res;
    
      for (; i < len; i++) {
        ele = arr[i].toString();
        elen = ele.length;
    
        if (elen > c) {
          res = ele;
          c = elen;
        }
      }
    
      return res;
    };
    
  provide("longest", module.exports);
}(global));

// pakmanager:repeat-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * repeat-string <https://github.com/jonschlinkert/repeat-string>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    /**
     * Expose `repeat`
     */
    
    module.exports = repeat;
    
    /**
     * Repeat the given `string` the specified `number`
     * of times.
     *
     * **Example:**
     *
     * ```js
     * var repeat =  require('repeat-string');
     * repeat('A', 5);
     * //=> AAAAA
     * ```
     *
     * @param {String} `string` The string to repeat
     * @param {Number} `number` The number of times to repeat the string
     * @return {String} Repeated string
     * @api public
     */
    
    function repeat(str, num) {
      if (typeof str !== 'string') {
        throw new TypeError('repeat-string expects a string.');
      }
    
      if (num === 1) return str;
      if (num === 2) return str + str;
    
      var max = str.length * num;
      if (cache !== str || typeof cache === 'undefined') {
        cache = str;
        res = '';
      }
    
      while (max > res.length && num > 0) {
        if (num & 1) {
          res += str;
        }
    
        num >>= 1;
        if (!num) break;
        str += str;
      }
    
      return res.substr(0, max);
    }
    
    /**
     * Results cache
     */
    
    var res = '';
    var cache;
    
  provide("repeat-string", module.exports);
}(global));

// pakmanager:align-text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * align-text <https://github.com/jonschlinkert/align-text>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var typeOf = require('kind-of');
    var repeat = require('repeat-string');
    var longest = require('longest');
    
    module.exports = function alignText(val, fn) {
      var lines, type = typeOf(val);
    
      if (type === 'array') {
        lines = val;
      } else if (type === 'string') {
        lines = val.split(/(?:\r\n|\n)/);
      } else {
        throw new TypeError('align-text expects a string or array.');
      }
    
      var fnType = typeOf(fn);
      var len = lines.length;
      var max = longest(lines);
      var res = [], i = 0;
    
      while (len--) {
        var line = String(lines[i++]);
        var diff;
    
        if (fnType === 'function') {
          diff = fn(line.length, max.length, line, lines, i);
        } else if (fnType === 'number') {
          diff = fn;
        } else {
          diff = max.length - line.length;
        }
    
        if (typeOf(diff) === 'number') {
          res.push(repeat(' ', diff) + line);
        } else if (typeOf(diff) === 'object') {
          var result = repeat(diff.character || ' ', diff.indent || 0);
          res.push((diff.prefix || '') + result + line);
        }
      }
    
      if (type === 'array') return res;
      return res.join('\n');
    };
    
  provide("align-text", module.exports);
}(global));

// pakmanager:wrappy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Returns a wrapper function that returns a wrapped callback
    // The wrapper function should do some stuff, and return a
    // presumably different callback function.
    // This makes sure that own properties are retained, so that
    // decorations and such are not lost along the way.
    module.exports = wrappy
    function wrappy (fn, cb) {
      if (fn && cb) return wrappy(fn)(cb)
    
      if (typeof fn !== 'function')
        throw new TypeError('need wrapper function')
    
      Object.keys(fn).forEach(function (k) {
        wrapper[k] = fn[k]
      })
    
      return wrapper
    
      function wrapper() {
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        var ret = fn.apply(this, args)
        var cb = args[args.length-1]
        if (typeof ret === 'function' && ret !== cb) {
          Object.keys(cb).forEach(function (k) {
            ret[k] = cb[k]
          })
        }
        return ret
      }
    }
    
  provide("wrappy", module.exports);
}(global));

// pakmanager:balanced-match
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = balanced;
    function balanced(a, b, str) {
      var bal = 0;
      var m = {};
      var ended = false;
    
      for (var i = 0; i < str.length; i++) {
        if (a == str.substr(i, a.length)) {
          if (!('start' in m)) m.start = i;
          bal++;
        }
        else if (b == str.substr(i, b.length) && 'start' in m) {
          ended = true;
          bal--;
          if (!bal) {
            m.end = i;
            m.pre = str.substr(0, m.start);
            m.body = (m.end - m.start > 1)
              ? str.substring(m.start + a.length, m.end)
              : '';
            m.post = str.slice(m.end + b.length);
            return m;
          }
        }
      }
    
      // if we opened more than we closed, find the one we closed
      if (bal && ended) {
        var start = m.start + a.length;
        m = balanced(a, b, str.substr(start));
        if (m) {
          m.start += start;
          m.end += start;
          m.pre = str.slice(0, start) + m.pre;
        }
        return m;
      }
    }
    
  provide("balanced-match", module.exports);
}(global));

// pakmanager:concat-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            var x = fn(xs[i], i);
            if (isArray(x)) res.push.apply(res, x);
            else res.push(x);
        }
        return res;
    };
    
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
  provide("concat-map", module.exports);
}(global));

// pakmanager:ansi-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function () {
    	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
    };
    
  provide("ansi-regex", module.exports);
}(global));

// pakmanager:center-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * center-align <https://github.com/jonschlinkert/center-align>
     *
     * Copycenter (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function centerAlign(val) {
      return align(val, function (len, longest) {
        return Math.floor((longest - len) / 2);
      });
    };
    
  provide("center-align", module.exports);
}(global));

// pakmanager:right-align
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * right-align <https://github.com/jonschlinkert/right-align>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var align = require('align-text');
    
    module.exports = function rightAlign(val) {
      return align(val, function (len, longest) {
        return longest - len;
      });
    };
    
  provide("right-align", module.exports);
}(global));

// pakmanager:wordwrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wordwrap = module.exports = function (start, stop, params) {
        if (typeof start === 'object') {
            params = start;
            start = params.start;
            stop = params.stop;
        }
        
        if (typeof stop === 'object') {
            params = stop;
            start = start || params.start;
            stop = undefined;
        }
        
        if (!stop) {
            stop = start;
            start = 0;
        }
        
        if (!params) params = {};
        var mode = params.mode || 'soft';
        var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
        
        return function (text) {
            var chunks = text.toString()
                .split(re)
                .reduce(function (acc, x) {
                    if (mode === 'hard') {
                        for (var i = 0; i < x.length; i += stop - start) {
                            acc.push(x.slice(i, i + stop - start));
                        }
                    }
                    else acc.push(x)
                    return acc;
                }, [])
            ;
            
            return chunks.reduce(function (lines, rawChunk) {
                if (rawChunk === '') return lines;
                
                var chunk = rawChunk.replace(/\t/g, '    ');
                
                var i = lines.length - 1;
                if (lines[i].length + chunk.length > stop) {
                    lines[i] = lines[i].replace(/\s+$/, '');
                    
                    chunk.split(/\n/).forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else if (chunk.match(/\n/)) {
                    var xs = chunk.split(/\n/);
                    lines[i] += xs.shift();
                    xs.forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else {
                    lines[i] += chunk;
                }
                
                return lines;
            }, [ new Array(start + 1).join(' ') ]).join('\n');
        };
    };
    
    wordwrap.soft = wordwrap;
    
    wordwrap.hard = function (start, stop) {
        return wordwrap(start, stop, { mode : 'hard' });
    };
    
  provide("wordwrap", module.exports);
}(global));

// pakmanager:once
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    module.exports = wrappy(once)
    
    once.proto = once(function () {
      Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return once(this)
        },
        configurable: true
      })
    })
    
    function once (fn) {
      var f = function () {
        if (f.called) return f.value
        f.called = true
        return f.value = fn.apply(this, arguments)
      }
      f.called = false
      return f
    }
    
  provide("once", module.exports);
}(global));

// pakmanager:brace-expansion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var concatMap = require('concat-map');
    var balanced = require('balanced-match');
    
    module.exports = expandTop;
    
    var escSlash = '\0SLASH'+Math.random()+'\0';
    var escOpen = '\0OPEN'+Math.random()+'\0';
    var escClose = '\0CLOSE'+Math.random()+'\0';
    var escComma = '\0COMMA'+Math.random()+'\0';
    var escPeriod = '\0PERIOD'+Math.random()+'\0';
    
    function numeric(str) {
      return parseInt(str, 10) == str
        ? parseInt(str, 10)
        : str.charCodeAt(0);
    }
    
    function escapeBraces(str) {
      return str.split('\\\\').join(escSlash)
                .split('\\{').join(escOpen)
                .split('\\}').join(escClose)
                .split('\\,').join(escComma)
                .split('\\.').join(escPeriod);
    }
    
    function unescapeBraces(str) {
      return str.split(escSlash).join('\\')
                .split(escOpen).join('{')
                .split(escClose).join('}')
                .split(escComma).join(',')
                .split(escPeriod).join('.');
    }
    
    
    // Basically just str.split(","), but handling cases
    // where we have nested braced sections, which should be
    // treated as individual members, like {a,{b,c},d}
    function parseCommaParts(str) {
      if (!str)
        return [''];
    
      var parts = [];
      var m = balanced('{', '}', str);
    
      if (!m)
        return str.split(',');
    
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(',');
    
      p[p.length-1] += '{' + body + '}';
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length-1] += postParts.shift();
        p.push.apply(p, postParts);
      }
    
      parts.push.apply(parts, p);
    
      return parts;
    }
    
    function expandTop(str) {
      if (!str)
        return [];
    
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    
    function identity(e) {
      return e;
    }
    
    function embrace(str) {
      return '{' + str + '}';
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    
    function expand(str, isTop) {
      var expansions = [];
    
      var m = balanced('{', '}', str);
      if (!m || /\$$/.test(m.pre)) return [str];
    
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = /^(.*,)+(.+)?$/.test(m.body);
      if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,.*}/)) {
          str = m.pre + '{' + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
    
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          // x{{a,b}}y ==> x{a}y x{b}y
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length
              ? expand(m.post, false)
              : [''];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
    
      // at this point, n is the parts, and we know it's not a comma set
      // with a single entry.
    
      // no need to expand pre, since it is guaranteed to be free of brace-sets
      var pre = m.pre;
      var post = m.post.length
        ? expand(m.post, false)
        : [''];
    
      var N;
    
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length)
        var incr = n.length == 3
          ? Math.abs(numeric(n[2]))
          : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
    
        N = [];
    
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === '\\')
              c = '';
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join('0');
                if (i < 0)
                  c = '-' + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) { return expand(el, false) });
      }
    
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    
      return expansions;
    }
    
    
  provide("brace-expansion", module.exports);
}(global));

// pakmanager:ansi-styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function assembleStyles () {
    	var styles = {
    		modifiers: {
    			reset: [0, 0],
    			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
    			dim: [2, 22],
    			italic: [3, 23],
    			underline: [4, 24],
    			inverse: [7, 27],
    			hidden: [8, 28],
    			strikethrough: [9, 29]
    		},
    		colors: {
    			black: [30, 39],
    			red: [31, 39],
    			green: [32, 39],
    			yellow: [33, 39],
    			blue: [34, 39],
    			magenta: [35, 39],
    			cyan: [36, 39],
    			white: [37, 39],
    			gray: [90, 39]
    		},
    		bgColors: {
    			bgBlack: [40, 49],
    			bgRed: [41, 49],
    			bgGreen: [42, 49],
    			bgYellow: [43, 49],
    			bgBlue: [44, 49],
    			bgMagenta: [45, 49],
    			bgCyan: [46, 49],
    			bgWhite: [47, 49]
    		}
    	};
    
    	// fix humans
    	styles.colors.grey = styles.colors.gray;
    
    	Object.keys(styles).forEach(function (groupName) {
    		var group = styles[groupName];
    
    		Object.keys(group).forEach(function (styleName) {
    			var style = group[styleName];
    
    			styles[styleName] = group[styleName] = {
    				open: '\u001b[' + style[0] + 'm',
    				close: '\u001b[' + style[1] + 'm'
    			};
    		});
    
    		Object.defineProperty(styles, groupName, {
    			value: group,
    			enumerable: false
    		});
    	});
    
    	return styles;
    }
    
    Object.defineProperty(module, 'exports', {
    	enumerable: true,
    	get: assembleStyles
    });
    
  provide("ansi-styles", module.exports);
}(global));

// pakmanager:escape-string-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(matchOperatorsRe,  '\\$&');
    };
    
  provide("escape-string-regexp", module.exports);
}(global));

// pakmanager:has-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex');
    var re = new RegExp(ansiRegex().source); // remove the `g` flag
    module.exports = re.test.bind(re);
    
  provide("has-ansi", module.exports);
}(global));

// pakmanager:strip-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex')();
    
    module.exports = function (str) {
    	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
    };
    
  provide("strip-ansi", module.exports);
}(global));

// pakmanager:supports-color
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var argv = process.argv;
    
    var terminator = argv.indexOf('--');
    var hasFlag = function (flag) {
    	flag = '--' + flag;
    	var pos = argv.indexOf(flag);
    	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
    };
    
    module.exports = (function () {
    	if ('FORCE_COLOR' in process.env) {
    		return true;
    	}
    
    	if (hasFlag('no-color') ||
    		hasFlag('no-colors') ||
    		hasFlag('color=false')) {
    		return false;
    	}
    
    	if (hasFlag('color') ||
    		hasFlag('colors') ||
    		hasFlag('color=true') ||
    		hasFlag('color=always')) {
    		return true;
    	}
    
    	if (process.stdout && !process.stdout.isTTY) {
    		return false;
    	}
    
    	if (process.platform === 'win32') {
    		return true;
    	}
    
    	if ('COLORTERM' in process.env) {
    		return true;
    	}
    
    	if (process.env.TERM === 'dumb') {
    		return false;
    	}
    
    	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    		return true;
    	}
    
    	return false;
    })();
    
  provide("supports-color", module.exports);
}(global));

// pakmanager:amdefine
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /** vim: et:ts=4:sw=4:sts=4
     * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
     * Available via the MIT or new BSD license.
     * see: http://github.com/jrburke/amdefine for details
     */
    
    /*jslint node: true */
    /*global module, process */
    'use strict';
    
    /**
     * Creates a define for node.
     * @param {Object} module the "module" object that is defined by Node for the
     * current module.
     * @param {Function} [requireFn]. Node's require function for the current module.
     * It only needs to be passed in Node versions before 0.5, when module.require
     * did not exist.
     * @returns {Function} a define function that is usable for the current node
     * module.
     */
    function amdefine(module, requireFn) {
        'use strict';
        var defineCache = {},
            loaderCache = {},
            alreadyCalled = false,
            path = require('path'),
            makeRequire, stringRequire;
    
        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i+= 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
    
        function normalize(name, baseName) {
            var baseParts;
    
            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    baseParts = baseName.split('/');
                    baseParts = baseParts.slice(0, baseParts.length - 1);
                    baseParts = baseParts.concat(name.split('/'));
                    trimDots(baseParts);
                    name = baseParts.join('/');
                }
            }
    
            return name;
        }
    
        /**
         * Create the normalize() function passed to a loader plugin's
         * normalize method.
         */
        function makeNormalize(relName) {
            return function (name) {
                return normalize(name, relName);
            };
        }
    
        function makeLoad(id) {
            function load(value) {
                loaderCache[id] = value;
            }
    
            load.fromText = function (id, text) {
                //This one is difficult because the text can/probably uses
                //define, and any relative paths and requires should be relative
                //to that id was it would be found on disk. But this would require
                //bootstrapping a module/require fairly deeply from node core.
                //Not sure how best to go about that yet.
                throw new Error('amdefine does not implement load.fromText');
            };
    
            return load;
        }
    
        makeRequire = function (systemRequire, exports, module, relId) {
            function amdRequire(deps, callback) {
                if (typeof deps === 'string') {
                    //Synchronous, single module require('')
                    return stringRequire(systemRequire, exports, module, deps, relId);
                } else {
                    //Array of dependencies with a callback.
    
                    //Convert the dependencies to modules.
                    deps = deps.map(function (depName) {
                        return stringRequire(systemRequire, exports, module, depName, relId);
                    });
    
                    //Wait for next tick to call back the require call.
                    if (callback) {
                        process.nextTick(function () {
                            callback.apply(null, deps);
                        });
                    }
                }
            }
    
            amdRequire.toUrl = function (filePath) {
                if (filePath.indexOf('.') === 0) {
                    return normalize(filePath, path.dirname(module.filename));
                } else {
                    return filePath;
                }
            };
    
            return amdRequire;
        };
    
        //Favor explicit value, passed in if the module wants to support Node 0.4.
        requireFn = requireFn || function req() {
            return module.require.apply(module, arguments);
        };
    
        function runFactory(id, deps, factory) {
            var r, e, m, result;
    
            if (id) {
                e = loaderCache[id] = {};
                m = {
                    id: id,
                    uri: __filename,
                    exports: e
                };
                r = makeRequire(requireFn, e, m, id);
            } else {
                //Only support one define call per file
                if (alreadyCalled) {
                    throw new Error('amdefine with no module ID cannot be called more than once per file.');
                }
                alreadyCalled = true;
    
                //Use the real variables from node
                //Use module.exports for exports, since
                //the exports in here is amdefine exports.
                e = module.exports;
                m = module;
                r = makeRequire(requireFn, e, m, module.id);
            }
    
            //If there are dependencies, they are strings, so need
            //to convert them to dependency values.
            if (deps) {
                deps = deps.map(function (depName) {
                    return r(depName);
                });
            }
    
            //Call the factory with the right dependencies.
            if (typeof factory === 'function') {
                result = factory.apply(m.exports, deps);
            } else {
                result = factory;
            }
    
            if (result !== undefined) {
                m.exports = result;
                if (id) {
                    loaderCache[id] = m.exports;
                }
            }
        }
    
        stringRequire = function (systemRequire, exports, module, id, relId) {
            //Split the ID by a ! so that
            var index = id.indexOf('!'),
                originalId = id,
                prefix, plugin;
    
            if (index === -1) {
                id = normalize(id, relId);
    
                //Straight module lookup. If it is one of the special dependencies,
                //deal with it, otherwise, delegate to node.
                if (id === 'require') {
                    return makeRequire(systemRequire, exports, module, relId);
                } else if (id === 'exports') {
                    return exports;
                } else if (id === 'module') {
                    return module;
                } else if (loaderCache.hasOwnProperty(id)) {
                    return loaderCache[id];
                } else if (defineCache[id]) {
                    runFactory.apply(null, defineCache[id]);
                    return loaderCache[id];
                } else {
                    if(systemRequire) {
                        return systemRequire(originalId);
                    } else {
                        throw new Error('No module with ID: ' + id);
                    }
                }
            } else {
                //There is a plugin in play.
                prefix = id.substring(0, index);
                id = id.substring(index + 1, id.length);
    
                plugin = stringRequire(systemRequire, exports, module, prefix, relId);
    
                if (plugin.normalize) {
                    id = plugin.normalize(id, makeNormalize(relId));
                } else {
                    //Normalize the ID normally.
                    id = normalize(id, relId);
                }
    
                if (loaderCache[id]) {
                    return loaderCache[id];
                } else {
                    plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
    
                    return loaderCache[id];
                }
            }
        };
    
        //Create a define function specific to the module asking for amdefine.
        function define(id, deps, factory) {
            if (Array.isArray(id)) {
                factory = deps;
                deps = id;
                id = undefined;
            } else if (typeof id !== 'string') {
                factory = id;
                id = deps = undefined;
            }
    
            if (deps && !Array.isArray(deps)) {
                factory = deps;
                deps = undefined;
            }
    
            if (!deps) {
                deps = ['require', 'exports', 'module'];
            }
    
            //Set up properties for this module. If an ID, then use
            //internal cache. If no ID, then use the external variables
            //for this node module.
            if (id) {
                //Put the module in deep freeze until there is a
                //require call for it.
                defineCache[id] = [id, deps, factory];
            } else {
                runFactory(id, deps, factory);
            }
        }
    
        //define.require, which has access to all the values in the
        //cache. Useful for AMD modules that all have IDs in the file,
        //but need to finally export a value to node based on one of those
        //IDs.
        define.require = function (id) {
            if (loaderCache[id]) {
                return loaderCache[id];
            }
    
            if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            }
        };
    
        define.amd = {};
    
        return define;
    }
    
    module.exports = amdefine;
    
  provide("amdefine", module.exports);
}(global));

// pakmanager:camelcase
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str) {
    	str = str.trim();
    
    	if (str.length === 1 || !(/[_.\- ]+/).test(str) ) {
    		if (str[0] === str[0].toLowerCase() && str.slice(1) !== str.slice(1).toLowerCase()) {
    			return str;
    		}
    
    		return str.toLowerCase();
    	}
    
    	return str
    	.replace(/^[_.\- ]+/, '')
    	.toLowerCase()
    	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
    		return p1.toUpperCase();
    	});
    };
    
  provide("camelcase", module.exports);
}(global));

// pakmanager:cliui
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrap = require('wordwrap'),
      align = {
        right: require('right-align'),
        center: require('center-align')
      },
      top = 0,
      right = 1,
      bottom = 2,
      left = 3
    
    function UI (opts) {
      this.width = opts.width
      this.wrap = opts.wrap
      this.rows = []
    }
    
    UI.prototype.span = function () {
      var cols = this.div.apply(this, arguments)
      cols.span = true
    }
    
    UI.prototype.div = function () {
      if (arguments.length === 0) this.div('')
      if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {
        return this._applyLayoutDSL(arguments[0])
      }
    
      var cols = []
    
      for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {
        if (typeof arg === 'string') cols.push(this._colFromString(arg))
        else cols.push(arg)
      }
    
      this.rows.push(cols)
      return cols
    }
    
    UI.prototype._shouldApplyLayoutDSL = function () {
      return arguments.length === 1 && typeof arguments[0] === 'string' &&
        /[\t\n]/.test(arguments[0])
    }
    
    UI.prototype._applyLayoutDSL = function (str) {
      var _this = this,
        rows = str.split('\n'),
        leftColumnWidth = 0
    
      // simple heuristic for layout, make sure the
      // second column lines up along the left-hand.
      // don't allow the first column to take up more
      // than 50% of the screen.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        if (columns.length > 1 && columns[0].length > leftColumnWidth) {
          leftColumnWidth = Math.min(
            Math.floor(_this.width * 0.5),
            columns[0].length
          )
        }
      })
    
      // generate a table:
      //  replacing ' ' with padding calculations.
      //  using the algorithmically generated width.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        _this.div.apply(_this, columns.map(function (r, i) {
          return {
            text: r.trim(),
            padding: [0, r.match(/\s*$/)[0].length, 0, r.match(/^\s*/)[0].length],
            width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
          }
        }))
      })
    
      return this.rows[this.rows.length - 1]
    }
    
    UI.prototype._colFromString = function (str) {
      return {
        text: str
      }
    }
    
    UI.prototype.toString = function () {
      var _this = this,
        lines = []
    
      _this.rows.forEach(function (row, i) {
        _this.rowToString(row, lines)
      })
    
      // don't display any lines with the
      // hidden flag set.
      lines = lines.filter(function (line) {
        return !line.hidden
      })
    
      return lines.map(function (line) {
        return line.text
      }).join('\n')
    }
    
    UI.prototype.rowToString = function (row, lines) {
      var _this = this,
        paddingLeft,
        rrows = this._rasterize(row),
        str = '',
        ts,
        width,
        wrapWidth
    
      rrows.forEach(function (rrow, r) {
        str = ''
        rrow.forEach(function (col, c) {
          ts = '' // temporary string used during alignment/padding.
          width = row[c].width // the width with padding.
          wrapWidth = _this._negatePadding(row[c]) // the width without padding.
    
          for (var i = 0; i < Math.max(wrapWidth, col.length); i++) {
            ts += col.charAt(i) || ' '
          }
    
          // align the string within its column.
          if (row[c].align && row[c].align !== 'left' && _this.wrap) {
            ts = align[row[c].align](ts.trim() + '\n' + new Array(wrapWidth + 1).join(' '))
              .split('\n')[0]
            if (ts.length < wrapWidth) ts += new Array(width - ts.length).join(' ')
          }
    
          // add left/right padding and print string.
          paddingLeft = (row[c].padding || [0, 0, 0, 0])[left]
          if (paddingLeft) str += new Array(row[c].padding[left] + 1).join(' ')
          str += ts
          if (row[c].padding && row[c].padding[right]) str += new Array(row[c].padding[right] + 1).join(' ')
    
          // if prior row is span, try to render the
          // current row on the prior line.
          if (r === 0 && lines.length > 0) {
            str = _this._renderInline(str, lines[lines.length - 1], paddingLeft)
          }
        })
    
        // remove trailing whitespace.
        lines.push({
          text: str.replace(/ +$/, ''),
          span: row.span
        })
      })
    
      return lines
    }
    
    // if the full 'source' can render in
    // the target line, do so.
    UI.prototype._renderInline = function (source, previousLine, paddingLeft) {
      var target = previousLine.text,
        str = ''
    
      if (!previousLine.span) return source
    
      // if we're not applying wrapping logic,
      // just always append to the span.
      if (!this.wrap) {
        previousLine.hidden = true
        return target + source
      }
    
      for (var i = 0, tc, sc; i < Math.max(source.length, target.length); i++) {
        tc = target.charAt(i) || ' '
        sc = source.charAt(i) || ' '
        // we tried to overwrite a character in the other string.
        if (tc !== ' ' && sc !== ' ') return source
        // there is not enough whitespace to maintain padding.
        if (sc !== ' ' && i < paddingLeft + target.length) return source
        // :thumbsup:
        if (tc === ' ') str += sc
        else str += tc
      }
    
      previousLine.hidden = true
    
      return str
    }
    
    UI.prototype._rasterize = function (row) {
      var _this = this,
        i,
        rrow,
        rrows = [],
        widths = this._columnWidths(row),
        wrapped
    
      // word wrap all columns, and create
      // a data-structure that is easy to rasterize.
      row.forEach(function (col, c) {
        // leave room for left and right padding.
        col.width = widths[c]
        if (_this.wrap) wrapped = wrap.hard(_this._negatePadding(col))(col.text).split('\n')
        else wrapped = col.text.split('\n')
    
        // add top and bottom padding.
        if (col.padding) {
          for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')
          for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')
        }
    
        wrapped.forEach(function (str, r) {
          if (!rrows[r]) rrows.push([])
    
          rrow = rrows[r]
    
          for (var i = 0; i < c; i++) {
            if (rrow[i] === undefined) rrow.push('')
          }
          rrow.push(str)
        })
      })
    
      return rrows
    }
    
    UI.prototype._negatePadding = function (col) {
      var wrapWidth = col.width
      if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)
      return wrapWidth
    }
    
    UI.prototype._columnWidths = function (row) {
      var _this = this,
        widths = [],
        unset = row.length,
        unsetWidth,
        remainingWidth = this.width
    
      // column widths can be set in config.
      row.forEach(function (col, i) {
        if (col.width) {
          unset--
          widths[i] = col.width
          remainingWidth -= col.width
        } else {
          widths[i] = undefined
        }
      })
    
      // any unset widths should be calculated.
      if (unset) unsetWidth = Math.floor(remainingWidth / unset)
      widths.forEach(function (w, i) {
        if (!_this.wrap) widths[i] = row[i].width || row[i].text.length
        else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))
      })
    
      return widths
    }
    
    // calculates the minimum width of
    // a column, based on padding preferences.
    function _minWidth (col) {
      var padding = col.padding || []
    
      return 1 + (padding[left] || 0) + (padding[right] || 0)
    }
    
    module.exports = function (opts) {
      opts = opts || {}
    
      return new UI({
        width: (opts || {}).width || 80,
        wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true
      })
    }
    
  provide("cliui", module.exports);
}(global));

// pakmanager:decamelize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str, sep) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(/([a-z\d])([A-Z])/g, '$1' + (sep || '_') + '$2').toLowerCase();
    };
    
  provide("decamelize", module.exports);
}(global));

// pakmanager:window-size
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * window-size <https://github.com/jonschlinkert/window-size>
     *
     * Copyright (c) 2014-2015 Jon Schlinkert
     * Licensed under the MIT license.
     */
    
    const tty = require('tty');
    
    module.exports = (function() {
      var width;
      var height;
    
      if(tty.isatty(1) && tty.isatty(2)) {
        if(process.stdout.getWindowSize) {
          width = process.stdout.getWindowSize(1)[0];
          height = process.stdout.getWindowSize(1)[1];
        } else if (tty.getWindowSize) {
          width = tty.getWindowSize()[1];
          height = tty.getWindowSize()[0];
        } else if (process.stdout.columns && process.stdout.rows) {
          height = process.stdout.columns;
          width = process.stdout.rows;
        }
      } else {
        new Error('window-size could not get size with tty or process.stdout.');
      }
    
      return {height: height, width: width};
    })();
  provide("window-size", module.exports);
}(global));

// pakmanager:inflight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    var reqs = Object.create(null)
    var once = require('once')
    
    module.exports = wrappy(inflight)
    
    function inflight (key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb)
        return null
      } else {
        reqs[key] = [cb]
        return makeres(key)
      }
    }
    
    function makeres (key) {
      return once(function RES () {
        var cbs = reqs[key]
        var len = cbs.length
        var args = slice(arguments)
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args)
        }
        if (cbs.length > len) {
          // added more in the interim.
          // de-zalgo, just in case, but don't call again.
          cbs.splice(0, len)
          process.nextTick(function () {
            RES.apply(null, args)
          })
        } else {
          delete reqs[key]
        }
      })
    }
    
    function slice (args) {
      var length = args.length
      var array = []
    
      for (var i = 0; i < length; i++) array[i] = args[i]
      return array
    }
    
  provide("inflight", module.exports);
}(global));

// pakmanager:inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('util').inherits
    
  provide("inherits", module.exports);
}(global));

// pakmanager:minimatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = minimatch
    minimatch.Minimatch = Minimatch
    
    var path = { sep: '/' }
    try {
      path = require('path')
    } catch (er) {}
    
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
    var expand = require('brace-expansion')
    
    // any single thing other than /
    // don't need to escape / when using new RegExp()
    var qmark = '[^/]'
    
    // * => any number of characters
    var star = qmark + '*?'
    
    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
    
    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
    
    // characters that need to be escaped in RegExp.
    var reSpecials = charSet('().*{}+?[]^$\\!')
    
    // "abc" -> { a:true, b:true, c:true }
    function charSet (s) {
      return s.split('').reduce(function (set, c) {
        set[c] = true
        return set
      }, {})
    }
    
    // normalizes slashes.
    var slashSplit = /\/+/
    
    minimatch.filter = filter
    function filter (pattern, options) {
      options = options || {}
      return function (p, i, list) {
        return minimatch(p, pattern, options)
      }
    }
    
    function ext (a, b) {
      a = a || {}
      b = b || {}
      var t = {}
      Object.keys(b).forEach(function (k) {
        t[k] = b[k]
      })
      Object.keys(a).forEach(function (k) {
        t[k] = a[k]
      })
      return t
    }
    
    minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return minimatch
    
      var orig = minimatch
    
      var m = function minimatch (p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options))
      }
    
      m.Minimatch = function Minimatch (pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options))
      }
    
      return m
    }
    
    Minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return Minimatch
      return minimatch.defaults(def).Minimatch
    }
    
    function minimatch (p, pattern, options) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
    
      // shortcut: comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        return false
      }
    
      // "" only matches ""
      if (pattern.trim() === '') return p === ''
    
      return new Minimatch(pattern, options).match(p)
    }
    
    function Minimatch (pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options)
      }
    
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
      pattern = pattern.trim()
    
      // windows support: need to use /, not \
      if (path.sep !== '/') {
        pattern = pattern.split(path.sep).join('/')
      }
    
      this.options = options
      this.set = []
      this.pattern = pattern
      this.regexp = null
      this.negate = false
      this.comment = false
      this.empty = false
    
      // make the set of regexps etc.
      this.make()
    }
    
    Minimatch.prototype.debug = function () {}
    
    Minimatch.prototype.make = make
    function make () {
      // don't do it more than once.
      if (this._made) return
    
      var pattern = this.pattern
      var options = this.options
    
      // empty patterns and comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        this.comment = true
        return
      }
      if (!pattern) {
        this.empty = true
        return
      }
    
      // step 1: figure out negation, etc.
      this.parseNegate()
    
      // step 2: expand braces
      var set = this.globSet = this.braceExpand()
    
      if (options.debug) this.debug = console.error
    
      this.debug(this.pattern, set)
    
      // step 3: now we have a set, so turn each one into a series of path-portion
      // matching patterns.
      // These will be regexps, except in the case of "**", which is
      // set to the GLOBSTAR object for globstar behavior,
      // and will not contain any / characters
      set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })
    
      this.debug(this.pattern, set)
    
      // glob --> regexps
      set = set.map(function (s, si, set) {
        return s.map(this.parse, this)
      }, this)
    
      this.debug(this.pattern, set)
    
      // filter out everything that didn't compile properly.
      set = set.filter(function (s) {
        return s.indexOf(false) === -1
      })
    
      this.debug(this.pattern, set)
    
      this.set = set
    }
    
    Minimatch.prototype.parseNegate = parseNegate
    function parseNegate () {
      var pattern = this.pattern
      var negate = false
      var options = this.options
      var negateOffset = 0
    
      if (options.nonegate) return
    
      for (var i = 0, l = pattern.length
        ; i < l && pattern.charAt(i) === '!'
        ; i++) {
        negate = !negate
        negateOffset++
      }
    
      if (negateOffset) this.pattern = pattern.substr(negateOffset)
      this.negate = negate
    }
    
    // Brace expansion:
    // a{b,c}d -> abd acd
    // a{b,}c -> abc ac
    // a{0..3}d -> a0d a1d a2d a3d
    // a{b,c{d,e}f}g -> abg acdfg acefg
    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
    //
    // Invalid sets are not expanded.
    // a{2..}b -> a{2..}b
    // a{b}c -> a{b}c
    minimatch.braceExpand = function (pattern, options) {
      return braceExpand(pattern, options)
    }
    
    Minimatch.prototype.braceExpand = braceExpand
    
    function braceExpand (pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options
        } else {
          options = {}
        }
      }
    
      pattern = typeof pattern === 'undefined'
        ? this.pattern : pattern
    
      if (typeof pattern === 'undefined') {
        throw new Error('undefined pattern')
      }
    
      if (options.nobrace ||
        !pattern.match(/\{.*\}/)) {
        // shortcut. no need to expand.
        return [pattern]
      }
    
      return expand(pattern)
    }
    
    // parse a component of the expanded set.
    // At this point, no pattern may contain "/" in it
    // so we're going to return a 2d array, where each entry is the full
    // pattern, split on '/', and then turned into a regular expression.
    // A regexp is made at the end which joins each array with an
    // escaped /, and another full one which joins each regexp with |.
    //
    // Following the lead of Bash 4.1, note that "**" only has special meaning
    // when it is the *only* thing in a path portion.  Otherwise, any series
    // of * is equivalent to a single *.  Globstar behavior is enabled by
    // default, and can be disabled by setting options.noglobstar.
    Minimatch.prototype.parse = parse
    var SUBPARSE = {}
    function parse (pattern, isSub) {
      var options = this.options
    
      // shortcuts
      if (!options.noglobstar && pattern === '**') return GLOBSTAR
      if (pattern === '') return ''
    
      var re = ''
      var hasMagic = !!options.nocase
      var escaping = false
      // ? => one single character
      var patternListStack = []
      var plType
      var stateChar
      var inClass = false
      var reClassStart = -1
      var classStart = -1
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      var patternStart = pattern.charAt(0) === '.' ? '' // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
      : '(?!\\.)'
      var self = this
    
      function clearStateChar () {
        if (stateChar) {
          // we had some state-tracking character
          // that wasn't consumed by this pass.
          switch (stateChar) {
            case '*':
              re += star
              hasMagic = true
            break
            case '?':
              re += qmark
              hasMagic = true
            break
            default:
              re += '\\' + stateChar
            break
          }
          self.debug('clearStateChar %j %j', stateChar, re)
          stateChar = false
        }
      }
    
      for (var i = 0, len = pattern.length, c
        ; (i < len) && (c = pattern.charAt(i))
        ; i++) {
        this.debug('%s\t%s %s %j', pattern, i, re, c)
    
        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
          re += '\\' + c
          escaping = false
          continue
        }
    
        switch (c) {
          case '/':
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false
    
          case '\\':
            clearStateChar()
            escaping = true
          continue
    
          // the various stateChar values
          // for the "extglob" stuff.
          case '?':
          case '*':
          case '+':
          case '@':
          case '!':
            this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
    
            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              this.debug('  in class')
              if (c === '!' && i === classStart + 1) c = '^'
              re += c
              continue
            }
    
            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            self.debug('call clearStateChar %j', stateChar)
            clearStateChar()
            stateChar = c
            // if extglob is disabled, then +(asdf|foo) isn't a thing.
            // just clear the statechar *now*, rather than even diving into
            // the patternList stuff.
            if (options.noext) clearStateChar()
          continue
    
          case '(':
            if (inClass) {
              re += '('
              continue
            }
    
            if (!stateChar) {
              re += '\\('
              continue
            }
    
            plType = stateChar
            patternListStack.push({ type: plType, start: i - 1, reStart: re.length })
            // negation is (?:(?!js)[^/]*)
            re += stateChar === '!' ? '(?:(?!' : '(?:'
            this.debug('plType %j %j', stateChar, re)
            stateChar = false
          continue
    
          case ')':
            if (inClass || !patternListStack.length) {
              re += '\\)'
              continue
            }
    
            clearStateChar()
            hasMagic = true
            re += ')'
            plType = patternListStack.pop().type
            // negation is (?:(?!js)[^/]*)
            // The others are (?:<pattern>)<type>
            switch (plType) {
              case '!':
                re += '[^/]*?)'
                break
              case '?':
              case '+':
              case '*':
                re += plType
                break
              case '@': break // the default anyway
            }
          continue
    
          case '|':
            if (inClass || !patternListStack.length || escaping) {
              re += '\\|'
              escaping = false
              continue
            }
    
            clearStateChar()
            re += '|'
          continue
    
          // these are mostly the same in regexp and glob
          case '[':
            // swallow any state-tracking char before the [
            clearStateChar()
    
            if (inClass) {
              re += '\\' + c
              continue
            }
    
            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
          continue
    
          case ']':
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += '\\' + c
              escaping = false
              continue
            }
    
            // handle the case where we left a class open.
            // "[z-a]" is valid, equivalent to "\[z-a\]"
            if (inClass) {
              // split where the last [ was, make sure we don't have
              // an invalid re. if so, re-walk the contents of the
              // would-be class to re-translate any characters that
              // were passed through as-is
              // TODO: It would probably be faster to determine this
              // without a try/catch and a new RegExp, but it's tricky
              // to do safely.  For now, this is safe and works.
              var cs = pattern.substring(classStart + 1, i)
              try {
                RegExp('[' + cs + ']')
              } catch (er) {
                // not a valid class!
                var sp = this.parse(cs, SUBPARSE)
                re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
                hasMagic = hasMagic || sp[1]
                inClass = false
                continue
              }
            }
    
            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
          continue
    
          default:
            // swallow any state char that wasn't consumed
            clearStateChar()
    
            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
              && !(c === '^' && inClass)) {
              re += '\\'
            }
    
            re += c
    
        } // switch
      } // for
    
      // handle the case where we left a class open.
      // "[abc" is valid, equivalent to "\[abc"
      if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1)
        sp = this.parse(cs, SUBPARSE)
        re = re.substr(0, reClassStart) + '\\[' + sp[0]
        hasMagic = hasMagic || sp[1]
      }
    
      // handle the case where we had a +( thing at the *end*
      // of the pattern.
      // each pattern list stack adds 3 chars, and we need to go through
      // and escape any | chars that were passed through as-is for the regexp.
      // Go through and escape them, taking care not to double-escape any
      // | chars that were already escaped.
      for (var pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3)
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
          if (!$2) {
            // the | isn't already escaped, so escape it.
            $2 = '\\'
          }
    
          // need to escape all those slashes *again*, without escaping the
          // one that we need for escaping the | character.  As it works out,
          // escaping an even number of slashes can be done by simply repeating
          // it exactly after itself.  That's why this trick works.
          //
          // I am sorry that you have to see this.
          return $1 + $1 + $2 + '|'
        })
    
        this.debug('tail=%j\n   %s', tail, tail)
        var t = pl.type === '*' ? star
          : pl.type === '?' ? qmark
          : '\\' + pl.type
    
        hasMagic = true
        re = re.slice(0, pl.reStart) + t + '\\(' + tail
      }
    
      // handle trailing things that only matter at the very end.
      clearStateChar()
      if (escaping) {
        // trailing \\
        re += '\\\\'
      }
    
      // only need to apply the nodot start if the re starts with
      // something that could conceivably capture a dot
      var addPatternStart = false
      switch (re.charAt(0)) {
        case '.':
        case '[':
        case '(': addPatternStart = true
      }
    
      // if the re is not "" at this point, then we need to make sure
      // it doesn't match against an empty path part.
      // Otherwise a/* will match a/, which it should not.
      if (re !== '' && hasMagic) re = '(?=.)' + re
    
      if (addPatternStart) re = patternStart + re
    
      // parsing just a piece of a larger pattern.
      if (isSub === SUBPARSE) {
        return [re, hasMagic]
      }
    
      // skip the regexp for non-magical patterns
      // unescape anything in it, though, so that it'll be
      // an exact match against a file etc.
      if (!hasMagic) {
        return globUnescape(pattern)
      }
    
      var flags = options.nocase ? 'i' : ''
      var regExp = new RegExp('^' + re + '$', flags)
    
      regExp._glob = pattern
      regExp._src = re
    
      return regExp
    }
    
    minimatch.makeRe = function (pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe()
    }
    
    Minimatch.prototype.makeRe = makeRe
    function makeRe () {
      if (this.regexp || this.regexp === false) return this.regexp
    
      // at this point, this.set is a 2d array of partial
      // pattern strings, or "**".
      //
      // It's better to use .match().  This function shouldn't
      // be used, really, but it's pretty convenient sometimes,
      // when you just want to work with a regex.
      var set = this.set
    
      if (!set.length) {
        this.regexp = false
        return this.regexp
      }
      var options = this.options
    
      var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
        : twoStarNoDot
      var flags = options.nocase ? 'i' : ''
    
      var re = set.map(function (pattern) {
        return pattern.map(function (p) {
          return (p === GLOBSTAR) ? twoStar
          : (typeof p === 'string') ? regExpEscape(p)
          : p._src
        }).join('\\\/')
      }).join('|')
    
      // must match entire pattern
      // ending in a * or ** will make it less strict.
      re = '^(?:' + re + ')$'
    
      // can match anything, as long as it's not this.
      if (this.negate) re = '^(?!' + re + ').*$'
    
      try {
        this.regexp = new RegExp(re, flags)
      } catch (ex) {
        this.regexp = false
      }
      return this.regexp
    }
    
    minimatch.match = function (list, pattern, options) {
      options = options || {}
      var mm = new Minimatch(pattern, options)
      list = list.filter(function (f) {
        return mm.match(f)
      })
      if (mm.options.nonull && !list.length) {
        list.push(pattern)
      }
      return list
    }
    
    Minimatch.prototype.match = match
    function match (f, partial) {
      this.debug('match', f, this.pattern)
      // short-circuit in the case of busted things.
      // comments, etc.
      if (this.comment) return false
      if (this.empty) return f === ''
    
      if (f === '/' && partial) return true
    
      var options = this.options
    
      // windows: need to use /, not \
      if (path.sep !== '/') {
        f = f.split(path.sep).join('/')
      }
    
      // treat the test path as a set of pathparts.
      f = f.split(slashSplit)
      this.debug(this.pattern, 'split', f)
    
      // just ONE of the pattern sets in this.set needs to match
      // in order for it to be valid.  If negating, then just one
      // match means that we have failed.
      // Either way, return on the first hit.
    
      var set = this.set
      this.debug(this.pattern, 'set', set)
    
      // Find the basename of the path by looking for the last non-empty segment
      var filename
      var i
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i]
        if (filename) break
      }
    
      for (i = 0; i < set.length; i++) {
        var pattern = set[i]
        var file = f
        if (options.matchBase && pattern.length === 1) {
          file = [filename]
        }
        var hit = this.matchOne(file, pattern, partial)
        if (hit) {
          if (options.flipNegate) return true
          return !this.negate
        }
      }
    
      // didn't get any hits.  this is success if it's a negative
      // pattern, failure otherwise.
      if (options.flipNegate) return false
      return this.negate
    }
    
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    Minimatch.prototype.matchOne = function (file, pattern, partial) {
      var options = this.options
    
      this.debug('matchOne',
        { 'this': this, file: file, pattern: pattern })
    
      this.debug('matchOne', file.length, pattern.length)
    
      for (var fi = 0,
          pi = 0,
          fl = file.length,
          pl = pattern.length
          ; (fi < fl) && (pi < pl)
          ; fi++, pi++) {
        this.debug('matchOne loop')
        var p = pattern[pi]
        var f = file[fi]
    
        this.debug(pattern, p, f)
    
        // should be impossible.
        // some invalid regexp stuff in the set.
        if (p === false) return false
    
        if (p === GLOBSTAR) {
          this.debug('GLOBSTAR', [pattern, p, f])
    
          // "**"
          // a/**/b/**/c would match the following:
          // a/b/x/y/z/c
          // a/x/y/z/b/c
          // a/b/x/b/x/c
          // a/b/c
          // To do this, take the rest of the pattern after
          // the **, and see if it would match the file remainder.
          // If so, return success.
          // If not, the ** "swallows" a segment, and try again.
          // This is recursively awful.
          //
          // a/**/b/**/c matching a/b/x/y/z/c
          // - a matches a
          // - doublestar
          //   - matchOne(b/x/y/z/c, b/**/c)
          //     - b matches b
          //     - doublestar
          //       - matchOne(x/y/z/c, c) -> no
          //       - matchOne(y/z/c, c) -> no
          //       - matchOne(z/c, c) -> no
          //       - matchOne(c, c) yes, hit
          var fr = fi
          var pr = pi + 1
          if (pr === pl) {
            this.debug('** at the end')
            // a ** at the end will just swallow the rest.
            // We have found a match.
            // however, it will not swallow /.x, unless
            // options.dot is set.
            // . and .. are *never* matched by **, for explosively
            // exponential reasons.
            for (; fi < fl; fi++) {
              if (file[fi] === '.' || file[fi] === '..' ||
                (!options.dot && file[fi].charAt(0) === '.')) return false
            }
            return true
          }
    
          // ok, let's see if we can swallow whatever we can.
          while (fr < fl) {
            var swallowee = file[fr]
    
            this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
    
            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug('globstar found match!', fr, fl, swallowee)
              // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === '.' || swallowee === '..' ||
                (!options.dot && swallowee.charAt(0) === '.')) {
                this.debug('dot detected!', file, fr, pattern, pr)
                break
              }
    
              // ** swallows a segment, and continue.
              this.debug('globstar swallow a segment, and continue')
              fr++
            }
          }
    
          // no match was found.
          // However, in partial mode, we can't say this is necessarily over.
          // If there's more *pattern* left, then
          if (partial) {
            // ran out of file
            this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
            if (fr === fl) return true
          }
          return false
        }
    
        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit
        if (typeof p === 'string') {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase()
          } else {
            hit = f === p
          }
          this.debug('string match', p, f, hit)
        } else {
          hit = f.match(p)
          this.debug('pattern match', p, f, hit)
        }
    
        if (!hit) return false
      }
    
      // Note: ending in / means that we'll get a final ""
      // at the end of the pattern.  This can only match a
      // corresponding "" at the end of the file.
      // If the file ends in /, then it can only match a
      // a pattern that ends in /, unless the pattern just
      // doesn't have any more for it. But, a/b/ should *not*
      // match "a/b/*", even though "" matches against the
      // [^/]*? pattern, except in partial mode, where it might
      // simply not be reached yet.
      // However, a/b/ should still satisfy a/*
    
      // now either we fell off the end of the pattern, or we're done.
      if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true
      } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial
      } else if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
        return emptyFileEnd
      }
    
      // should be unreachable.
      throw new Error('wtf?')
    }
    
    // replace stuff like \* with *
    function globUnescape (s) {
      return s.replace(/\\(.)/g, '$1')
    }
    
    function regExpEscape (s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
    }
    
  provide("minimatch", module.exports);
}(global));

// pakmanager:path-is-absolute
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function posix(path) {
    	return path.charAt(0) === '/';
    };
    
    function win32(path) {
    	// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    	var result = splitDeviceRe.exec(path);
    	var device = result[1] || '';
    	var isUnc = !!device && device.charAt(1) !== ':';
    
    	// UNC paths are always absolute
    	return !!result[2] || isUnc;
    };
    
    module.exports = process.platform === 'win32' ? win32 : posix;
    module.exports.posix = posix;
    module.exports.win32 = win32;
    
  provide("path-is-absolute", module.exports);
}(global));

// pakmanager:underscore
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     Underscore.js 1.8.3
    //     http://underscorejs.org
    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    
    (function() {
    
      // Baseline setup
      // --------------
    
      // Establish the root object, `window` in the browser, or `exports` on the server.
      var root = this;
    
      // Save the previous value of the `_` variable.
      var previousUnderscore = root._;
    
      // Save bytes in the minified (but not gzipped) version:
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    
      // Create quick reference variables for speed access to core prototypes.
      var
        push             = ArrayProto.push,
        slice            = ArrayProto.slice,
        toString         = ObjProto.toString,
        hasOwnProperty   = ObjProto.hasOwnProperty;
    
      // All **ECMAScript 5** native function implementations that we hope to use
      // are declared here.
      var
        nativeIsArray      = Array.isArray,
        nativeKeys         = Object.keys,
        nativeBind         = FuncProto.bind,
        nativeCreate       = Object.create;
    
      // Naked function reference for surrogate-prototype-swapping.
      var Ctor = function(){};
    
      // Create a safe reference to the Underscore object for use below.
      var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
      };
    
      // Export the Underscore object for **Node.js**, with
      // backwards-compatibility for the old `require()` API. If we're in
      // the browser, add `_` as a global object.
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
    
      // Current version.
      _.VERSION = '1.8.3';
    
      // Internal function that returns an efficient (for current engines) version
      // of the passed-in callback, to be repeatedly applied in other Underscore
      // functions.
      var optimizeCb = function(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
          case 1: return function(value) {
            return func.call(context, value);
          };
          case 2: return function(value, other) {
            return func.call(context, value, other);
          };
          case 3: return function(value, index, collection) {
            return func.call(context, value, index, collection);
          };
          case 4: return function(accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
        }
        return function() {
          return func.apply(context, arguments);
        };
      };
    
      // A mostly-internal function to generate callbacks that can be applied
      // to each element in a collection, returning the desired result  either
      // identity, an arbitrary callback, a property matcher, or a property accessor.
      var cb = function(value, context, argCount) {
        if (value == null) return _.identity;
        if (_.isFunction(value)) return optimizeCb(value, context, argCount);
        if (_.isObject(value)) return _.matcher(value);
        return _.property(value);
      };
      _.iteratee = function(value, context) {
        return cb(value, context, Infinity);
      };
    
      // An internal function for creating assigner functions.
      var createAssigner = function(keysFunc, undefinedOnly) {
        return function(obj) {
          var length = arguments.length;
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
        };
      };
    
      // An internal function for creating a new object that inherits from another.
      var baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor;
        Ctor.prototype = null;
        return result;
      };
    
      var property = function(key) {
        return function(obj) {
          return obj == null ? void 0 : obj[key];
        };
      };
    
      // Helper for collection methods to determine whether a collection
      // should be iterated as an array or as an object
      // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
      // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      var getLength = property('length');
      var isArrayLike = function(collection) {
        var length = getLength(collection);
        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
      };
    
      // Collection Functions
      // --------------------
    
      // The cornerstone, an `each` implementation, aka `forEach`.
      // Handles raw objects in addition to array-likes. Treats all
      // sparse array-likes as if they were dense.
      _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
          for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
          }
        } else {
          var keys = _.keys(obj);
          for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
          }
        }
        return obj;
      };
    
      // Return the results of applying the iteratee to each element.
      _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
      };
    
      // Create a reducing function iterating left or right.
      function createReduce(dir) {
        // Optimized iterator function as using arguments.length
        // in the main function will deoptimize the, see #1991.
        function iterator(obj, iteratee, memo, keys, index, length) {
          for (; index >= 0 && index < length; index += dir) {
            var currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        }
    
        return function(obj, iteratee, memo, context) {
          iteratee = optimizeCb(iteratee, context, 4);
          var keys = !isArrayLike(obj) && _.keys(obj),
              length = (keys || obj).length,
              index = dir > 0 ? 0 : length - 1;
          // Determine the initial value if none is provided.
          if (arguments.length < 3) {
            memo = obj[keys ? keys[index] : index];
            index += dir;
          }
          return iterator(obj, iteratee, memo, keys, index, length);
        };
      }
    
      // **Reduce** builds up a single result from a list of values, aka `inject`,
      // or `foldl`.
      _.reduce = _.foldl = _.inject = createReduce(1);
    
      // The right-associative version of reduce, also known as `foldr`.
      _.reduceRight = _.foldr = createReduce(-1);
    
      // Return the first value which passes a truth test. Aliased as `detect`.
      _.find = _.detect = function(obj, predicate, context) {
        var key;
        if (isArrayLike(obj)) {
          key = _.findIndex(obj, predicate, context);
        } else {
          key = _.findKey(obj, predicate, context);
        }
        if (key !== void 0 && key !== -1) return obj[key];
      };
    
      // Return all the elements that pass a truth test.
      // Aliased as `select`.
      _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function(value, index, list) {
          if (predicate(value, index, list)) results.push(value);
        });
        return results;
      };
    
      // Return all the elements for which a truth test fails.
      _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
      };
    
      // Determine whether all of the elements match a truth test.
      // Aliased as `all`.
      _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
      };
    
      // Determine if at least one element in the object matches a truth test.
      // Aliased as `any`.
      _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
      };
    
      // Determine if the array or object contains a given item (using `===`).
      // Aliased as `includes` and `include`.
      _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        if (typeof fromIndex != 'number' || guard) fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0;
      };
    
      // Invoke a method (with arguments) on every item in a collection.
      _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
          var func = isFunc ? method : value[method];
          return func == null ? func : func.apply(value, args);
        });
      };
    
      // Convenience version of a common use case of `map`: fetching a property.
      _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
      };
    
      // Convenience version of a common use case of `filter`: selecting only objects
      // containing specific `key:value` pairs.
      _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
      };
    
      // Convenience version of a common use case of `find`: getting the first object
      // containing specific `key:value` pairs.
      _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
      };
    
      // Return the maximum element (or element-based computation).
      _.max = function(obj, iteratee, context) {
        var result = -Infinity, lastComputed = -Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value > result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
              result = value;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Return the minimum element (or element-based computation).
      _.min = function(obj, iteratee, context) {
        var result = Infinity, lastComputed = Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value < result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
              result = value;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
    
      // Shuffle a collection, using the modern version of the
      // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
      _.shuffle = function(obj) {
        var set = isArrayLike(obj) ? obj : _.values(obj);
        var length = set.length;
        var shuffled = Array(length);
        for (var index = 0, rand; index < length; index++) {
          rand = _.random(0, index);
          if (rand !== index) shuffled[index] = shuffled[rand];
          shuffled[rand] = set[index];
        }
        return shuffled;
      };
    
      // Sample **n** random values from a collection.
      // If **n** is not specified, returns a single random element.
      // The internal `guard` argument allows it to work with `map`.
      _.sample = function(obj, n, guard) {
        if (n == null || guard) {
          if (!isArrayLike(obj)) obj = _.values(obj);
          return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
      };
    
      // Sort the object's values by a criterion produced by an iteratee.
      _.sortBy = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function(value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iteratee(value, index, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), 'value');
      };
    
      // An internal function used for aggregate "group by" operations.
      var group = function(behavior) {
        return function(obj, iteratee, context) {
          var result = {};
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
          });
          return result;
        };
      };
    
      // Groups the object's values by a criterion. Pass either a string attribute
      // to group by, or a function that returns the criterion.
      _.groupBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key].push(value); else result[key] = [value];
      });
    
      // Indexes the object's values by a criterion, similar to `groupBy`, but for
      // when you know that your index values will be unique.
      _.indexBy = group(function(result, value, key) {
        result[key] = value;
      });
    
      // Counts instances of an object that group by a certain criterion. Pass
      // either a string attribute to count by, or a function that returns the
      // criterion.
      _.countBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key]++; else result[key] = 1;
      });
    
      // Safely create a real, live array from anything iterable.
      _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (isArrayLike(obj)) return _.map(obj, _.identity);
        return _.values(obj);
      };
    
      // Return the number of elements in an object.
      _.size = function(obj) {
        if (obj == null) return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length;
      };
    
      // Split a collection into two arrays: one whose elements all satisfy the given
      // predicate, and one whose elements all do not satisfy the predicate.
      _.partition = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var pass = [], fail = [];
        _.each(obj, function(value, key, obj) {
          (predicate(value, key, obj) ? pass : fail).push(value);
        });
        return [pass, fail];
      };
    
      // Array Functions
      // ---------------
    
      // Get the first element of an array. Passing **n** will return the first N
      // values in the array. Aliased as `head` and `take`. The **guard** check
      // allows it to work with `_.map`.
      _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[0];
        return _.initial(array, array.length - n);
      };
    
      // Returns everything but the last entry of the array. Especially useful on
      // the arguments object. Passing **n** will return all the values in
      // the array, excluding the last N.
      _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
      };
    
      // Get the last element of an array. Passing **n** will return the last N
      // values in the array.
      _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n));
      };
    
      // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
      // Especially useful on the arguments object. Passing an **n** will return
      // the rest N values in the array.
      _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
    
      // Trim out all falsy values from an array.
      _.compact = function(array) {
        return _.filter(array, _.identity);
      };
    
      // Internal implementation of a recursive `flatten` function.
      var flatten = function(input, shallow, strict, startIndex) {
        var output = [], idx = 0;
        for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
          var value = input[i];
          if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
            //flatten current level of array or arguments object
            if (!shallow) value = flatten(value, shallow, strict);
            var j = 0, len = value.length;
            output.length += len;
            while (j < len) {
              output[idx++] = value[j++];
            }
          } else if (!strict) {
            output[idx++] = value;
          }
        }
        return output;
      };
    
      // Flatten out an array, either recursively (by default), or just one level.
      _.flatten = function(array, shallow) {
        return flatten(array, shallow, false);
      };
    
      // Return a version of the array that does not contain the specified value(s).
      _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
      };
    
      // Produce a duplicate-free version of the array. If the array has already
      // been sorted, you have the option of using a faster algorithm.
      // Aliased as `unique`.
      _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
          context = iteratee;
          iteratee = isSorted;
          isSorted = false;
        }
        if (iteratee != null) iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
          var value = array[i],
              computed = iteratee ? iteratee(value, i, array) : value;
          if (isSorted) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
          } else if (iteratee) {
            if (!_.contains(seen, computed)) {
              seen.push(computed);
              result.push(value);
            }
          } else if (!_.contains(result, value)) {
            result.push(value);
          }
        }
        return result;
      };
    
      // Produce an array that contains the union: each distinct element from all of
      // the passed-in arrays.
      _.union = function() {
        return _.uniq(flatten(arguments, true, true));
      };
    
      // Produce an array that contains every item shared between all the
      // passed-in arrays.
      _.intersection = function(array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
          var item = array[i];
          if (_.contains(result, item)) continue;
          for (var j = 1; j < argsLength; j++) {
            if (!_.contains(arguments[j], item)) break;
          }
          if (j === argsLength) result.push(item);
        }
        return result;
      };
    
      // Take the difference between one array and a number of other arrays.
      // Only the elements present in just the first array will remain.
      _.difference = function(array) {
        var rest = flatten(arguments, true, true, 1);
        return _.filter(array, function(value){
          return !_.contains(rest, value);
        });
      };
    
      // Zip together multiple lists into a single array -- elements that share
      // an index go together.
      _.zip = function() {
        return _.unzip(arguments);
      };
    
      // Complement of _.zip. Unzip accepts an array of arrays and groups
      // each array's elements on shared indices
      _.unzip = function(array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);
    
        for (var index = 0; index < length; index++) {
          result[index] = _.pluck(array, index);
        }
        return result;
      };
    
      // Converts lists into objects. Pass either a single array of `[key, value]`
      // pairs, or two parallel arrays of the same length -- one of keys, and one of
      // the corresponding values.
      _.object = function(list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
    
      // Generator function to create the findIndex and findLastIndex functions
      function createPredicateIndexFinder(dir) {
        return function(array, predicate, context) {
          predicate = cb(predicate, context);
          var length = getLength(array);
          var index = dir > 0 ? 0 : length - 1;
          for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
          }
          return -1;
        };
      }
    
      // Returns the first index on an array-like that passes a predicate test
      _.findIndex = createPredicateIndexFinder(1);
      _.findLastIndex = createPredicateIndexFinder(-1);
    
      // Use a comparator function to figure out the smallest index at which
      // an object should be inserted so as to maintain order. Uses binary search.
      _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
        }
        return low;
      };
    
      // Generator function to create the indexOf and lastIndexOf functions
      function createIndexFinder(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
          var i = 0, length = getLength(array);
          if (typeof idx == 'number') {
            if (dir > 0) {
                i = idx >= 0 ? idx : Math.max(idx + length, i);
            } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
          } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
          }
          if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1;
          }
          for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
          }
          return -1;
        };
      }
    
      // Return the position of the first occurrence of an item in an array,
      // or -1 if the item is not included in the array.
      // If the array is large and already in sort order, pass `true`
      // for **isSorted** to use binary search.
      _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
      _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
    
      // Generate an integer Array containing an arithmetic progression. A port of
      // the native Python `range()` function. See
      // [the Python documentation](http://docs.python.org/library/functions.html#range).
      _.range = function(start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0;
        }
        step = step || 1;
    
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
    
        for (var idx = 0; idx < length; idx++, start += step) {
          range[idx] = start;
        }
    
        return range;
      };
    
      // Function (ahem) Functions
      // ------------------
    
      // Determines whether to execute a function as a constructor
      // or a normal function with the provided arguments
      var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result)) return result;
        return self;
      };
    
      // Create a function bound to a given object (assigning `this`, and arguments,
      // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
      // available.
      _.bind = function(func, context) {
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
        var args = slice.call(arguments, 2);
        var bound = function() {
          return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
        };
        return bound;
      };
    
      // Partially apply a function by creating a version that has had some of its
      // arguments pre-filled, without changing its dynamic `this` context. _ acts
      // as a placeholder, allowing any combination of arguments to be pre-filled.
      _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        var bound = function() {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i = 0; i < length; i++) {
            args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
          }
          while (position < arguments.length) args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args);
        };
        return bound;
      };
    
      // Bind a number of an object's methods to that object. Remaining arguments
      // are the method names to be bound. Useful for ensuring that all callbacks
      // defined on an object belong to it.
      _.bindAll = function(obj) {
        var i, length = arguments.length, key;
        if (length <= 1) throw new Error('bindAll must be passed function names');
        for (i = 1; i < length; i++) {
          key = arguments[i];
          obj[key] = _.bind(obj[key], obj);
        }
        return obj;
      };
    
      // Memoize an expensive function by storing its results.
      _.memoize = function(func, hasher) {
        var memoize = function(key) {
          var cache = memoize.cache;
          var address = '' + (hasher ? hasher.apply(this, arguments) : key);
          if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
          return cache[address];
        };
        memoize.cache = {};
        return memoize;
      };
    
      // Delays a function for the given number of milliseconds, and then calls
      // it with the arguments supplied.
      _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function(){
          return func.apply(null, args);
        }, wait);
      };
    
      // Defers a function, scheduling it to run after the current call stack has
      // cleared.
      _.defer = _.partial(_.delay, _, 1);
    
      // Returns a function, that, when invoked, will only be triggered at most once
      // during a given window of time. Normally, the throttled function will run
      // as much as it can, without ever going more than once per `wait` duration;
      // but if you'd like to disable the execution on the leading edge, pass
      // `{leading: false}`. To disable execution on the trailing edge, ditto.
      _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
          previous = options.leading === false ? 0 : _.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        };
        return function() {
          var now = _.now();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      };
    
      // Returns a function, that, as long as it continues to be invoked, will not
      // be triggered. The function will be called after it stops being called for
      // N milliseconds. If `immediate` is passed, trigger the function on the
      // leading edge, instead of the trailing.
      _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
    
        var later = function() {
          var last = _.now() - timestamp;
    
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              if (!timeout) context = args = null;
            }
          }
        };
    
        return function() {
          context = this;
          args = arguments;
          timestamp = _.now();
          var callNow = immediate && !timeout;
          if (!timeout) timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
    
          return result;
        };
      };
    
      // Returns the first function passed as an argument to the second,
      // allowing you to adjust arguments, run code before and after, and
      // conditionally execute the original function.
      _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
      };
    
      // Returns a negated version of the passed-in predicate.
      _.negate = function(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      };
    
      // Returns a function that is the composition of a list of functions, each
      // consuming the return value of the function that follows.
      _.compose = function() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
          var i = start;
          var result = args[start].apply(this, arguments);
          while (i--) result = args[i].call(this, result);
          return result;
        };
      };
    
      // Returns a function that will only be executed on and after the Nth call.
      _.after = function(times, func) {
        return function() {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
    
      // Returns a function that will only be executed up to (but not including) the Nth call.
      _.before = function(times, func) {
        var memo;
        return function() {
          if (--times > 0) {
            memo = func.apply(this, arguments);
          }
          if (times <= 1) func = null;
          return memo;
        };
      };
    
      // Returns a function that will be executed at most one time, no matter how
      // often you call it. Useful for lazy initialization.
      _.once = _.partial(_.before, 2);
    
      // Object Functions
      // ----------------
    
      // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
      var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
      var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                          'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    
      function collectNonEnumProps(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
    
        // Constructor is a special case.
        var prop = 'constructor';
        if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
    
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
            keys.push(prop);
          }
        }
      }
    
      // Retrieve the names of an object's own properties.
      // Delegates to **ECMAScript 5**'s native `Object.keys`
      _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve all the property names of an object.
      _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
    
      // Retrieve the values of an object's properties.
      _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
    
      // Returns the results of applying the iteratee to each element of the object
      // In contrast to _.map it returns an object
      _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys =  _.keys(obj),
              length = keys.length,
              results = {},
              currentKey;
          for (var index = 0; index < length; index++) {
            currentKey = keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
      };
    
      // Convert an object into a list of `[key, value]` pairs.
      _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [keys[i], obj[keys[i]]];
        }
        return pairs;
      };
    
      // Invert the keys and values of an object. The values must be serializable.
      _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
    
      // Return a sorted list of the function names available on the object.
      // Aliased as `methods`
      _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
      };
    
      // Extend a given object with all the properties in passed-in object(s).
      _.extend = createAssigner(_.allKeys);
    
      // Assigns a given object with all the own properties in the passed-in object(s)
      // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
      _.extendOwn = _.assign = createAssigner(_.keys);
    
      // Returns the first key on an object that passes a predicate test
      _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj), key;
        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];
          if (predicate(obj[key], key, obj)) return key;
        }
      };
    
      // Return a copy of the object only containing the whitelisted properties.
      _.pick = function(object, oiteratee, context) {
        var result = {}, obj = object, iteratee, keys;
        if (obj == null) return result;
        if (_.isFunction(oiteratee)) {
          keys = _.allKeys(obj);
          iteratee = optimizeCb(oiteratee, context);
        } else {
          keys = flatten(arguments, false, false, 1);
          iteratee = function(value, key, obj) { return key in obj; };
          obj = Object(obj);
        }
        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          var value = obj[key];
          if (iteratee(value, key, obj)) result[key] = value;
        }
        return result;
      };
    
       // Return a copy of the object without the blacklisted properties.
      _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) {
          iteratee = _.negate(iteratee);
        } else {
          var keys = _.map(flatten(arguments, false, false, 1), String);
          iteratee = function(value, key) {
            return !_.contains(keys, key);
          };
        }
        return _.pick(obj, iteratee, context);
      };
    
      // Fill in a given object with default properties.
      _.defaults = createAssigner(_.allKeys, true);
    
      // Creates an object that inherits from the given prototype object.
      // If additional properties are provided then they will be added to the
      // created object.
      _.create = function(prototype, props) {
        var result = baseCreate(prototype);
        if (props) _.extendOwn(result, props);
        return result;
      };
    
      // Create a (shallow-cloned) duplicate of an object.
      _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
    
      // Invokes interceptor with the obj, and then returns obj.
      // The primary purpose of this method is to "tap into" a method chain, in
      // order to perform operations on intermediate results within the chain.
      _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
      };
    
      // Returns whether an object has a given set of `key:value` pairs.
      _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
      };
    
    
      // Internal recursive comparison function for `isEqual`.
      var eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
          // Strings, numbers, regular expressions, dates, and booleans are compared by value.
          case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        }
    
        var areArrays = className === '[object Array]';
        if (!areArrays) {
          if (typeof a != 'object' || typeof b != 'object') return false;
    
          // Objects with different constructors are not equivalent, but `Object`s or `Array`s
          // from different frames are.
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                                   _.isFunction(bCtor) && bCtor instanceof bCtor)
                              && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          // Linear search. Performance is inversely proportional to the number of
          // unique nested structures.
          if (aStack[length] === a) return bStack[length] === b;
        }
    
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
    
        // Recursively compare objects and arrays.
        if (areArrays) {
          // Compare array lengths to determine if a deep comparison is necessary.
          length = a.length;
          if (length !== b.length) return false;
          // Deep compare the contents, ignoring non-numeric properties.
          while (length--) {
            if (!eq(a[length], b[length], aStack, bStack)) return false;
          }
        } else {
          // Deep compare objects.
          var keys = _.keys(a), key;
          length = keys.length;
          // Ensure that both objects contain the same number of properties before comparing deep equality.
          if (_.keys(b).length !== length) return false;
          while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
          }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
      };
    
      // Perform a deep comparison to check if two objects are equal.
      _.isEqual = function(a, b) {
        return eq(a, b);
      };
    
      // Is a given array, string, or object empty?
      // An "empty" object has no enumerable own-properties.
      _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
        return _.keys(obj).length === 0;
      };
    
      // Is a given value a DOM element?
      _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
      };
    
      // Is a given value an array?
      // Delegates to ECMA5's native Array.isArray
      _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) === '[object Array]';
      };
    
      // Is a given variable an object?
      _.isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
      };
    
      // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
      _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
        _['is' + name] = function(obj) {
          return toString.call(obj) === '[object ' + name + ']';
        };
      });
    
      // Define a fallback version of the method in browsers (ahem, IE < 9), where
      // there isn't any inspectable "Arguments" type.
      if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
          return _.has(obj, 'callee');
        };
      }
    
      // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
      // IE 11 (#1621), and in Safari 8 (#1929).
      if (typeof /./ != 'function' && typeof Int8Array != 'object') {
        _.isFunction = function(obj) {
          return typeof obj == 'function' || false;
        };
      }
    
      // Is a given object a finite number?
      _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      };
    
      // Is the given value `NaN`? (NaN is the only number which does not equal itself).
      _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
      };
    
      // Is a given value a boolean?
      _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
      };
    
      // Is a given value equal to null?
      _.isNull = function(obj) {
        return obj === null;
      };
    
      // Is a given variable undefined?
      _.isUndefined = function(obj) {
        return obj === void 0;
      };
    
      // Shortcut function for checking if an object has a given property directly
      // on itself (in other words, not on a prototype).
      _.has = function(obj, key) {
        return obj != null && hasOwnProperty.call(obj, key);
      };
    
      // Utility Functions
      // -----------------
    
      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
      // previous owner. Returns a reference to the Underscore object.
      _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
      };
    
      // Keep the identity function around for default iteratees.
      _.identity = function(value) {
        return value;
      };
    
      // Predicate-generating functions. Often useful outside of Underscore.
      _.constant = function(value) {
        return function() {
          return value;
        };
      };
    
      _.noop = function(){};
    
      _.property = property;
    
      // Generates a function for a given object that returns a given property.
      _.propertyOf = function(obj) {
        return obj == null ? function(){} : function(key) {
          return obj[key];
        };
      };
    
      // Returns a predicate for checking whether an object has a given set of
      // `key:value` pairs.
      _.matcher = _.matches = function(attrs) {
        attrs = _.extendOwn({}, attrs);
        return function(obj) {
          return _.isMatch(obj, attrs);
        };
      };
    
      // Run a function **n** times.
      _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee(i);
        return accum;
      };
    
      // Return a random integer between min and max (inclusive).
      _.random = function(min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
    
      // A (possibly faster) way to get the current timestamp as an integer.
      _.now = Date.now || function() {
        return new Date().getTime();
      };
    
       // List of HTML entities for escaping.
      var escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;'
      };
      var unescapeMap = _.invert(escapeMap);
    
      // Functions for escaping and unescaping strings to/from HTML interpolation.
      var createEscaper = function(map) {
        var escaper = function(match) {
          return map[match];
        };
        // Regexes for identifying a key that needs to be escaped
        var source = '(?:' + _.keys(map).join('|') + ')';
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, 'g');
        return function(string) {
          string = string == null ? '' : '' + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      };
      _.escape = createEscaper(escapeMap);
      _.unescape = createEscaper(unescapeMap);
    
      // If the value of the named `property` is a function then invoke it with the
      // `object` as context; otherwise, return it.
      _.result = function(object, property, fallback) {
        var value = object == null ? void 0 : object[property];
        if (value === void 0) {
          value = fallback;
        }
        return _.isFunction(value) ? value.call(object) : value;
      };
    
      // Generate a unique integer id (unique within the entire client session).
      // Useful for temporary DOM ids.
      var idCounter = 0;
      _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      };
    
      // By default, Underscore uses ERB-style template delimiters, change the
      // following template settings to use alternative delimiters.
      _.templateSettings = {
        evaluate    : /<%([\s\S]+?)%>/g,
        interpolate : /<%=([\s\S]+?)%>/g,
        escape      : /<%-([\s\S]+?)%>/g
      };
    
      // When customizing `templateSettings`, if you don't want to define an
      // interpolation, evaluation or escaping regex, we need one that is
      // guaranteed not to match.
      var noMatch = /(.)^/;
    
      // Certain characters need to be escaped so that they can be put into a
      // string literal.
      var escapes = {
        "'":      "'",
        '\\':     '\\',
        '\r':     'r',
        '\n':     'n',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
    
      var escapeChar = function(match) {
        return '\\' + escapes[match];
      };
    
      // JavaScript micro-templating, similar to John Resig's implementation.
      // Underscore templating handles arbitrary delimiters, preserves whitespace,
      // and correctly escapes quotes within interpolated code.
      // NB: `oldSettings` only exists for backwards compatibility.
      _.template = function(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);
    
        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');
    
        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escaper, escapeChar);
          index = offset + match.length;
    
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
    
          // Adobe VMs need the match returned to produce the correct offest.
          return match;
        });
        source += "';\n";
    
        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    
        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';
    
        try {
          var render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }
    
        var template = function(data) {
          return render.call(this, data, _);
        };
    
        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';
    
        return template;
      };
    
      // Add a "chain" function. Start chaining a wrapped Underscore object.
      _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
      };
    
      // OOP
      // ---------------
      // If Underscore is called as a function, it returns a wrapped object that
      // can be used OO-style. This wrapper holds altered versions of all the
      // underscore functions. Wrapped objects may be chained.
    
      // Helper function to continue chaining intermediate results.
      var result = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
      };
    
      // Add your own custom functions to the Underscore object.
      _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function() {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return result(this, func.apply(_, args));
          };
        });
      };
    
      // Add all of the Underscore functions to the wrapper object.
      _.mixin(_);
    
      // Add all mutator Array functions to the wrapper.
      _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
          return result(this, obj);
        };
      });
    
      // Add all accessor Array functions to the wrapper.
      _.each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          return result(this, method.apply(this._wrapped, arguments));
        };
      });
    
      // Extracts the result from a wrapped and chained object.
      _.prototype.value = function() {
        return this._wrapped;
      };
    
      // Provide unwrapping proxy for some methods used in engine operations
      // such as arithmetic and JSON stringification.
      _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    
      _.prototype.toString = function() {
        return '' + this._wrapped;
      };
    
      // AMD registration happens at the end for compatibility with AMD loaders
      // that may not enforce next-turn semantics on modules. Even though general
      // practice for AMD registration is to be anonymous, underscore registers
      // as a named module because, like jQuery, it is a base library that is
      // popular enough to be bundled in a third party lib, but not be part of
      // an AMD load request. Those cases could generate an error when an
      // anonymous define() is called outside of a loader request.
      if (typeof define === 'function' && define.amd) {
        define('underscore', [], function() {
          return _;
        });
      }
    }.call(this));
    
  provide("underscore", module.exports);
}(global));

// pakmanager:chalk
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var escapeStringRegexp = require('escape-string-regexp');
    var ansiStyles = require('ansi-styles');
    var stripAnsi = require('strip-ansi');
    var hasAnsi = require('has-ansi');
    var supportsColor = require('supports-color');
    var defineProps = Object.defineProperties;
    var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);
    
    function Chalk(options) {
    	// detect mode if not set manually
    	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
    }
    
    // use bright blue on Windows as the normal blue color is illegible
    if (isSimpleWindowsTerm) {
    	ansiStyles.blue.open = '\u001b[94m';
    }
    
    var styles = (function () {
    	var ret = {};
    
    	Object.keys(ansiStyles).forEach(function (key) {
    		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    
    		ret[key] = {
    			get: function () {
    				return build.call(this, this._styles.concat(key));
    			}
    		};
    	});
    
    	return ret;
    })();
    
    var proto = defineProps(function chalk() {}, styles);
    
    function build(_styles) {
    	var builder = function builder() {
    		return applyStyle.apply(builder, arguments);
    	};
    
    	builder._styles = _styles;
    	builder.enabled = this.enabled;
    	// __proto__ is used because we must return a function, but there is
    	// no way to create a function with a different prototype.
    	/*eslint no-proto: 0 */
    	builder.__proto__ = proto;
    
    	return builder;
    }
    
    function applyStyle() {
    	// support varags, but simply cast to string in case there's only one arg
    	var args = arguments;
    	var argsLen = args.length;
    	var str = argsLen !== 0 && String(arguments[0]);
    
    	if (argsLen > 1) {
    		// don't slice `arguments`, it prevents v8 optimizations
    		for (var a = 1; a < argsLen; a++) {
    			str += ' ' + args[a];
    		}
    	}
    
    	if (!this.enabled || !str) {
    		return str;
    	}
    
    	var nestedStyles = this._styles;
    	var i = nestedStyles.length;
    
    	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
    	// see https://github.com/chalk/chalk/issues/58
    	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
    	var originalDim = ansiStyles.dim.open;
    	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
    		ansiStyles.dim.open = '';
    	}
    
    	while (i--) {
    		var code = ansiStyles[nestedStyles[i]];
    
    		// Replace any instances already present with a re-opening code
    		// otherwise only the part of the string until said closing code
    		// will be colored, and the rest will simply be 'plain'.
    		str = code.open + str.replace(code.closeRe, code.open) + code.close;
    	}
    
    	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
    	ansiStyles.dim.open = originalDim;
    
    	return str;
    }
    
    function init() {
    	var ret = {};
    
    	Object.keys(styles).forEach(function (name) {
    		ret[name] = {
    			get: function () {
    				return build.call(this, [name]);
    			}
    		};
    	});
    
    	return ret;
    }
    
    defineProps(Chalk.prototype, init());
    
    module.exports = new Chalk();
    module.exports.styles = ansiStyles;
    module.exports.hasColor = hasAnsi;
    module.exports.stripColor = stripAnsi;
    module.exports.supportsColor = supportsColor;
    
  provide("chalk", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
    
        function setKey (obj, keys, value) {
            var o = obj;
            keys.slice(0,-1).forEach(function (key) {
                if (o[key] === undefined) o[key] = {};
                o = o[key];
            });
    
            var key = keys[keys.length - 1];
            if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
                o[key] = value;
            }
            else if (Array.isArray(o[key])) {
                o[key].push(value);
            }
            else {
                o[key] = [ o[key], value ];
            }
        }
        
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                setArg(m[1], m[2], arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * async
     * https://github.com/caolan/async
     *
     * Copyright 2010-2014 Caolan McMahon
     * Released under the MIT license
     */
    (function () {
    
        var async = {};
        function noop() {}
    
        // global on the server, window in the browser
        var previous_async;
    
        // Establish the root object, `window` (`self`) in the browser, `global`
        // on the server, or `this` in some virtual machines. We use `self`
        // instead of `window` for `WebWorker` support.
        var root = typeof self === 'object' && self.self === self && self ||
                typeof global === 'object' && global.global === global && global ||
                this;
    
        if (root != null) {
            previous_async = root.async;
        }
    
        async.noConflict = function () {
            root.async = previous_async;
            return async;
        };
    
        function only_once(fn) {
            var called = false;
            return function() {
                if (called) throw new Error("Callback was already called.");
                called = true;
                fn.apply(this, arguments);
            };
        }
    
        function _once(fn) {
            var called = false;
            return function() {
                if (called) return;
                called = true;
                fn.apply(this, arguments);
            };
        }
    
        //// cross-browser compatiblity functions ////
    
        var _toString = Object.prototype.toString;
    
        var _isArray = Array.isArray || function (obj) {
            return _toString.call(obj) === '[object Array]';
        };
    
        function _isArrayLike(arr) {
            return _isArray(arr) || (
                // has a positive integer length property
                typeof arr.length === "number" &&
                arr.length >= 0 &&
                arr.length % 1 === 0
            );
        }
    
        function _each(coll, iterator) {
            return _isArrayLike(coll) ?
                _arrayEach(coll, iterator) :
                _forEachOf(coll, iterator);
        }
    
        function _arrayEach(arr, iterator) {
            var index = -1,
                length = arr.length;
    
            while (++index < length) {
                iterator(arr[index], index, arr);
            }
        }
    
        function _map(arr, iterator) {
            var index = -1,
                length = arr.length,
                result = Array(length);
    
            while (++index < length) {
                result[index] = iterator(arr[index], index, arr);
            }
            return result;
        }
    
        function _range(count) {
            return _map(Array(count), function (v, i) { return i; });
        }
    
        function _reduce(arr, iterator, memo) {
            _arrayEach(arr, function (x, i, a) {
                memo = iterator(memo, x, i, a);
            });
            return memo;
        }
    
        function _forEachOf(object, iterator) {
            _arrayEach(_keys(object), function (key) {
                iterator(object[key], key);
            });
        }
    
        var _keys = Object.keys || function (obj) {
            var keys = [];
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    keys.push(k);
                }
            }
            return keys;
        };
    
        function _keyIterator(coll) {
            var i = -1;
            var len;
            var keys;
            if (_isArrayLike(coll)) {
                len = coll.length;
                return function next() {
                    i++;
                    return i < len ? i : null;
                };
            } else {
                keys = _keys(coll);
                len = keys.length;
                return function next() {
                    i++;
                    return i < len ? keys[i] : null;
                };
            }
        }
    
        function _baseSlice(arr, start) {
            start = start || 0;
            var index = -1;
            var length = arr.length;
    
            if (start) {
                length -= start;
                length = length < 0 ? 0 : length;
            }
            var result = Array(length);
    
            while (++index < length) {
                result[index] = arr[index + start];
            }
            return result;
        }
    
        function _withoutIndex(iterator) {
            return function (value, index, callback) {
                return iterator(value, callback);
            };
        }
    
        //// exported async module functions ////
    
        //// nextTick implementation with browser-compatible fallback ////
    
        // capture the global reference to guard against fakeTimer mocks
        var _setImmediate;
        if (typeof setImmediate === 'function') {
            _setImmediate = setImmediate;
        }
    
        if (typeof process === 'undefined' || !(process.nextTick)) {
            if (_setImmediate) {
                async.nextTick = function (fn) {
                    // not a direct alias for IE10 compatibility
                    _setImmediate(fn);
                };
                async.setImmediate = async.nextTick;
            }
            else {
                async.nextTick = function (fn) {
                    setTimeout(fn, 0);
                };
                async.setImmediate = async.nextTick;
            }
        }
        else {
            async.nextTick = process.nextTick;
            if (_setImmediate) {
                async.setImmediate = function (fn) {
                  // not a direct alias for IE10 compatibility
                    _setImmediate(fn);
                };
            }
            else {
                async.setImmediate = async.nextTick;
            }
        }
    
        async.forEach =
        async.each = function (arr, iterator, callback) {
            return async.eachOf(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachSeries =
        async.eachSeries = function (arr, iterator, callback) {
            return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
        };
    
    
        async.forEachLimit =
        async.eachLimit = function (arr, limit, iterator, callback) {
            return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachOf =
        async.eachOf = function (object, iterator, callback) {
            callback = _once(callback || noop);
            object = object || [];
            var size = _isArrayLike(object) ? object.length : _keys(object).length;
            var completed = 0;
            if (!size) {
                return callback(null);
            }
            _each(object, function (value, key) {
                iterator(object[key], key, only_once(done));
            });
            function done(err) {
                if (err) {
                    callback(err);
                }
                else {
                    completed += 1;
                    if (completed >= size) {
                        callback(null);
                    }
                }
            }
        };
    
        async.forEachOfSeries =
        async.eachOfSeries = function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            var key = nextKey();
            function iterate() {
                var sync = true;
                if (key === null) {
                    return callback(null);
                }
                iterator(obj[key], key, only_once(function (err) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        key = nextKey();
                        if (key === null) {
                            return callback(null);
                        } else {
                            if (sync) {
                                async.nextTick(iterate);
                            } else {
                                iterate();
                            }
                        }
                    }
                }));
                sync = false;
            }
            iterate();
        };
    
    
    
        async.forEachOfLimit =
        async.eachOfLimit = function (obj, limit, iterator, callback) {
            _eachOfLimit(limit)(obj, iterator, callback);
        };
    
        function _eachOfLimit(limit) {
    
            return function (obj, iterator, callback) {
                callback = _once(callback || noop);
                obj = obj || [];
                var nextKey = _keyIterator(obj);
                if (limit <= 0) {
                    return callback(null);
                }
                var done = false;
                var running = 0;
                var errored = false;
    
                (function replenish () {
                    if (done && running <= 0) {
                        return callback(null);
                    }
    
                    while (running < limit && !errored) {
                        var key = nextKey();
                        if (key === null) {
                            done = true;
                            if (running <= 0) {
                                callback(null);
                            }
                            return;
                        }
                        running += 1;
                        iterator(obj[key], key, only_once(function (err) {
                            running -= 1;
                            if (err) {
                                callback(err);
                                errored = true;
                            }
                            else {
                                replenish();
                            }
                        }));
                    }
                })();
            };
        }
    
    
        function doParallel(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOf, obj, iterator, callback);
            };
        }
        function doParallelLimit(limit, fn) {
            return function (obj, iterator, callback) {
                return fn(_eachOfLimit(limit), obj, iterator, callback);
            };
        }
        function doSeries(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOfSeries, obj, iterator, callback);
            };
        }
    
        function _asyncMap(eachfn, arr, iterator, callback) {
            callback = _once(callback || noop);
            var results = [];
            eachfn(arr, function (value, index, callback) {
                iterator(value, function (err, v) {
                    results[index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.map = doParallel(_asyncMap);
        async.mapSeries = doSeries(_asyncMap);
        async.mapLimit = function (arr, limit, iterator, callback) {
            return _mapLimit(limit)(arr, iterator, callback);
        };
    
        function _mapLimit(limit) {
            return doParallelLimit(limit, _asyncMap);
        }
    
        // reduce only has a series version, as doing reduce in parallel won't
        // work in many situations.
        async.inject =
        async.foldl =
        async.reduce = function (arr, memo, iterator, callback) {
            async.eachOfSeries(arr, function (x, i, callback) {
                iterator(memo, x, function (err, v) {
                    memo = v;
                    callback(err);
                });
            }, function (err) {
                callback(err || null, memo);
            });
        };
    
        async.foldr =
        async.reduceRight = function (arr, memo, iterator, callback) {
            var reversed = _map(arr, function (x) {
                return x;
            }).reverse();
            async.reduce(reversed, memo, iterator, callback);
        };
    
        function _filter(eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            eachfn(arr, function (x, index, callback) {
                iterator(x.value, function (v) {
                    if (v) {
                        results.push(x);
                    }
                    callback();
                });
            }, function () {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        }
    
        async.select =
        async.filter = doParallel(_filter);
    
        async.selectSeries =
        async.filterSeries = doSeries(_filter);
    
        function _reject(eachfn, arr, iterator, callback) {
            _filter(eachfn, arr, function(value, cb) {
                iterator(value, function(v) {
                    cb(!v);
                });
            }, callback);
        }
        async.reject = doParallel(_reject);
        async.rejectSeries = doSeries(_reject);
    
        function _detect(eachfn, arr, iterator, main_callback) {
            eachfn(arr, function (x, index, callback) {
                iterator(x, function (result) {
                    if (result) {
                        main_callback(x);
                        main_callback = noop;
                    }
                    else {
                        callback();
                    }
                });
            }, function () {
                main_callback();
            });
        }
        async.detect = doParallel(_detect);
        async.detectSeries = doSeries(_detect);
    
        async.any =
        async.some = function (arr, iterator, main_callback) {
            async.eachOf(arr, function (x, _, callback) {
                iterator(x, function (v) {
                    if (v) {
                        main_callback(true);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function () {
                main_callback(false);
            });
        };
    
        async.all =
        async.every = function (arr, iterator, main_callback) {
            async.eachOf(arr, function (x, _, callback) {
                iterator(x, function (v) {
                    if (!v) {
                        main_callback(false);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function () {
                main_callback(true);
            });
        };
    
        async.sortBy = function (arr, iterator, callback) {
            async.map(arr, function (x, callback) {
                iterator(x, function (err, criteria) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null, {value: x, criteria: criteria});
                    }
                });
            }, function (err, results) {
                if (err) {
                    return callback(err);
                }
                else {
                    callback(null, _map(results.sort(comparator), function (x) {
                        return x.value;
                    }));
                }
    
            });
    
            function comparator(left, right) {
                var a = left.criteria, b = right.criteria;
                return a < b ? -1 : a > b ? 1 : 0;
            }
        };
    
        async.auto = function (tasks, callback) {
            callback = _once(callback || noop);
            var keys = _keys(tasks);
            var remainingTasks = keys.length;
            if (!remainingTasks) {
                return callback(null);
            }
    
            var results = {};
    
            var listeners = [];
            function addListener(fn) {
                listeners.unshift(fn);
            }
            function removeListener(fn) {
                for (var i = 0; i < listeners.length; i += 1) {
                    if (listeners[i] === fn) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            }
            function taskComplete() {
                remainingTasks--;
                _arrayEach(listeners.slice(0), function (fn) {
                    fn();
                });
            }
    
            addListener(function () {
                if (!remainingTasks) {
                    callback(null, results);
                }
            });
    
            _arrayEach(keys, function (k) {
                var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                function taskCallback(err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    if (err) {
                        var safeResults = {};
                        _arrayEach(_keys(results), function(rkey) {
                            safeResults[rkey] = results[rkey];
                        });
                        safeResults[k] = args;
                        callback(err, safeResults);
                    }
                    else {
                        results[k] = args;
                        async.setImmediate(taskComplete);
                    }
                }
                var requires = task.slice(0, Math.abs(task.length - 1)) || [];
                // prevent dead-locks
                var len = requires.length;
                var dep;
                while (len--) {
                    if (!(dep = tasks[requires[len]])) {
                        throw new Error('Has inexistant dependency');
                    }
                    if (_isArray(dep) && !!~dep.indexOf(k)) {
                        throw new Error('Has cyclic dependencies');
                    }
                }
                function ready() {
                    return _reduce(requires, function (a, x) {
                        return (a && results.hasOwnProperty(x));
                    }, true) && !results.hasOwnProperty(k);
                }
                if (ready()) {
                    task[task.length - 1](taskCallback, results);
                }
                else {
                    addListener(listener);
                }
                function listener() {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                }
            });
        };
    
    
    
        async.retry = function(/*[times,] task [, callback]*/) {
            var DEFAULT_TIMES = 5;
            var DEFAULT_INTERVAL = 0;
    
            var attempts = [];
    
            var opts = {
              times: DEFAULT_TIMES,
              interval: DEFAULT_INTERVAL
            };
    
            function parseTimes(acc, t){
              if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
              } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
              } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof(t));
              }
            }
    
            switch(arguments.length){
                case 1: {
                  opts.task = arguments[0];
                  break;
                }
                case 2 : {
                  if(typeof arguments[0] === 'number' || typeof arguments[0] === 'object'){
                    parseTimes(opts, arguments[0]);
                    opts.task = arguments[1];
                  } else {
                    opts.task = arguments[0];
                    opts.callback = arguments[1];
                  }
                  break;
                }
                case 3: {
                  parseTimes(opts, arguments[0]);
                  opts.task = arguments[1];
                  opts.callback = arguments[2];
                  break;
                }
                default: {
                  throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
                }
              }
    
            function wrappedTask(wrappedCallback, wrappedResults) {
                function retryAttempt(task, finalAttempt) {
                    return function(seriesCallback) {
                        task(function(err, result){
                            seriesCallback(!err || finalAttempt, {err: err, result: result});
                        }, wrappedResults);
                    };
                }
    
                function retryInterval(interval){
                  return function(seriesCallback){
                    setTimeout(function(){
                      seriesCallback(null);
                    }, interval);
                  };
                }
    
                while (opts.times) {
    
                    var finalAttempt = !(opts.times-=1);
                    attempts.push(retryAttempt(opts.task, finalAttempt));
                    if(!finalAttempt && opts.interval > 0){
                      attempts.push(retryInterval(opts.interval));
                    }
                }
    
                async.series(attempts, function(done, data){
                    data = data[data.length - 1];
                    (wrappedCallback || opts.callback)(data.err, data.result);
                });
            }
    
            // If a callback is passed, run this as a controll flow
            return opts.callback ? wrappedTask() : wrappedTask;
        };
    
        async.waterfall = function (tasks, callback) {
            callback = _once(callback || noop);
            if (!_isArray(tasks)) {
                var err = new Error('First argument to waterfall must be an array of functions');
                return callback(err);
            }
            if (!tasks.length) {
                return callback();
            }
            function wrapIterator(iterator) {
                return function (err) {
                    if (err) {
                        callback.apply(null, arguments);
                    }
                    else {
                        var args = _baseSlice(arguments, 1);
                        var next = iterator.next();
                        if (next) {
                            args.push(wrapIterator(next));
                        }
                        else {
                            args.push(callback);
                        }
                        ensureAsync(iterator).apply(null, args);
                    }
                };
            }
            wrapIterator(async.iterator(tasks))();
        };
    
        function _parallel(eachfn, tasks, callback) {
            callback = callback || noop;
            var results = _isArrayLike(tasks) ? [] : {};
    
            eachfn(tasks, function (task, key, callback) {
                task(function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[key] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.parallel = function (tasks, callback) {
            _parallel(async.eachOf, tasks, callback);
        };
    
        async.parallelLimit = function(tasks, limit, callback) {
            _parallel(_eachOfLimit(limit), tasks, callback);
        };
    
        async.series = function (tasks, callback) {
            callback = callback || noop;
            var results = _isArrayLike(tasks) ? [] : {};
    
            async.eachOfSeries(tasks, function (task, key, callback) {
                task(function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[key] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        };
    
        async.iterator = function (tasks) {
            function makeCallback(index) {
                function fn() {
                    if (tasks.length) {
                        tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                }
                fn.next = function () {
                    return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                };
                return fn;
            }
            return makeCallback(0);
        };
    
        async.apply = function (fn) {
            var args = _baseSlice(arguments, 1);
            return function () {
                return fn.apply(
                    null, args.concat(_baseSlice(arguments))
                );
            };
        };
    
        function _concat(eachfn, arr, fn, callback) {
            var result = [];
            eachfn(arr, function (x, index, cb) {
                fn(x, function (err, y) {
                    result = result.concat(y || []);
                    cb(err);
                });
            }, function (err) {
                callback(err, result);
            });
        }
        async.concat = doParallel(_concat);
        async.concatSeries = doSeries(_concat);
    
        async.whilst = function (test, iterator, callback) {
            callback = callback || noop;
            if (test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.whilst(test, iterator, callback);
                });
            }
            else {
                callback(null);
            }
        };
    
        async.doWhilst = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (test.apply(null, args)) {
                    async.doWhilst(iterator, test, callback);
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.until = function (test, iterator, callback) {
            callback = callback || noop;
            if (!test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.until(test, iterator, callback);
                });
            }
            else {
                callback(null);
            }
        };
    
        async.doUntil = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (!test.apply(null, args)) {
                    async.doUntil(iterator, test, callback);
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.during = function (test, iterator, callback) {
            callback = callback || noop;
            test(function(err, truth) {
                if (err) {
                    return callback(err);
                }
                if (truth) {
                    iterator(function (err) {
                        if (err) {
                            return callback(err);
                        }
                        async.during(test, iterator, callback);
                    });
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.doDuring = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                args.push(function (err, truth) {
                    if (err) {
                       return callback(err);
                    }
                    if (truth) {
                        async.doDuring(iterator, test, callback);
                    }
                    else {
                        callback(null);
                    }
                });
                test.apply(null, args);
            });
        };
    
        function _queue(worker, concurrency, payload) {
            if (concurrency == null) {
                concurrency = 1;
            }
            else if(concurrency === 0) {
                throw new Error('Concurrency must not be zero');
            }
            function _insert(q, data, pos, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0 && q.idle()) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                       q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        callback: callback || noop
                    };
    
                    if (pos) {
                        q.tasks.unshift(item);
                    } else {
                        q.tasks.push(item);
                    }
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                });
                async.setImmediate(q.process);
            }
            function _next(q, tasks) {
                return function(){
                    workers -= 1;
                    var args = arguments;
                    _arrayEach(tasks, function (task) {
                        task.callback.apply(task, args);
                    });
                    if (q.tasks.length + workers === 0) {
                        q.drain();
                    }
                    q.process();
                };
            }
    
            var workers = 0;
            var q = {
                tasks: [],
                concurrency: concurrency,
                payload: payload,
                saturated: noop,
                empty: noop,
                drain: noop,
                started: false,
                paused: false,
                push: function (data, callback) {
                    _insert(q, data, false, callback);
                },
                kill: function () {
                    q.drain = noop;
                    q.tasks = [];
                },
                unshift: function (data, callback) {
                    _insert(q, data, true, callback);
                },
                process: function () {
                    if (!q.paused && workers < q.concurrency && q.tasks.length) {
                        while(workers < q.concurrency && q.tasks.length){
                            var tasks = q.payload ?
                                q.tasks.splice(0, q.payload) :
                                q.tasks.splice(0, q.tasks.length);
    
                            var data = _map(tasks, function (task) {
                                return task.data;
                            });
    
                            if (q.tasks.length === 0) {
                                q.empty();
                            }
                            workers += 1;
                            var cb = only_once(_next(q, tasks));
                            worker(data, cb);
                        }
                    }
                },
                length: function () {
                    return q.tasks.length;
                },
                running: function () {
                    return workers;
                },
                idle: function() {
                    return q.tasks.length + workers === 0;
                },
                pause: function () {
                    q.paused = true;
                },
                resume: function () {
                    if (q.paused === false) { return; }
                    q.paused = false;
                    var resumeCount = Math.min(q.concurrency, q.tasks.length);
                    // Need to call q.process once per concurrent
                    // worker to preserve full concurrency after pause
                    for (var w = 1; w <= resumeCount; w++) {
                        async.setImmediate(q.process);
                    }
                }
            };
            return q;
        }
    
        async.queue = function (worker, concurrency) {
            var q = _queue(function (items, cb) {
                worker(items[0], cb);
            }, concurrency, 1);
    
            return q;
        };
    
        async.priorityQueue = function (worker, concurrency) {
    
            function _compareTasks(a, b){
                return a.priority - b.priority;
            }
    
            function _binarySearch(sequence, item, compare) {
              var beg = -1,
                  end = sequence.length - 1;
              while (beg < end) {
                  var mid = beg + ((end - beg + 1) >>> 1);
                  if (compare(item, sequence[mid]) >= 0) {
                      beg = mid;
                  } else {
                      end = mid - 1;
                  }
              }
              return beg;
            }
    
            function _insert(q, data, priority, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                        q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        priority: priority,
                        callback: typeof callback === 'function' ? callback : noop
                    };
    
                    q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                    async.setImmediate(q.process);
                });
            }
    
            // Start with a normal queue
            var q = async.queue(worker, concurrency);
    
            // Override push to accept second parameter representing priority
            q.push = function (data, priority, callback) {
                _insert(q, data, priority, callback);
            };
    
            // Remove unshift function
            delete q.unshift;
    
            return q;
        };
    
        async.cargo = function (worker, payload) {
            return _queue(worker, 1, payload);
        };
    
        function _console_fn(name) {
            return function (fn) {
                var args = _baseSlice(arguments, 1);
                fn.apply(null, args.concat([function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (typeof console !== 'undefined') {
                        if (err) {
                            if (console.error) {
                                console.error(err);
                            }
                        }
                        else if (console[name]) {
                            _arrayEach(args, function (x) {
                                console[name](x);
                            });
                        }
                    }
                }]));
            };
        }
        async.log = _console_fn('log');
        async.dir = _console_fn('dir');
        /*async.info = _console_fn('info');
        async.warn = _console_fn('warn');
        async.error = _console_fn('error');*/
    
        async.memoize = function (fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || function (x) {
                return x;
            };
            function memoized() {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                var key = hasher.apply(null, args);
                if (key in memo) {
                    async.nextTick(function () {
                        callback.apply(null, memo[key]);
                    });
                }
                else if (key in queues) {
                    queues[key].push(callback);
                }
                else {
                    queues[key] = [callback];
                    fn.apply(null, args.concat([function () {
                        memo[key] = _baseSlice(arguments);
                        var q = queues[key];
                        delete queues[key];
                        for (var i = 0, l = q.length; i < l; i++) {
                          q[i].apply(null, arguments);
                        }
                    }]));
                }
            }
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
        };
    
        async.unmemoize = function (fn) {
            return function () {
                return (fn.unmemoized || fn).apply(null, arguments);
            };
        };
    
        function _times(mapper) {
            return function (count, iterator, callback) {
                mapper(_range(count), iterator, callback);
            };
        }
    
        async.times = _times(async.map);
        async.timesSeries = _times(async.mapSeries);
        async.timesLimit = function (count, limit, iterator, callback) {
            return async.mapLimit(_range(count), limit, iterator, callback);
        };
    
        async.seq = function (/* functions... */) {
            var fns = arguments;
            return function () {
                var that = this;
                var args = _baseSlice(arguments);
    
                var callback = args.slice(-1)[0];
                if (typeof callback == 'function') {
                    args.pop();
                } else {
                    callback = noop;
                }
    
                async.reduce(fns, args, function (newargs, fn, cb) {
                    fn.apply(that, newargs.concat([function () {
                        var err = arguments[0];
                        var nextargs = _baseSlice(arguments, 1);
                        cb(err, nextargs);
                    }]));
                },
                function (err, results) {
                    callback.apply(that, [err].concat(results));
                });
            };
        };
    
        async.compose = function (/* functions... */) {
            return async.seq.apply(null, Array.prototype.reverse.call(arguments));
        };
    
    
        function _applyEach(eachfn, fns /*args...*/) {
            function go() {
                var that = this;
                var args = _baseSlice(arguments);
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            }
            if (arguments.length > 2) {
                var args = _baseSlice(arguments, 2);
                return go.apply(this, args);
            }
            else {
                return go;
            }
        }
    
        async.applyEach = function (/*fns, args...*/) {
            var args = _baseSlice(arguments);
            return _applyEach.apply(null, [async.eachOf].concat(args));
        };
        async.applyEachSeries = function (/*fns, args...*/) {
            var args = _baseSlice(arguments);
            return _applyEach.apply(null, [async.eachOfSeries].concat(args));
        };
    
    
        async.forever = function (fn, callback) {
            var done = only_once(callback || noop);
            var task = ensureAsync(fn);
            function next(err) {
                if (err) {
                    return done(err);
                }
                task(next);
            }
            next();
        };
    
        function ensureAsync(fn) {
            return function (/*...args, callback*/) {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                args.push(function () {
                    var innerArgs = arguments;
                    if (sync) {
                        async.setImmediate(function () {
                            callback.apply(null, innerArgs);
                        });
                    } else {
                        callback.apply(null, innerArgs);
                    }
                });
                var sync = true;
                fn.apply(this, args);
                sync = false;
            };
        }
    
        async.ensureAsync = ensureAsync;
    
        async.constant = function constant(/*values...*/) {
            var args = [null].concat(_baseSlice(arguments));
            return function (callback) {
                return callback.apply(this, args);
            };
        };
    
        async.wrapSync =
        async.asyncify = function asyncify(func) {
            return function (/*args..., callback*/) {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                var result;
                try {
                    result = func.apply(this, args);
                } catch (e) {
                    return callback(e);
                }
                callback(null, result);
            };
        };
    
        // Node.js
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = async;
        }
        // AMD / RequireJS
        else if (typeof define !== 'undefined' && define.amd) {
            define([], function () {
                return async;
            });
        }
        // included directly via <script> tag
        else {
            root.async = async;
        }
    
    }());
    
  provide("async", module.exports);
}(global));

// pakmanager:source-map/source-map/base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var charToIntMap = {};
      var intToCharMap = {};
    
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        .split('')
        .forEach(function (ch, index) {
          charToIntMap[ch] = index;
          intToCharMap[index] = ch;
        });
    
      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function base64_encode(aNumber) {
        if (aNumber in intToCharMap) {
          return intToCharMap[aNumber];
        }
        throw new TypeError("Must be between 0 and 63: " + aNumber);
      };
    
      /**
       * Decode a single base 64 digit to an integer.
       */
      exports.decode = function base64_decode(aChar) {
        if (aChar in charToIntMap) {
          return charToIntMap[aChar];
        }
        throw new TypeError("Not a valid base 64 digit: " + aChar);
      };
    
    });
    
  provide("source-map/source-map/base64", module.exports);
}(global));

// pakmanager:source-map/source-map/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
    
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
    
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
    
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
    
      /**
       * Normalizes a path, or the path portion of a URL:
       *
       * - Replaces consequtive slashes with one slash.
       * - Removes unnecessary '.' parts.
       * - Removes unnecessary '<dir>/..' parts.
       *
       * Based on code in the Node.js 'path' core module.
       *
       * @param aPath The path or url to normalize.
       */
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = (path.charAt(0) === '/');
    
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              // The first part is blank if the path is absolute. Trying to go
              // above the root is a no-op. Therefore we can remove all '..' parts
              // directly after the root.
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
    
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
    
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
    
      /**
       * Joins two paths/URLs.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be joined with the root.
       *
       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
       *   first.
       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
       *   is updated with the result and aRoot is returned. Otherwise the result
       *   is returned.
       *   - If aPath is absolute, the result is aPath.
       *   - Otherwise the two paths are joined with a slash.
       * - Joining for example 'http://' and 'www.example.com' is also supported.
       */
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }
    
        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
    
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
    
        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
    
        var joined = aPath.charAt(0) === '/'
          ? aPath
          : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
    
      /**
       * Make a path relative to a URL or another path.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be made relative to aRoot.
       */
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
    
        aRoot = aRoot.replace(/\/$/, '');
    
        // XXX: It is possible to remove this block, and the tests still pass!
        var url = urlParse(aRoot);
        if (aPath.charAt(0) == "/" && url && url.path == "/") {
          return aPath.slice(1);
        }
    
        return aPath.indexOf(aRoot + '/') === 0
          ? aPath.substr(aRoot.length + 1)
          : aPath;
      }
      exports.relative = relative;
    
      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
    
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
    
      function strcmp(aStr1, aStr2) {
        var s1 = aStr1 || "";
        var s2 = aStr2 || "";
        return (s1 > s2) - (s1 < s2);
      }
    
      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp || onlyCompareOriginal) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        return strcmp(mappingA.name, mappingB.name);
      };
      exports.compareByOriginalPositions = compareByOriginalPositions;
    
      /**
       * Comparator between two mappings where the generated positions are
       * compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
        var cmp;
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp || onlyCompareGenerated) {
          return cmp;
        }
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp) {
          return cmp;
        }
    
        return strcmp(mappingA.name, mappingB.name);
      };
      exports.compareByGeneratedPositions = compareByGeneratedPositions;
    
    });
    
  provide("source-map/source-map/util", module.exports);
}(global));

// pakmanager:source-map/source-map/base64-vlq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     *
     * Based on the Base 64 VLQ implementation in Closure Compiler:
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
     *
     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *  * Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above
     *    copyright notice, this list of conditions and the following
     *    disclaimer in the documentation and/or other materials provided
     *    with the distribution.
     *  * Neither the name of Google Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64 =  require('source-map/source-map/base64');
    
      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011
    
      var VLQ_BASE_SHIFT = 5;
    
      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    
      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;
    
      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
    
      /**
       * Converts from a two-complement value to a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0
          ? ((-aValue) << 1) + 1
          : (aValue << 1) + 0;
      }
    
      /**
       * Converts to a two-complement value from a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative
          ? -shifted
          : shifted;
      }
    
      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
    
        var vlq = toVLQSigned(aValue);
    
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
    
        return encoded;
      };
    
      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
    
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charAt(aIndex++));
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
    
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    
    });
    
  provide("source-map/source-map/base64-vlq", module.exports);
}(global));

// pakmanager:source-map/source-map/array-set
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
    
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
    
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var isDuplicate = this.has(aStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[util.toSetString(aStr)] = idx;
        }
      };
    
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        return Object.prototype.hasOwnProperty.call(this._set,
                                                    util.toSetString(aStr));
      };
    
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (this.has(aStr)) {
          return this._set[util.toSetString(aStr)];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
    
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
    
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
    
      exports.ArraySet = ArraySet;
    
    });
    
  provide("source-map/source-map/array-set", module.exports);
}(global));

// pakmanager:source-map/source-map/mapping-list
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2014 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * Determine whether mappingB is after mappingA with respect to generated
       * position.
       */
      function generatedPositionAfter(mappingA, mappingB) {
        // Optimized for most common case
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA ||
               util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
      }
    
      /**
       * A data structure to provide a sorted view of accumulated mappings in a
       * performance conscious manner. It trades a neglibable overhead in general
       * case for a large speedup in case of mappings being added in order.
       */
      function MappingList() {
        this._array = [];
        this._sorted = true;
        // Serves as infimum
        this._last = {generatedLine: -1, generatedColumn: 0};
      }
    
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      MappingList.prototype.unsortedForEach =
        function MappingList_forEach(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        };
    
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      MappingList.prototype.add = function MappingList_add(aMapping) {
        var mapping;
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
    
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositions);
          this._sorted = true;
        }
        return this._array;
      };
    
      exports.MappingList = MappingList;
    
    });
    
  provide("source-map/source-map/mapping-list", module.exports);
}(global));

// pakmanager:source-map/source-map/binary-search
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
    
      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return mid;
        }
        else if (cmp > 0) {
          // Our needle is greater than aHaystack[mid].
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        }
        else {
          // Our needle is less than aHaystack[mid].
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
    
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
    
      /**
       * This is an implementation of binary search which will always try and return
       * the index of the closest element if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
    
        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                    aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) {
          return -1;
        }
    
        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
    
        return index;
      };
    
    });
    
  provide("source-map/source-map/binary-search", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-generator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64VLQ =  require('source-map/source-map/base64-vlq');
      var util =  require('source-map/source-map/util');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var MappingList =  require('source-map/source-map/mapping-list').MappingList;
    
      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
    
      SourceMapGenerator.prototype._version = 3;
    
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
    
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
              }
    
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
              };
    
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
    
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
    
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, 'generated');
          var original = util.getArg(aArgs, 'original', null);
          var source = util.getArg(aArgs, 'source', null);
          var name = util.getArg(aArgs, 'name', null);
    
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
    
          if (source != null && !this._sources.has(source)) {
            this._sources.add(source);
          }
    
          if (name != null && !this._names.has(name)) {
            this._names.add(name);
          }
    
          this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
          });
        };
    
      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
    
          if (aSourceContent != null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
              this._sourcesContents = {};
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
    
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          // If aSourceFile is omitted, we will use the file property of the SourceMap
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                'or the source map\'s "file" property. Both were omitted.'
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          // Make "sourceFile" relative if an absolute Url is passed.
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          // Applying the SourceMap can add and remove items from the sources and
          // the names array.
          var newSources = new ArraySet();
          var newNames = new ArraySet();
    
          // Find mappings for the "sourceFile"
          this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              // Check if it can be mapped by the source map, then update the mapping.
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source)
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
    
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
    
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
    
          }, this);
          this._sources = newSources;
          this._names = newNames;
    
          // Copy sourcesContents of applied map.
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
    
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                    aName) {
          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
              && aGenerated.line > 0 && aGenerated.column >= 0
              && !aOriginal && !aSource && !aName) {
            // Case 1.
            return;
          }
          else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                   && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                   && aGenerated.line > 0 && aGenerated.column >= 0
                   && aOriginal.line > 0 && aOriginal.column >= 0
                   && aSource) {
            // Cases 2 and 3.
            return;
          }
          else {
            throw new Error('Invalid mapping: ' + JSON.stringify({
              generated: aGenerated,
              source: aSource,
              original: aOriginal,
              name: aName
            }));
          }
        };
    
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = '';
          var mapping;
    
          var mappings = this._mappings.toArray();
    
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
    
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                result += ';';
                previousGeneratedLine++;
              }
            }
            else {
              if (i > 0) {
                if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
                  continue;
                }
                result += ',';
              }
            }
    
            result += base64VLQ.encode(mapping.generatedColumn
                                       - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
    
            if (mapping.source != null) {
              result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                         - previousSource);
              previousSource = this._sources.indexOf(mapping.source);
    
              // lines are stored 0-based in SourceMap spec version 3
              result += base64VLQ.encode(mapping.originalLine - 1
                                         - previousOriginalLine);
              previousOriginalLine = mapping.originalLine - 1;
    
              result += base64VLQ.encode(mapping.originalColumn
                                         - previousOriginalColumn);
              previousOriginalColumn = mapping.originalColumn;
    
              if (mapping.name != null) {
                result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                           - previousName);
                previousName = this._names.indexOf(mapping.name);
              }
            }
          }
    
          return result;
        };
    
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                        key)
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
    
      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
          }
    
          return map;
        };
    
      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
    
      exports.SourceMapGenerator = SourceMapGenerator;
    
    });
    
  provide("source-map/source-map/source-map-generator", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-consumer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
      var binarySearch =  require('source-map/source-map/binary-search');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var base64VLQ =  require('source-map/source-map/base64-vlq');
    
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        return sourceMap.sections != null
          ? new IndexedSourceMapConsumer(sourceMap)
          : new BasicSourceMapConsumer(sourceMap);
      }
    
      SourceMapConsumer.fromSourceMap = function(aSourceMap) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
      }
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;
    
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
    
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__generatedMappings;
        }
      });
    
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__originalMappings;
        }
      });
    
      SourceMapConsumer.prototype._nextCharIsMappingSeparator =
        function SourceMapConsumer_nextCharIsMappingSeparator(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        };
    
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
    
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping =
        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    
          var mappings;
          switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
          }
    
          var sourceRoot = this.sourceRoot;
          mappings.map(function (mapping) {
            var source = mapping.source;
            if (source != null && sourceRoot != null) {
              source = util.join(sourceRoot, source);
            }
            return {
              source: source,
              generatedLine: mapping.generatedLine,
              generatedColumn: mapping.generatedColumn,
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: mapping.name
            };
          }).forEach(aCallback, context);
        };
    
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a single line. Otherwise, returns all mappings
       * corresponding to a single line and column.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: Optional. the column number in the original source.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      SourceMapConsumer.prototype.allGeneratedPositionsFor =
        function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
          // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
          // returns the index of the closest mapping less than the needle. By
          // setting needle.originalColumn to 0, we thus find the last mapping for
          // the given line, provided such a mapping exists.
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column', 0)
          };
    
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
    
          var mappings = [];
    
          var index = this._findMapping(needle,
                                        this._originalMappings,
                                        "originalLine",
                                        "originalColumn",
                                        util.compareByOriginalPositions,
                                        binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            var originalLine = mapping.originalLine;
            var originalColumn = mapping.originalColumn;
    
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line. Since mappings are sorted, this is
            // guaranteed to find all mappings for the line we are searching for.
            while (mapping && mapping.originalLine === originalLine &&
                   (aArgs.column === undefined ||
                    mapping.originalColumn === originalColumn)) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              });
    
              mapping = this._originalMappings[++index];
            }
          }
    
          return mappings;
        };
    
      exports.SourceMapConsumer = SourceMapConsumer;
    
      /**
       * A BasicSourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The only parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function BasicSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
    
        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        sources = sources.map(util.normalize);
    
        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
    
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
    
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @returns BasicSourceMapConsumer
       */
      BasicSourceMapConsumer.fromSourceMap =
        function SourceMapConsumer_fromSourceMap(aSourceMap) {
          var smc = Object.create(BasicSourceMapConsumer.prototype);
    
          smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
          smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                  smc.sourceRoot);
          smc.file = aSourceMap._file;
    
          smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
          smc.__originalMappings = aSourceMap._mappings.toArray().slice()
            .sort(util.compareByOriginalPositions);
    
          return smc;
        };
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      BasicSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      BasicSourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var length = aStr.length;
          var index = 0;
          var cachedValues = {};
          var temp = {};
          var mapping, str, values, end, value;
    
          while (index < length) {
            if (aStr.charAt(index) === ';') {
              generatedLine++;
              ++index;
              previousGeneratedColumn = 0;
            }
            else if (aStr.charAt(index) === ',') {
              ++index;
            }
            else {
              mapping = {};
              mapping.generatedLine = generatedLine;
    
              // Because each offset is encoded relative to the previous one,
              // many segments often have the same encoding. We can exploit this
              // fact by caching the parsed variable length fields of each segment,
              // allowing us to avoid a second parse if we encounter the same
              // segment again.
              for (end = index; end < length; ++end) {
                if (this._nextCharIsMappingSeparator(aStr, end)) {
                  break;
                }
              }
              str = aStr.slice(index, end);
    
              values = cachedValues[str];
              if (values) {
                index += str.length;
              } else {
                values = [];
                while (index < end) {
                  base64VLQ.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  values.push(value);
                }
                cachedValues[str] = values;
              }
    
              // Generated column.
              mapping.generatedColumn = previousGeneratedColumn + values[0];
              previousGeneratedColumn = mapping.generatedColumn;
    
              if (values.length > 1) {
                // Original source.
                mapping.source = this._sources.at(previousSource + values[1]);
                previousSource += values[1];
                if (values.length === 2) {
                  throw new Error('Found a source, but no line and column');
                }
    
                // Original line.
                mapping.originalLine = previousOriginalLine + values[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                if (values.length === 3) {
                  throw new Error('Found a source and line, but no column');
                }
    
                // Original column.
                mapping.originalColumn = previousOriginalColumn + values[3];
                previousOriginalColumn = mapping.originalColumn;
    
                if (values.length > 4) {
                  // Original name.
                  mapping.name = this._names.at(previousName + values[4]);
                  previousName += values[4];
                }
              }
    
              this.__generatedMappings.push(mapping);
              if (typeof mapping.originalLine === 'number') {
                this.__originalMappings.push(mapping);
              }
            }
          }
    
          this.__generatedMappings.sort(util.compareByGeneratedPositions);
          this.__originalMappings.sort(util.compareByOriginalPositions);
        };
    
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      BasicSourceMapConsumer.prototype._findMapping =
        function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                               aColumnName, aComparator, aBias) {
          // To return the position we are searching for, we must first find the
          // mapping for the given position and then return the opposite position it
          // points to. Because the mappings are sorted, we can use binary search to
          // find the best mapping.
    
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError('Line must be greater than or equal to 1, got '
                                + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError('Column must be greater than or equal to 0, got '
                                + aNeedle[aColumnName]);
          }
    
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
    
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      BasicSourceMapConsumer.prototype.computeColumnSpans =
        function SourceMapConsumer_computeColumnSpans() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
    
            // Mappings do not contain a field for the last generated columnt. We
            // can come up with an optimistic estimate, however, by assuming that
            // mappings are contiguous (i.e. given two consecutive mappings, the
            // first mapping ends where the second one starts).
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
    
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
    
            // The last mapping for each line spans the entire line.
            mapping.lastGeneratedColumn = Infinity;
          }
        };
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      BasicSourceMapConsumer.prototype.originalPositionFor =
        function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          var index = this._findMapping(
            needle,
            this._generatedMappings,
            "generatedLine",
            "generatedColumn",
            util.compareByGeneratedPositions,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
    
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, 'source', null);
              if (source != null && this.sourceRoot != null) {
                source = util.join(this.sourceRoot, source);
              }
              return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: util.getArg(mapping, 'name', null)
              };
            }
          }
    
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * availible.
       */
      BasicSourceMapConsumer.prototype.sourceContentFor =
        function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          if (!this.sourcesContent) {
            return null;
          }
    
          if (this.sourceRoot != null) {
            aSource = util.relative(this.sourceRoot, aSource);
          }
    
          if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
          }
    
          var url;
          if (this.sourceRoot != null
              && (url = util.urlParse(this.sourceRoot))) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file"
                && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
            }
    
            if ((!url.path || url.path == "/")
                && this._sources.has("/" + aSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
          }
    
          // This function is used recursively from
          // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
          // don't want to throw if we can't find the source - we just want to
          // return null, so we provide a flag to exit gracefully.
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      BasicSourceMapConsumer.prototype.generatedPositionFor =
        function SourceMapConsumer_generatedPositionFor(aArgs) {
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
    
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
    
          var index = this._findMapping(
            needle,
            this._originalMappings,
            "originalLine",
            "originalColumn",
            util.compareByOriginalPositions,
            util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
    
          if (index >= 0) {
            var mapping = this._originalMappings[index];
    
            if (mapping.source === needle.source) {
              return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              };
            }
          }
    
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        };
    
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    
      /**
       * An IndexedSourceMapConsumer instance represents a parsed source map which
       * we can query for information. It differs from BasicSourceMapConsumer in
       * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
       * input.
       *
       * The only parameter is a raw source map (either as a JSON string, or already
       * parsed to an object). According to the spec for indexed source maps, they
       * have the following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - file: Optional. The generated file this source map is associated with.
       *   - sections: A list of section definitions.
       *
       * Each value under the "sections" field has two fields:
       *   - offset: The offset into the original specified at which this section
       *       begins to apply, defined as an object with a "line" and "column"
       *       field.
       *   - map: A source map definition. This source map could also be indexed,
       *       but doesn't have to be.
       *
       * Instead of the "map" field, it's also possible to have a "url" field
       * specifying a URL to retrieve a source map from, but that's currently
       * unsupported.
       *
       * Here's an example source map, taken from the source map spec[0], but
       * modified to omit a section which uses the "url" field.
       *
       *  {
       *    version : 3,
       *    file: "app.js",
       *    sections: [{
       *      offset: {line:100, column:10},
       *      map: {
       *        version : 3,
       *        file: "section.js",
       *        sources: ["foo.js", "bar.js"],
       *        names: ["src", "maps", "are", "fun"],
       *        mappings: "AAAA,E;;ABCDE;"
       *      }
       *    }],
       *  }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
       */
      function IndexedSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sections = util.getArg(sourceMap, 'sections');
    
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function (s) {
          if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
          }
          var offset = util.getArg(s, 'offset');
          var offsetLine = util.getArg(offset, 'line');
          var offsetColumn = util.getArg(offset, 'column');
    
          if (offsetLine < lastOffset.line ||
              (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
          }
          lastOffset = offset;
    
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'))
          }
        });
      }
    
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      IndexedSourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
        get: function () {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          };
          return sources;
        }
      });
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      IndexedSourceMapConsumer.prototype.originalPositionFor =
        function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          // Find the section containing the generated position we're trying to map
          // to an original position.
          var sectionIndex = binarySearch.search(needle, this._sections,
            function(needle, section) {
              var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
              if (cmp) {
                return cmp;
              }
    
              return (needle.generatedColumn -
                      section.generatedOffset.generatedColumn);
            });
          var section = this._sections[sectionIndex];
    
          if (!section) {
            return {
              source: null,
              line: null,
              column: null,
              name: null
            };
          }
    
          return section.consumer.originalPositionFor({
            line: needle.generatedLine -
              (section.generatedOffset.generatedLine - 1),
            column: needle.generatedColumn -
              (section.generatedOffset.generatedLine === needle.generatedLine
               ? section.generatedOffset.generatedColumn - 1
               : 0),
            bias: aArgs.bias
          });
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      IndexedSourceMapConsumer.prototype.sourceContentFor =
        function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
              return content;
            }
          }
          if (nullOnMissing) {
            return null;
          }
          else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      IndexedSourceMapConsumer.prototype.generatedPositionFor =
        function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
    
            // Only consider this section if the requested source is in the list of
            // sources of the consumer.
            if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
              continue;
            }
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = {
                line: generatedPosition.line +
                  (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column +
                  (section.generatedOffset.generatedLine === generatedPosition.line
                   ? section.generatedOffset.generatedColumn - 1
                   : 0)
              };
              return ret;
            }
          }
    
          return {
            line: null,
            column: null
          };
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      IndexedSourceMapConsumer.prototype._parseMappings =
        function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          this.__generatedMappings = [];
          this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[i];
    
              var source = mapping.source;
              var sourceRoot = section.consumer.sourceRoot;
    
              if (source != null && sourceRoot != null) {
                source = util.join(sourceRoot, source);
              }
    
              // The mappings coming from the consumer for the section have
              // generated positions relative to the start of the section, so we
              // need to offset them to be relative to the start of the concatenated
              // generated file.
              var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine +
                  (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.column +
                  (section.generatedOffset.generatedLine === mapping.generatedLine)
                  ? section.generatedOffset.generatedColumn - 1
                  : 0,
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: mapping.name
              };
    
              this.__generatedMappings.push(adjustedMapping);
              if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
              }
            };
          };
    
        this.__generatedMappings.sort(util.compareByGeneratedPositions);
        this.__originalMappings.sort(util.compareByOriginalPositions);
      };
    
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    
    });
    
  provide("source-map/source-map/source-map-consumer", module.exports);
}(global));

// pakmanager:source-map/source-map/source-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
      var util =  require('source-map/source-map/util');
    
      // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/;
    
      // Newline character code for charCodeAt() comparisons
      var NEWLINE_CODE = 10;
    
      // Private symbol for identifying `SourceNode`s when multiple versions of
      // the source-map library are loaded. This MUST NOT CHANGE across
      // versions!
      var isSourceNode = "$$$isSourceNode$$$";
    
      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
    
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      SourceNode.fromStringWithSourceMap =
        function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          // The SourceNode we want to fill with the generated code
          // and the SourceMap
          var node = new SourceNode();
    
          // All even indices of this array are one line of the generated code,
          // while all odd indices are the newlines between two adjacent lines
          // (since `REGEX_NEWLINE` captures its match).
          // Processed fragments are removed from this array, by calling `shiftNextLine`.
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var shiftNextLine = function() {
            var lineContents = remainingLines.shift();
            // The last line of a file might not have a newline.
            var newLine = remainingLines.shift() || "";
            return lineContents + newLine;
          };
    
          // We need to remember the position of "remainingLines"
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    
          // The generate SourceNodes we need a code range.
          // To extract it current and last mapping is used.
          // Here we store the last mapping.
          var lastMapping = null;
    
          aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping !== null) {
              // We add the code from "lastMapping" to "mapping":
              // First check if there is a new line in between.
              if (lastGeneratedLine < mapping.generatedLine) {
                var code = "";
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
                // The remaining code is added without mapping
              } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[0];
                var code = nextLine.substr(0, mapping.generatedColumn -
                                              lastGeneratedColumn);
                remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                    lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
              }
            }
            // We add the generated code until the first mapping
            // to the SourceNode without any mapping.
            // Each line is added as separate string.
            while (lastGeneratedLine < mapping.generatedLine) {
              node.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              node.add(nextLine.substr(0, mapping.generatedColumn));
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this);
          // We have processed all mappings.
          if (remainingLines.length > 0) {
            if (lastMapping) {
              // Associate the remaining code in the current line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
            }
            // and add the remaining lines without any mapping
            node.add(remainingLines.join(""));
          }
    
          // Copy sourcesContent into SourceNode
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
              }
              node.setSourceContent(sourceFile, content);
            }
          });
    
          return node;
    
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
              node.add(code);
            } else {
              var source = aRelativePath
                ? util.join(aRelativePath, mapping.source)
                : mapping.source;
              node.add(new SourceNode(mapping.originalLine,
                                      mapping.originalColumn,
                                      source,
                                      code,
                                      mapping.name));
            }
          }
        };
    
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length-1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        }
        else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          }
          else {
            if (chunk !== '') {
              aFn(chunk, { source: this.source,
                           line: this.line,
                           column: this.column,
                           name: this.name });
            }
          }
        }
      };
    
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len-1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
    
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        }
        else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        }
        else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
    
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent =
        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
    
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents =
        function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
              this.children[i].walkSourceContents(aFn);
            }
          }
    
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
    
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
    
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null
              && original.line !== null
              && original.column !== null) {
            if(lastOriginalSource !== original.source
               || lastOriginalLine !== original.line
               || lastOriginalColumn !== original.column
               || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              // Mappings end at eol
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
    
        return { code: generated.code, map: map };
      };
    
      exports.SourceNode = SourceNode;
    
    });
    
  provide("source-map/source-map/source-node", module.exports);
}(global));

// pakmanager:source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer =  require('source-map/source-map/source-map-consumer').SourceMapConsumer;
    exports.SourceNode =  require('source-map/source-map/source-node').SourceNode;
    
  provide("source-map", module.exports);
}(global));

// pakmanager:uglify-to-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var fs = require('fs')
    var PassThrough = require('stream').PassThrough
    var Transform = require('stream').Transform
    
    if (typeof Transform === 'undefined') {
      throw new Error('UglifyJS only supports browserify when using node >= 0.10.x')
    }
    
    var cache = {}
    module.exports = transform
    function transform(file) {
      if (!/tools\/node\.js$/.test(file.replace(/\\/g,'/'))) return new PassThrough();
      if (cache[file]) return makeStream(cache[file])
      var uglify = require(file)
      var src = 'var sys = require("util");\nvar MOZ_SourceMap = require("source-map");\nvar UglifyJS = exports;\n' + uglify.FILES.map(function (path) { return fs.readFileSync(path, 'utf8') }).join('\n')
    
      var ast = uglify.parse(src)
      ast.figure_out_scope()
    
      var variables = ast.variables
        .map(function (node, name) {
          return name
        })
    
      src += '\n\n' + variables.map(function (v) { return 'exports.' + v + ' = ' + v + ';' }).join('\n') + '\n\n'
    
      src += 'exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }\n\n'
    
      src += 'exports.minify = ' + uglify.minify.toString() + ';\n\n'
      src += 'exports.describe_ast = ' + uglify.describe_ast.toString() + ';'
    
      // TODO: remove once https://github.com/substack/node-browserify/issues/631 is resolved
      src = src.replace(/"for"/g, '"fo" + "r"')
    
      cache[file] = src
      return makeStream(src);
    }
    
    function makeStream(src) {
      var res = new Transform();
      res._transform = function (chunk, encoding, callback) { callback() }
      res._flush = function (callback) {
        res.push(src)
        callback()
      }
      return res;
    }
    
  provide("uglify-to-browserify", module.exports);
}(global));

// pakmanager:yargs/lib/completion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var path = require('path')
    
    // add bash completions to your
    //  yargs-powered applications.
    module.exports = function (yargs, usage) {
      var self = {
        completionKey: 'get-yargs-completions'
      }
    
      // get a list of completion commands.
      self.getCompletion = function (done) {
        var completions = []
        var current = process.argv[process.argv.length - 1]
        var previous = process.argv.slice(process.argv.indexOf('--' + self.completionKey) + 1)
        var argv = yargs.parse(previous)
    
        // a custom completion function can be provided
        // to completion().
        if (completionFunction) {
          if (completionFunction.length < 3) {
            // synchronous completion function.
            return done(completionFunction(current, argv))
          } else {
            // asynchronous completion function
            return completionFunction(current, argv, function (completions) {
              done(completions)
            })
          }
        }
    
        var handlers = yargs.getCommandHandlers()
        for (var i = 0, ii = previous.length; i < ii; ++i) {
          if (handlers[previous[i]]) {
            return handlers[previous[i]](yargs.reset())
          }
        }
    
        if (!current.match(/^-/)) {
          usage.getCommands().forEach(function (command) {
            if (previous.indexOf(command[0]) === -1) {
              completions.push(command[0])
            }
          })
        }
    
        if (current.match(/^-/)) {
          Object.keys(yargs.getOptions().key).forEach(function (key) {
            completions.push('--' + key)
          })
        }
    
        done(completions)
      }
    
      // generate the completion script to add to your .bashrc.
      self.generateCompletionScript = function ($0) {
        var script = fs.readFileSync(
          path.resolve(__dirname, '../completion.sh.hbs'),
          'utf-8'
        )
        var name = path.basename($0)
    
        // add ./to applications not yet installed as bin.
        if ($0.match(/\.js$/)) $0 = './' + $0
    
        script = script.replace(/{{app_name}}/g, name)
        return script.replace(/{{app_path}}/g, $0)
      }
    
      // register a function to perform your own custom
      // completions., this function can be either
      // synchrnous or asynchronous.
      var completionFunction = null
      self.registerFunction = function (fn) {
        completionFunction = fn
      }
    
      return self
    }
    
  provide("yargs/lib/completion", module.exports);
}(global));

// pakmanager:yargs/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // fancy-pants parsing of argv, originally forked
    // from minimist: https://www.npmjs.com/package/minimist
    var camelCase = require('camelcase')
    var path = require('path')
    
    function increment (orig) {
      return orig !== undefined ? orig + 1 : 0
    }
    
    module.exports = function (args, opts) {
      if (!opts) opts = {}
    
      var error = null
      var flags = { arrays: {}, bools: {}, strings: {}, counts: {}, normalize: {}, configs: {} }
    
      ;[].concat(opts['array']).filter(Boolean).forEach(function (key) {
        flags.arrays[key] = true
      })
    
      ;[].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true
      })
    
      ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true
      })
    
      ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
        flags.counts[key] = true
      })
    
      ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
        flags.normalize[key] = true
      })
    
      ;[].concat(opts.config).filter(Boolean).forEach(function (key) {
        flags.configs[key] = true
      })
    
      var aliases = {}
      var newAliases = {}
    
      extendAliases(opts.key)
      extendAliases(opts.alias)
    
      var defaults = opts['default'] || {}
      Object.keys(defaults).forEach(function (key) {
        if (/-/.test(key) && !opts.alias[key]) {
          aliases[key] = aliases[key] || []
        }
        (aliases[key] || []).forEach(function (alias) {
          defaults[alias] = defaults[key]
        })
      })
    
      var argv = { _: [] }
    
      Object.keys(flags.bools).forEach(function (key) {
        setArg(key, !(key in defaults) ? false : defaults[key])
      })
    
      var notFlags = []
      if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--') + 1)
        args = args.slice(0, args.indexOf('--'))
      }
    
      for (var i = 0; i < args.length; i++) {
        var arg = args[i]
        var broken
        var key
        var letters
        var m
        var next
        var value
    
        // -- seperated by =
        if (arg.match(/^--.+=/)) {
          // Using [\s\S] instead of . because js doesn't support the
          // 'dotall' regex modifier. See:
          // http://stackoverflow.com/a/1068308/13216
          m = arg.match(/^--([^=]+)=([\s\S]*)$/)
    
          // nargs format = '--f=monkey washing cat'
          if (checkAllAliases(m[1], opts.narg)) {
            args.splice(i + 1, m[1], m[2])
            i = eatNargs(i, m[1], args)
          // arrays format = '--f=a b c'
          } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {
            args.splice(i + 1, m[1], m[2])
            i = eatArray(i, m[1], args)
          } else {
            setArg(m[1], m[2])
          }
        } else if (arg.match(/^--no-.+/)) {
          key = arg.match(/^--no-(.+)/)[1]
          setArg(key, false)
    
        // -- seperated by space.
        } else if (arg.match(/^--.+/)) {
          key = arg.match(/^--(.+)/)[1]
    
          // nargs format = '--foo a b c'
          if (checkAllAliases(key, opts.narg)) {
            i = eatNargs(i, key, args)
          // array format = '--foo a b c'
          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
            i = eatArray(i, key, args)
          } else {
            next = args[i + 1]
    
            if (next !== undefined && !next.match(/^-/) &&
              !checkAllAliases(key, flags.bools) &&
              !checkAllAliases(key, flags.counts)) {
              setArg(key, next)
              i++
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next)
              i++
            } else {
              setArg(key, defaultForType(guessType(key, flags)))
            }
          }
    
        // dot-notation flag seperated by '='.
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/)
          setArg(m[1], m[2])
    
        // dot-notation flag seperated by space.
        } else if (arg.match(/^-.\..+/)) {
          next = args[i + 1]
          key = arg.match(/^-(.\..+)/)[1]
    
          if (next !== undefined && !next.match(/^-/) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, next)
            i++
          } else {
            setArg(key, defaultForType(guessType(key, flags)))
          }
        } else if (arg.match(/^-[^-]+/)) {
          letters = arg.slice(1, -1).split('')
          broken = false
    
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2)
    
            if (letters[j + 1] && letters[j + 1] === '=') {
              value = arg.slice(j + 3)
              key = letters[j]
    
              // nargs format = '-f=monkey washing cat'
              if (checkAllAliases(letters[j], opts.narg)) {
                args.splice(i + 1, 0, value)
                i = eatNargs(i, key, args)
              // array format = '-f=a b c'
              } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
                args.splice(i + 1, 0, value)
                i = eatArray(i, key, args)
              } else {
                setArg(key, value)
              }
    
              broken = true
              break
            }
    
            if (next === '-') {
              setArg(letters[j], next)
              continue
            }
    
            if (/[A-Za-z]/.test(letters[j]) &&
              /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next)
              broken = true
              break
            }
    
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2))
              broken = true
              break
            } else {
              setArg(letters[j], defaultForType(guessType(letters[j], flags)))
            }
          }
    
          key = arg.slice(-1)[0]
    
          if (!broken && key !== '-') {
            // nargs format = '-f a b c'
            if (checkAllAliases(key, opts.narg)) {
              i = eatNargs(i, key, args)
            // array format = '-f a b c'
            } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
              i = eatArray(i, key, args)
            } else {
              if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) &&
                !checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts)) {
                setArg(key, args[i + 1])
                i++
              } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
                setArg(key, args[i + 1])
                i++
              } else {
                setArg(key, defaultForType(guessType(key, flags)))
              }
            }
          }
        } else {
          argv._.push(
            flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
          )
        }
      }
    
      setConfig(argv)
      applyDefaultsAndAliases(argv, aliases, defaults)
    
      Object.keys(flags.counts).forEach(function (key) {
        setArg(key, defaults[key])
      })
    
      notFlags.forEach(function (key) {
        argv._.push(key)
      })
    
      // how many arguments should we consume, based
      // on the nargs option?
      function eatNargs (i, key, args) {
        var toEat = checkAllAliases(key, opts.narg)
    
        if (args.length - (i + 1) < toEat) error = Error('not enough arguments following: ' + key)
    
        for (var ii = i + 1; ii < (toEat + i + 1); ii++) {
          setArg(key, args[ii])
        }
    
        return (i + toEat)
      }
    
      // if an option is an array, eat all non-hyphenated arguments
      // following it... YUM!
      // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
      function eatArray (i, key, args) {
        for (var ii = i + 1; ii < args.length; ii++) {
          if (/^-/.test(args[ii])) break
          i = ii
          setArg(key, args[ii])
        }
    
        return i
      }
    
      function setArg (key, val) {
        // handle parsing boolean arguments --foo=true --bar false.
        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === 'string') val = val === 'true'
        }
    
        if (/-/.test(key) && !(aliases[key] && aliases[key].length)) {
          var c = camelCase(key)
          aliases[key] = [c]
          newAliases[c] = true
        }
    
        var value = !checkAllAliases(key, flags.strings) && isNumber(val) ? Number(val) : val
    
        if (checkAllAliases(key, flags.counts)) {
          value = increment
        }
    
        var splitKey = key.split('.')
        setKey(argv, splitKey, value)
    
        ;(aliases[splitKey[0]] || []).forEach(function (x) {
          x = x.split('.')
    
          // handle populating dot notation for both
          // the key and its aliases.
          if (splitKey.length > 1) {
            var a = [].concat(splitKey)
            a.shift() // nuke the old key.
            x = x.concat(a)
          }
    
          setKey(argv, x, value)
        })
    
        var keys = [key].concat(aliases[key] || [])
        for (var i = 0, l = keys.length; i < l; i++) {
          if (flags.normalize[keys[i]]) {
            keys.forEach(function (key) {
              argv.__defineSetter__(key, function (v) {
                val = path.normalize(v)
              })
    
              argv.__defineGetter__(key, function () {
                return typeof val === 'string' ?
                path.normalize(val) : val
              })
            })
            break
          }
        }
      }
    
      // set args from config.json file, this should be
      // applied last so that defaults can be applied.
      function setConfig (argv) {
        var configLookup = {}
    
        // expand defaults/aliases, in-case any happen to reference
        // the config.json file.
        applyDefaultsAndAliases(configLookup, aliases, defaults)
    
        Object.keys(flags.configs).forEach(function (configKey) {
          var configPath = argv[configKey] || configLookup[configKey]
          if (configPath) {
            try {
              var config = require(path.resolve(process.cwd(), configPath))
    
              Object.keys(config).forEach(function (key) {
                // setting arguments via CLI takes precedence over
                // values within the config file.
                if (argv[key] === undefined) {
                  delete argv[key]
                  setArg(key, config[key])
                }
              })
            } catch (ex) {
              if (argv[configKey]) error = Error('invalid json config file: ' + configPath)
            }
          }
        })
      }
    
      function applyDefaultsAndAliases (obj, aliases, defaults) {
        Object.keys(defaults).forEach(function (key) {
          if (!hasKey(obj, key.split('.'))) {
            setKey(obj, key.split('.'), defaults[key])
    
            ;(aliases[key] || []).forEach(function (x) {
              setKey(obj, x.split('.'), defaults[key])
            })
          }
        })
      }
    
      function hasKey (obj, keys) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          o = (o[key] || {})
        })
    
        var key = keys[keys.length - 1]
        return key in o
      }
    
      function setKey (obj, keys, value) {
        var o = obj
        keys.slice(0, -1).forEach(function (key) {
          if (o[key] === undefined) o[key] = {}
          o = o[key]
        })
    
        var key = keys[keys.length - 1]
        if (value === increment) {
          o[key] = increment(o[key])
        } else if (o[key] === undefined && checkAllAliases(key, flags.arrays)) {
          o[key] = Array.isArray(value) ? value : [value]
        } else if (o[key] === undefined || typeof o[key] === 'boolean') {
          o[key] = value
        } else if (Array.isArray(o[key])) {
          o[key].push(value)
        } else {
          o[key] = [ o[key], value ]
        }
      }
    
      // extend the aliases list with inferred aliases.
      function extendAliases (obj) {
        Object.keys(obj || {}).forEach(function (key) {
          aliases[key] = [].concat(opts.alias[key] || [])
          // For "--option-name", also set argv.optionName
          aliases[key].concat(key).forEach(function (x) {
            if (/-/.test(x)) {
              var c = camelCase(x)
              aliases[key].push(c)
              newAliases[c] = true
            }
          })
          aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
              return x !== y
            }))
          })
        })
      }
    
      // check if a flag is set for any of a key's aliases.
      function checkAllAliases (key, flag) {
        var isSet = false
        var toCheck = [].concat(aliases[key] || [], key)
    
        toCheck.forEach(function (key) {
          if (flag[key]) isSet = flag[key]
        })
    
        return isSet
      }
    
      // return a default value, given the type of a flag.,
      // e.g., key of type 'string' will default to '', rather than 'true'.
      function defaultForType (type) {
        var def = {
          boolean: true,
          string: '',
          array: []
        }
    
        return def[type]
      }
    
      // given a flag, enforce a default type.
      function guessType (key, flags) {
        var type = 'boolean'
    
        if (flags.strings && flags.strings[key]) type = 'string'
        else if (flags.arrays && flags.arrays[key]) type = 'array'
    
        return type
      }
    
      function isNumber (x) {
        if (typeof x === 'number') return true
        if (/^0x[0-9a-f]+$/i.test(x)) return true
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
      }
    
      return {
        argv: argv,
        aliases: aliases,
        error: error,
        newAliases: newAliases
      }
    }
    
  provide("yargs/lib/parser", module.exports);
}(global));

// pakmanager:yargs/lib/usage
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // this file handles outputting usage instructions,
    // failures, etc. keeps logging in one place.
    var cliui = require('cliui')
    var decamelize = require('decamelize')
    var wsize = require('window-size')
    
    module.exports = function (yargs) {
      var self = {}
    
      // methods for ouputting/building failure message.
      var fails = []
      self.failFn = function (f) {
        fails.push(f)
      }
    
      var failMessage = null
      var showHelpOnFail = true
      self.showHelpOnFail = function (enabled, message) {
        if (typeof enabled === 'string') {
          message = enabled
          enabled = true
        } else if (typeof enabled === 'undefined') {
          enabled = true
        }
        failMessage = message
        showHelpOnFail = enabled
        return self
      }
    
      self.fail = function (msg) {
        if (fails.length) {
          fails.forEach(function (f) {
            f(msg)
          })
        } else {
          if (showHelpOnFail) yargs.showHelp('error')
          if (msg) console.error(msg)
          if (failMessage) {
            if (msg) console.error('')
            console.error(failMessage)
          }
          if (yargs.getExitProcess()) {
            process.exit(1)
          } else {
            throw new Error(msg)
          }
        }
      }
    
      // methods for ouputting/building help (usage) message.
      var usage
      self.usage = function (msg) {
        usage = msg
      }
    
      var examples = []
      self.example = function (cmd, description) {
        examples.push([cmd, description || ''])
      }
    
      var commands = []
      self.command = function (cmd, description) {
        commands.push([cmd, description || ''])
      }
      self.getCommands = function () {
        return commands
      }
    
      var descriptions = {}
      self.describe = function (key, desc) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.describe(k, key[k])
          })
        } else {
          descriptions[key] = desc
        }
      }
      self.getDescriptions = function () {
        return descriptions
      }
    
      var epilog
      self.epilog = function (msg) {
        epilog = msg
      }
    
      var wrap = windowWidth()
      self.wrap = function (cols) {
        wrap = cols
      }
    
      self.help = function () {
        normalizeAliases()
    
        var demanded = yargs.getDemanded()
        var options = yargs.getOptions()
        var keys = Object.keys(
          Object.keys(descriptions)
          .concat(Object.keys(demanded))
          .concat(Object.keys(options.default))
          .reduce(function (acc, key) {
            if (key !== '_') acc[key] = true
            return acc
          }, {})
        )
        var ui = cliui({
          width: wrap,
          wrap: !!wrap
        })
    
        // the usage string.
        if (usage) {
          var u = usage.replace(/\$0/g, yargs.$0)
          ui.div(u + '\n')
        }
    
        // your application's commands, i.e., non-option
        // arguments populated in '_'.
        if (commands.length) {
          ui.div('Commands:')
    
          commands.forEach(function (command) {
            ui.div(
              {text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands) + 4},
              {text: command[1]}
            )
          })
    
          ui.div()
        }
    
        // the options table.
        var aliasKeys = (Object.keys(options.alias) || [])
          .concat(Object.keys(yargs.parsed.newAliases) || [])
    
        keys = keys.filter(function (key) {
          return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {
            return (options.alias[alias] || []).indexOf(key) === -1
          })
        })
    
        var switches = keys.reduce(function (acc, key) {
          acc[key] = [ key ].concat(options.alias[key] || [])
          .map(function (sw) {
            return (sw.length > 1 ? '--' : '-') + sw
          })
          .join(', ')
    
          return acc
        }, {})
    
        if (keys.length) {
          ui.div('Options:')
    
          keys.forEach(function (key) {
            var kswitch = switches[key]
            var desc = descriptions[key] || ''
            var type = null
    
            if (~options.boolean.indexOf(key)) type = '[boolean]'
            if (~options.count.indexOf(key)) type = '[count]'
            if (~options.string.indexOf(key)) type = '[string]'
            if (~options.normalize.indexOf(key)) type = '[string]'
            if (~options.array.indexOf(key)) type = '[array]'
    
            var extra = [
                type,
                demanded[key] ? '[required]' : null,
                defaultString(options.default[key], options.defaultDescription[key])
              ].filter(Boolean).join(' ')
    
            ui.span(
              {text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches) + 4},
              desc
            )
    
            if (extra) ui.div({text: extra, padding: [0, 0, 0, 2], align: 'right'})
            else ui.div()
          })
    
          ui.div()
        }
    
        // describe some common use-cases for your application.
        if (examples.length) {
          ui.div('Examples:')
    
          examples.forEach(function (example) {
            example[0] = example[0].replace(/\$0/g, yargs.$0)
          })
    
          examples.forEach(function (example) {
            ui.div(
              {text: example[0], padding: [0, 2, 0, 2], width: maxWidth(examples) + 4},
              example[1]
            )
          })
    
          ui.div()
        }
    
        // the usage string.
        if (epilog) {
          var e = epilog.replace(/\$0/g, yargs.$0)
          ui.div(e + '\n')
        }
    
        return ui.toString()
      }
    
      // return the maximum width of a string
      // in the left-hand column of a table.
      function maxWidth (table) {
        var width = 0
    
        // table might be of the form [leftColumn],
        // or {key: leftColumn}}
        if (!Array.isArray(table)) {
          table = Object.keys(table).map(function (key) {
            return [table[key]]
          })
        }
    
        table.forEach(function (v) {
          width = Math.max(v[0].length, width)
        })
    
        // if we've enabled 'wrap' we should limit
        // the max-width of the left-column.
        if (wrap) width = Math.min(width, parseInt(wrap * 0.5, 10))
    
        return width
      }
    
      // make sure any options set for aliases,
      // are copied to the keys being aliased.
      function normalizeAliases () {
        var demanded = yargs.getDemanded()
        var options = yargs.getOptions()
    
        ;(Object.keys(options.alias) || []).forEach(function (key) {
          options.alias[key].forEach(function (alias) {
            // copy descriptions.
            if (descriptions[alias]) self.describe(key, descriptions[alias])
            // copy demanded.
            if (demanded[alias]) yargs.demand(key, demanded[alias].msg)
    
            // type messages.
            if (~options.boolean.indexOf(alias)) yargs.boolean(key)
            if (~options.count.indexOf(alias)) yargs.count(key)
            if (~options.string.indexOf(alias)) yargs.string(key)
            if (~options.normalize.indexOf(alias)) yargs.normalize(key)
            if (~options.array.indexOf(alias)) yargs.array(key)
          })
        })
      }
    
      self.showHelp = function (level) {
        level = level || 'error'
        console[level](self.help())
      }
    
      self.functionDescription = function (fn, defaultDescription) {
        if (defaultDescription) {
          return defaultDescription
        }
        var description = fn.name ? decamelize(fn.name, '-') : 'generated-value'
        return ['(', description, ')'].join('')
      }
    
      // format the default-value-string displayed in
      // the right-hand column.
      function defaultString (value, defaultDescription) {
        var string = '[default: '
    
        if (value === undefined) return null
    
        if (defaultDescription) {
          string += defaultDescription
        } else {
          switch (typeof value) {
            case 'string':
              string += JSON.stringify(value)
              break
            case 'object':
              string += JSON.stringify(value)
              break
            default:
              string += value
          }
        }
    
        return string + ']'
      }
    
      // guess the width of the console window, max-width 80.
      function windowWidth () {
        return wsize.width ? Math.min(80, wsize.width) : null
      }
    
      // logic for displaying application version.
      var version = null
      self.version = function (ver, opt, msg) {
        version = ver
      }
    
      self.showVersion = function () {
        if (typeof version === 'function') console.log(version())
        else console.log(version)
      }
    
      return self
    }
    
  provide("yargs/lib/usage", module.exports);
}(global));

// pakmanager:yargs/lib/validation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // validation-type-stuff, missing params,
    // bad implications, custom checks.
    module.exports = function (yargs, usage) {
      var self = {}
    
      // validate appropriate # of non-option
      // arguments were provided, i.e., '_'.
      self.nonOptionCount = function (argv) {
        var demanded = yargs.getDemanded()
        var _s = argv._.length
    
        if (demanded._ && (_s < demanded._.count || _s > demanded._.max)) {
          if (demanded._.msg !== undefined) {
            usage.fail(demanded._.msg)
          } else if (_s < demanded._.count) {
            usage.fail('Not enough non-option arguments: got ' +
              argv._.length + ', need at least ' + demanded._.count
            )
          } else {
            usage.fail('Too many non-option arguments: got ' +
              argv._.length + ', maximum of ' + demanded._.max
            )
          }
        }
      }
    
      // make sure that any args that require an
      // value (--foo=bar), have a value.
      self.missingArgumentValue = function (argv) {
        var defaultValues = [true, false, '']
        var options = yargs.getOptions()
    
        if (options.requiresArg.length > 0) {
          var missingRequiredArgs = []
    
          options.requiresArg.forEach(function (key) {
            var value = argv[key]
    
            // if a value is explicitly requested,
            // flag argument as missing if it does not
            // look like foo=bar was entered.
            if (~defaultValues.indexOf(value) ||
              (Array.isArray(value) && !value.length)) {
              missingRequiredArgs.push(key)
            }
          })
    
          if (missingRequiredArgs.length === 1) {
            usage.fail('Missing argument value: ' + missingRequiredArgs[0])
          } else if (missingRequiredArgs.length > 1) {
            var message = 'Missing argument values: ' + missingRequiredArgs.join(', ')
            usage.fail(message)
          }
        }
      }
    
      // make sure all the required arguments are present.
      self.requiredArguments = function (argv) {
        var demanded = yargs.getDemanded()
        var missing = null
    
        Object.keys(demanded).forEach(function (key) {
          if (!argv.hasOwnProperty(key)) {
            missing = missing || {}
            missing[key] = demanded[key]
          }
        })
    
        if (missing) {
          var customMsgs = []
          Object.keys(missing).forEach(function (key) {
            var msg = missing[key].msg
            if (msg && customMsgs.indexOf(msg) < 0) {
              customMsgs.push(msg)
            }
          })
    
          var customMsg = customMsgs.length ? '\n' + customMsgs.join('\n') : ''
          usage.fail('Missing required arguments: ' + Object.keys(missing).join(', ') + customMsg)
        }
      }
    
      // check for unknown arguments (strict-mode).
      self.unknownArguments = function (argv, aliases) {
        var aliasLookup = {}
        var descriptions = usage.getDescriptions()
        var demanded = yargs.getDemanded()
        var unknown = []
    
        Object.keys(aliases).forEach(function (key) {
          aliases[key].forEach(function (alias) {
            aliasLookup[alias] = key
          })
        })
    
        Object.keys(argv).forEach(function (key) {
          if (key !== '$0' && key !== '_' &&
            !descriptions.hasOwnProperty(key) &&
            !demanded.hasOwnProperty(key) &&
            !aliasLookup.hasOwnProperty(key)) {
            unknown.push(key)
          }
        })
    
        if (unknown.length === 1) {
          usage.fail('Unknown argument: ' + unknown[0])
        } else if (unknown.length > 1) {
          usage.fail('Unknown arguments: ' + unknown.join(', '))
        }
      }
    
      // custom checks, added using the `check` option on yargs.
      var checks = []
      self.check = function (f) {
        checks.push(f)
      }
    
      self.customChecks = function (argv, aliases) {
        checks.forEach(function (f) {
          try {
            var result = f(argv, aliases)
            if (!result) {
              usage.fail('Argument check failed: ' + f.toString())
            } else if (typeof result === 'string') {
              usage.fail(result)
            }
          } catch (err) {
            usage.fail(err.message ? err.message : err)
          }
        })
      }
    
      // check implications, argument foo implies => argument bar.
      var implied = {}
      self.implies = function (key, value) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.implies(k, key[k])
          })
        } else {
          implied[key] = value
        }
      }
      self.getImplied = function () {
        return implied
      }
    
      self.implications = function (argv) {
        var implyFail = []
    
        Object.keys(implied).forEach(function (key) {
          var num
          var origKey = key
          var value = implied[key]
    
          // convert string '1' to number 1
          num = Number(key)
          key = isNaN(num) ? key : num
    
          if (typeof key === 'number') {
            // check length of argv._
            key = argv._.length >= key
          } else if (key.match(/^--no-.+/)) {
            // check if key doesn't exist
            key = key.match(/^--no-(.+)/)[1]
            key = !argv[key]
          } else {
            // check if key exists
            key = argv[key]
          }
    
          num = Number(value)
          value = isNaN(num) ? value : num
    
          if (typeof value === 'number') {
            value = argv._.length >= value
          } else if (value.match(/^--no-.+/)) {
            value = value.match(/^--no-(.+)/)[1]
            value = !argv[value]
          } else {
            value = argv[value]
          }
    
          if (key && !value) {
            implyFail.push(origKey)
          }
        })
    
        if (implyFail.length) {
          var msg = 'Implications failed:\n'
    
          implyFail.forEach(function (key) {
            msg += ('  ' + key + ' -> ' + implied[key])
          })
    
          usage.fail(msg)
        }
      }
    
      return self
    }
    
  provide("yargs/lib/validation", module.exports);
}(global));

// pakmanager:yargs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var assert = require('assert')
    var Completion =  require('yargs/lib/completion')
    var Parser =  require('yargs/lib/parser')
    var path = require('path')
    var Usage =  require('yargs/lib/usage')
    var Validation =  require('yargs/lib/validation')
    
    Argv(process.argv.slice(2))
    
    var exports = module.exports = Argv
    function Argv (processArgs, cwd) {
      processArgs = processArgs || [] // handle calling yargs().
    
      var self = {}
      var completion = null
      var usage = null
      var validation = null
    
      if (!cwd) cwd = process.cwd()
    
      self.$0 = process.argv
        .slice(0, 2)
        .map(function (x, i) {
          // ignore the node bin, specify this in your
          // bin file with #!/usr/bin/env node
          if (i === 0 && /\b(node|iojs)$/.test(x)) return
          var b = rebase(cwd, x)
          return x.match(/^\//) && b.length < x.length
          ? b : x
        })
        .join(' ').trim()
    
      if (process.env._ !== undefined && process.argv[1] === process.env._) {
        self.$0 = process.env._.replace(
          path.dirname(process.execPath) + '/', ''
        )
      }
    
      var options
      self.resetOptions = self.reset = function () {
        // put yargs back into its initial
        // state, this is useful for creating a
        // nested CLI.
        options = {
          array: [],
          boolean: [],
          string: [],
          narg: {},
          key: {},
          alias: {},
          default: {},
          defaultDescription: {},
          requiresArg: [],
          count: [],
          normalize: [],
          config: []
        }
    
        usage = Usage(self) // handle usage output.
        validation = Validation(self, usage) // handle arg validation.
        completion = Completion(self, usage)
    
        demanded = {}
    
        exitProcess = true
        strict = false
        helpOpt = null
        versionOpt = null
        commandHandlers = {}
        self.parsed = false
    
        return self
      }
      self.resetOptions()
    
      self.boolean = function (bools) {
        options.boolean.push.apply(options.boolean, [].concat(bools))
        return self
      }
    
      self.array = function (arrays) {
        options.array.push.apply(options.array, [].concat(arrays))
        return self
      }
    
      self.nargs = function (key, n) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.nargs(k, key[k])
          })
        } else {
          options.narg[key] = n
        }
        return self
      }
    
      self.normalize = function (strings) {
        options.normalize.push.apply(options.normalize, [].concat(strings))
        return self
      }
    
      self.config = function (key, msg) {
        self.describe(key, msg || 'Path to JSON config file')
        options.config.push.apply(options.config, [].concat(key))
        return self
      }
    
      self.example = function (cmd, description) {
        usage.example(cmd, description)
        return self
      }
    
      self.command = function (cmd, description, fn) {
        if (description !== false) {
          usage.command(cmd, description)
        }
        if (fn) commandHandlers[cmd] = fn
        return self
      }
    
      var commandHandlers = {}
      self.getCommandHandlers = function () {
        return commandHandlers
      }
    
      self.string = function (strings) {
        options.string.push.apply(options.string, [].concat(strings))
        return self
      }
    
      self.default = function (key, value, defaultDescription) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.default(k, key[k])
          })
        } else {
          if (typeof value === 'function') {
            defaultDescription = usage.functionDescription(value, defaultDescription)
            value = value.call()
          }
          options.defaultDescription[key] = defaultDescription
          options.default[key] = value
        }
        return self
      }
    
      self.alias = function (x, y) {
        if (typeof x === 'object') {
          Object.keys(x).forEach(function (key) {
            self.alias(key, x[key])
          })
        } else {
          options.alias[x] = (options.alias[x] || []).concat(y)
        }
        return self
      }
    
      self.count = function (counts) {
        options.count.push.apply(options.count, [].concat(counts))
        return self
      }
    
      var demanded = {}
      self.demand = self.required = self.require = function (keys, max, msg) {
        // you can optionally provide a 'max' key,
        // which will raise an exception if too many '_'
        // options are provided.
        if (typeof max !== 'number') {
          msg = max
          max = Infinity
        }
    
        if (typeof keys === 'number') {
          if (!demanded._) demanded._ = { count: 0, msg: null, max: max }
          demanded._.count = keys
          demanded._.msg = msg
        } else if (Array.isArray(keys)) {
          keys.forEach(function (key) {
            self.demand(key, msg)
          })
        } else {
          if (typeof msg === 'string') {
            demanded[keys] = { msg: msg }
          } else if (msg === true || typeof msg === 'undefined') {
            demanded[keys] = { msg: undefined }
          }
        }
    
        return self
      }
      self.getDemanded = function () {
        return demanded
      }
    
      self.requiresArg = function (requiresArgs) {
        options.requiresArg.push.apply(options.requiresArg, [].concat(requiresArgs))
        return self
      }
    
      self.implies = function (key, value) {
        validation.implies(key, value)
        return self
      }
    
      self.usage = function (msg, opts) {
        if (!opts && typeof msg === 'object') {
          opts = msg
          msg = null
        }
    
        usage.usage(msg)
    
        if (opts) self.options(opts)
    
        return self
      }
    
      self.epilogue = self.epilog = function (msg) {
        usage.epilog(msg)
        return self
      }
    
      self.fail = function (f) {
        usage.failFn(f)
        return self
      }
    
      self.check = function (f) {
        validation.check(f)
        return self
      }
    
      self.defaults = self.default
    
      self.describe = function (key, desc) {
        options.key[key] = true
        usage.describe(key, desc)
        return self
      }
    
      self.parse = function (args) {
        return parseArgs(args)
      }
    
      self.option = self.options = function (key, opt) {
        if (typeof key === 'object') {
          Object.keys(key).forEach(function (k) {
            self.options(k, key[k])
          })
        } else {
          assert(typeof opt === 'object', 'second argument to option must be an object')
    
          options.key[key] = true // track manually set keys.
    
          if (opt.alias) self.alias(key, opt.alias)
    
          var demand = opt.demand || opt.required || opt.require
    
          if (demand) {
            self.demand(key, demand)
          } if ('default' in opt) {
            self.default(key, opt.default)
          } if ('nargs' in opt) {
            self.nargs(key, opt.nargs)
          } if (opt.boolean || opt.type === 'boolean') {
            self.boolean(key)
            if (opt.alias) self.boolean(opt.alias)
          } if (opt.array || opt.type === 'array') {
            self.array(key)
            if (opt.alias) self.array(opt.alias)
          } if (opt.string || opt.type === 'string') {
            self.string(key)
            if (opt.alias) self.string(opt.alias)
          } if (opt.count || opt.type === 'count') {
            self.count(key)
          }
    
          var desc = opt.describe || opt.description || opt.desc
          if (desc) {
            self.describe(key, desc)
          }
    
          if (opt.requiresArg) {
            self.requiresArg(key)
          }
        }
    
        return self
      }
      self.getOptions = function () {
        return options
      }
    
      self.wrap = function (cols) {
        usage.wrap(cols)
        return self
      }
    
      var strict = false
      self.strict = function () {
        strict = true
        return self
      }
      self.getStrict = function () {
        return strict
      }
    
      self.showHelp = function (level) {
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
        usage.showHelp(level)
        return self
      }
    
      var versionOpt = null
      self.version = function (ver, opt, msg) {
        versionOpt = opt || 'version'
        usage.version(ver)
        self.boolean(versionOpt)
        self.describe(versionOpt, msg || 'Show version number')
        return self
      }
    
      var helpOpt = null
      self.addHelpOpt = function (opt, msg) {
        helpOpt = opt
        self.boolean(opt)
        self.describe(opt, msg || 'Show help')
        return self
      }
    
      self.showHelpOnFail = function (enabled, message) {
        usage.showHelpOnFail(enabled, message)
        return self
      }
    
      var exitProcess = true
      self.exitProcess = function (enabled) {
        if (typeof enabled !== 'boolean') {
          enabled = true
        }
        exitProcess = enabled
        return self
      }
      self.getExitProcess = function () {
        return exitProcess
      }
    
      self.help = function () {
        if (arguments.length > 0) return self.addHelpOpt.apply(self, arguments)
    
        if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
    
        return usage.help()
      }
    
      var completionCommand = null
      self.completion = function (cmd, desc, fn) {
        // a function to execute when generating
        // completions can be provided as the second
        // or third argument to completion.
        if (typeof desc === 'function') {
          fn = desc
          desc = null
        }
    
        // register the completion command.
        completionCommand = cmd || 'completion'
        if (!desc && desc !== false) {
          desc = 'generate bash completion script'
        }
        self.command(completionCommand, desc)
    
        // a function can be provided
        if (fn) completion.registerFunction(fn)
    
        return self
      }
    
      self.showCompletionScript = function ($0) {
        $0 = $0 || self.$0
        console.log(completion.generateCompletionScript($0))
        return self
      }
    
      self.getUsageInstance = function () {
        return usage
      }
    
      self.getValidationInstance = function () {
        return validation
      }
    
      self.terminalWidth = function () {
        return require('window-size').width
      }
    
      Object.defineProperty(self, 'argv', {
        get: function () {
          var args = null
    
          try {
            args = parseArgs(processArgs)
          } catch (err) {
            usage.fail(err.message)
          }
    
          return args
        },
        enumerable: true
      })
    
      function parseArgs (args) {
        var parsed = Parser(args, options)
        var argv = parsed.argv
        var aliases = parsed.aliases
    
        argv.$0 = self.$0
    
        self.parsed = parsed
    
        // while building up the argv object, there
        // are two passes through the parser. If completion
        // is being performed short-circuit on the first pass.
        if (completionCommand &&
          (process.argv.join(' ')).indexOf(completion.completionKey) !== -1 &&
          !argv[completion.completionKey]) {
          return argv
        }
    
        // if there's a handler associated with a
        // command defer processing to it.
        var handlerKeys = Object.keys(self.getCommandHandlers())
        for (var i = 0, command; (command = handlerKeys[i]) !== undefined; i++) {
          if (~argv._.indexOf(command)) {
            self.getCommandHandlers()[command](self.reset())
            return self.argv
          }
        }
    
        // generate a completion script for adding to ~/.bashrc.
        if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {
          self.showCompletionScript()
          if (exitProcess) {
            process.exit(0)
          }
        }
    
        // we must run completions first, a user might
        // want to complete the --help or --version option.
        if (completion.completionKey in argv) {
          // we allow for asynchronous completions,
          // e.g., loading in a list of commands from an API.
          completion.getCompletion(function (completions) {
            ;(completions || []).forEach(function (completion) {
              console.log(completion)
            })
    
            if (exitProcess) {
              process.exit(0)
            }
          })
          return
        }
    
        Object.keys(argv).forEach(function (key) {
          if (key === helpOpt && argv[key]) {
            self.showHelp('log')
            if (exitProcess) {
              process.exit(0)
            }
          } else if (key === versionOpt && argv[key]) {
            usage.showVersion()
            if (exitProcess) {
              process.exit(0)
            }
          }
        })
    
        if (parsed.error) throw parsed.error
    
        // if we're executed via bash completion, don't
        // bother with validation.
        if (!argv[completion.completionKey]) {
          validation.nonOptionCount(argv)
          validation.missingArgumentValue(argv)
          validation.requiredArguments(argv)
          if (strict) validation.unknownArguments(argv, aliases)
          validation.customChecks(argv, aliases)
          validation.implications(argv)
        }
    
        setPlaceholderKeys(argv)
    
        return argv
      }
    
      function setPlaceholderKeys (argv) {
        Object.keys(options.key).forEach(function (key) {
          if (typeof argv[key] === 'undefined') argv[key] = undefined
        })
      }
    
      sigletonify(self)
      return self
    }
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase
    function rebase (base, dir) {
      return path.relative(base, dir)
    }
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
         require('yargs')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
         require('yargs').argv
        to get a parsed version of process.argv.
    */
    function sigletonify (inst) {
      Object.keys(inst).forEach(function (key) {
        if (key === 'argv') {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key))
        } else {
          Argv[key] = typeof inst[key] === 'function'
          ? inst[key].bind(inst)
          : inst[key]
        }
      })
    }
    
  provide("yargs", module.exports);
}(global));

// pakmanager:glob/common.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.alphasort = alphasort
    exports.alphasorti = alphasorti
    exports.setopts = setopts
    exports.ownProp = ownProp
    exports.makeAbs = makeAbs
    exports.finish = finish
    exports.mark = mark
    exports.isIgnored = isIgnored
    exports.childrenIgnored = childrenIgnored
    
    function ownProp (obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field)
    }
    
    var path = require("path")
    var minimatch = require("minimatch")
    var isAbsolute = require("path-is-absolute")
    var Minimatch = minimatch.Minimatch
    
    function alphasorti (a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase())
    }
    
    function alphasort (a, b) {
      return a.localeCompare(b)
    }
    
    function setupIgnores (self, options) {
      self.ignore = options.ignore || []
    
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore]
    
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap)
      }
    }
    
    function ignoreMap (pattern) {
      var gmatcher = null
      if (pattern.slice(-3) === '/**') {
        var gpattern = pattern.replace(/(\/\*\*)+$/, '')
        gmatcher = new Minimatch(gpattern)
      }
    
      return {
        matcher: new Minimatch(pattern),
        gmatcher: gmatcher
      }
    }
    
    function setopts (self, pattern, options) {
      if (!options)
        options = {}
    
      // base-matching: just use globstar for that.
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar")
        }
        pattern = "**/" + pattern
      }
    
      self.silent = !!options.silent
      self.pattern = pattern
      self.strict = options.strict !== false
      self.realpath = !!options.realpath
      self.realpathCache = options.realpathCache || Object.create(null)
      self.follow = !!options.follow
      self.dot = !!options.dot
      self.mark = !!options.mark
      self.nodir = !!options.nodir
      if (self.nodir)
        self.mark = true
      self.sync = !!options.sync
      self.nounique = !!options.nounique
      self.nonull = !!options.nonull
      self.nosort = !!options.nosort
      self.nocase = !!options.nocase
      self.stat = !!options.stat
      self.noprocess = !!options.noprocess
    
      self.maxLength = options.maxLength || Infinity
      self.cache = options.cache || Object.create(null)
      self.statCache = options.statCache || Object.create(null)
      self.symlinks = options.symlinks || Object.create(null)
    
      setupIgnores(self, options)
    
      self.changedCwd = false
      var cwd = process.cwd()
      if (!ownProp(options, "cwd"))
        self.cwd = cwd
      else {
        self.cwd = options.cwd
        self.changedCwd = path.resolve(options.cwd) !== cwd
      }
    
      self.root = options.root || path.resolve(self.cwd, "/")
      self.root = path.resolve(self.root)
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/")
    
      self.nomount = !!options.nomount
    
      // disable comments and negation unless the user explicitly
      // passes in false as the option.
      options.nonegate = options.nonegate === false ? false : true
      options.nocomment = options.nocomment === false ? false : true
      deprecationWarning(options)
    
      self.minimatch = new Minimatch(pattern, options)
      self.options = self.minimatch.options
    }
    
    // TODO(isaacs): remove entirely in v6
    // exported to reset in tests
    exports.deprecationWarned
    function deprecationWarning(options) {
      if (!options.nonegate || !options.nocomment) {
        if (process.noDeprecation !== true && !exports.deprecationWarned) {
          var msg = 'glob WARNING: comments and negation will be disabled in v6'
          if (process.throwDeprecation)
            throw new Error(msg)
          else if (process.traceDeprecation)
            console.trace(msg)
          else
            console.error(msg)
    
          exports.deprecationWarned = true
        }
      }
    }
    
    function finish (self) {
      var nou = self.nounique
      var all = nou ? [] : Object.create(null)
    
      for (var i = 0, l = self.matches.length; i < l; i ++) {
        var matches = self.matches[i]
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            // do like the shell, and spit out the literal glob
            var literal = self.minimatch.globSet[i]
            if (nou)
              all.push(literal)
            else
              all[literal] = true
          }
        } else {
          // had matches
          var m = Object.keys(matches)
          if (nou)
            all.push.apply(all, m)
          else
            m.forEach(function (m) {
              all[m] = true
            })
        }
      }
    
      if (!nou)
        all = Object.keys(all)
    
      if (!self.nosort)
        all = all.sort(self.nocase ? alphasorti : alphasort)
    
      // at *some* point we statted all of these
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i])
        }
        if (self.nodir) {
          all = all.filter(function (e) {
            return !(/\/$/.test(e))
          })
        }
      }
    
      if (self.ignore.length)
        all = all.filter(function(m) {
          return !isIgnored(self, m)
        })
    
      self.found = all
    }
    
    function mark (self, p) {
      var abs = makeAbs(self, p)
      var c = self.cache[abs]
      var m = p
      if (c) {
        var isDir = c === 'DIR' || Array.isArray(c)
        var slash = p.slice(-1) === '/'
    
        if (isDir && !slash)
          m += '/'
        else if (!isDir && slash)
          m = m.slice(0, -1)
    
        if (m !== p) {
          var mabs = makeAbs(self, m)
          self.statCache[mabs] = self.statCache[abs]
          self.cache[mabs] = self.cache[abs]
        }
      }
    
      return m
    }
    
    // lotta situps...
    function makeAbs (self, f) {
      var abs = f
      if (f.charAt(0) === '/') {
        abs = path.join(self.root, f)
      } else if (isAbsolute(f) || f === '') {
        abs = f
      } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f)
      } else {
        abs = path.resolve(f)
      }
      return abs
    }
    
    
    // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
    // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
    function isIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
    function childrenIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
  provide("glob/common.js", module.exports);
}(global));

// pakmanager:glob/glob.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    var isIgnored = common.isIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    glob.hasMagic = function (pattern, options_) {
      var options = util._extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
    
      function done () {
        --self._processing
        if (self._processing <= 0)
          self._finish()
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (isIgnored(this, e))
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob/glob.js", module.exports);
}(global));

// pakmanager:glob/sync.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = globSync
    globSync.GlobSync = GlobSync
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var Glob =  require('glob/glob.js').Glob
    var util = require('util')
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var childrenIgnored = common.childrenIgnored
    
    function globSync (pattern, options) {
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      return new GlobSync(pattern, options).found
    }
    
    function GlobSync (pattern, options) {
      if (!pattern)
        throw new Error('must provide pattern')
    
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options)
    
      setopts(this, pattern, options)
    
      if (this.noprocess)
        return this
    
      var n = this.minimatch.set.length
      this.matches = new Array(n)
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false)
      }
      this._finish()
    }
    
    GlobSync.prototype._finish = function () {
      assert(this instanceof GlobSync)
      if (this.realpath) {
        var self = this
        this.matches.forEach(function (matchset, index) {
          var set = self.matches[index] = Object.create(null)
          for (var p in matchset) {
            try {
              p = self._makeAbs(p)
              var real = fs.realpathSync(p, this.realpathCache)
              set[real] = true
            } catch (er) {
              if (er.syscall === 'stat')
                set[self._makeAbs(p)] = true
              else
                throw er
            }
          }
        })
      }
      common.finish(this)
    }
    
    
    GlobSync.prototype._process = function (pattern, index, inGlobStar) {
      assert(this instanceof GlobSync)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // See if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip processing
      if (childrenIgnored(this, read))
        return
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
    }
    
    
    GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar)
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix.slice(-1) !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this.matches[index][e] = true
        }
        // This was the last one, and no stats were needed
        return
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix)
          newPattern = [prefix, e]
        else
          newPattern = [e]
        this._process(newPattern.concat(remain), index, inGlobStar)
      }
    }
    
    
    GlobSync.prototype._emitMatch = function (index, e) {
      var abs = this._makeAbs(e)
      if (this.mark)
        e = this._mark(e)
    
      if (this.matches[index][e])
        return
    
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      this.matches[index][e] = true
      if (this.stat)
        this._stat(e)
    }
    
    
    GlobSync.prototype._readdirInGlobStar = function (abs) {
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false)
    
      var entries
      var lstat
      var stat
      try {
        lstat = fs.lstatSync(abs)
      } catch (er) {
        // lstat failed, doesn't exist
        return null
      }
    
      var isSym = lstat.isSymbolicLink()
      this.symlinks[abs] = isSym
    
      // If it's not a symlink or a dir, then it's definitely a regular file.
      // don't bother doing a readdir in that case.
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = 'FILE'
      else
        entries = this._readdir(abs, false)
    
      return entries
    }
    
    GlobSync.prototype._readdir = function (abs, inGlobStar) {
      var entries
    
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return null
    
        if (Array.isArray(c))
          return c
      }
    
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs))
      } catch (er) {
        this._readdirError(abs, er)
        return null
      }
    }
    
    GlobSync.prototype._readdirEntries = function (abs, entries) {
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
    
      // mark and cache dir-ness
      return entries
    }
    
    GlobSync.prototype._readdirError = function (f, er) {
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict)
            throw er
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    }
    
    GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
    
      var entries = this._readdir(abs, inGlobStar)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false)
    
      var len = entries.length
      var isSym = this.symlinks[abs]
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true)
      }
    }
    
    GlobSync.prototype._processSimple = function (prefix, index) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var exists = this._stat(prefix)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this.matches[index][prefix] = true
    }
    
    // Returns either 'DIR', 'FILE', or false
    GlobSync.prototype._stat = function (f) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return false
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return c
    
        if (needDir && c === 'FILE')
          return false
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (!stat) {
        var lstat
        try {
          lstat = fs.lstatSync(abs)
        } catch (er) {
          return false
        }
    
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs)
          } catch (er) {
            stat = lstat
          }
        } else {
          stat = lstat
        }
      }
    
      this.statCache[abs] = stat
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return false
    
      return c
    }
    
    GlobSync.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    GlobSync.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
  provide("glob/sync.js", module.exports);
}(global));

// pakmanager:glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    var isIgnored = common.isIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    glob.hasMagic = function (pattern, options_) {
      var options = util._extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
    
      function done () {
        --self._processing
        if (self._processing <= 0)
          self._finish()
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (isIgnored(this, e))
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob", module.exports);
}(global));

// pakmanager:nomnom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var _ = require("underscore"), chalk = require('chalk');
    
    
    function ArgParser() {
       this.commands = {};  // expected commands
       this.specs = {};     // option specifications
    }
    
    ArgParser.prototype = {
      /* Add a command to the expected commands */
      command : function(name) {
        var command;
        if (name) {
          command = this.commands[name] = {
            name: name,
            specs: {}
          };
        }
        else {
          command = this.fallback = {
            specs: {}
          };
        }
    
        // facilitates command('name').options().cb().help()
        var chain = {
          options : function(specs) {
            command.specs = specs;
            return chain;
          },
          opts : function(specs) {
            // old API
            return this.options(specs);
          },
          option : function(name, spec) {
            command.specs[name] = spec;
            return chain;
          },
          callback : function(cb) {
            command.cb = cb;
            return chain;
          },
          help : function(help) {
            command.help = help;
            return chain;
          },
          usage : function(usage) {
            command._usage = usage;
            return chain;
          }
        };
        return chain;
      },
    
      nocommand : function() {
        return this.command();
      },
    
      options : function(specs) {
        this.specs = specs;
        return this;
      },
    
      opts : function(specs) {
        // old API
        return this.options(specs);
      },
    
      globalOpts : function(specs) {
        // old API
        return this.options(specs);
      },
    
      option : function(name, spec) {
        this.specs[name] = spec;
        return this;
      },
    
      usage : function(usage) {
        this._usage = usage;
        return this;
      },
    
      printer : function(print) {
        this.print = print;
        return this;
      },
    
      script : function(script) {
        this._script = script;
        return this;
      },
    
      scriptName : function(script) {
        // old API
        return this.script(script);
      },
    
      help : function(help) {
        this._help = help;
        return this;
      },
    
      colors: function() {
        // deprecated - colors are on by default now
        return this;
      },
    
      nocolors : function() {
        this._nocolors = true;
        return this;
      },
    
      parseArgs : function(argv) {
        // old API
        return this.parse(argv);
      },
    
      nom : function(argv) {
        return this.parse(argv);
      },
    
      parse : function(argv) {
        this.print = this.print || function(str, code) {
          console.log(str);
          process.exit(code || 0);
        };
        this._help = this._help || "";
        this._script = this._script || process.argv[0] + " "
              + require('path').basename(process.argv[1]);
        this.specs = this.specs || {};
    
        var argv = argv || process.argv.slice(2);
    
        var arg = Arg(argv[0]).isValue && argv[0],
            command = arg && this.commands[arg],
            commandExpected = !_(this.commands).isEmpty();
    
        if (commandExpected) {
           if (command) {
              _(this.specs).extend(command.specs);
              this._script += " " + command.name;
              if (command.help) {
                this._help = command.help;
              }
              this.command = command;
           }
           else if (arg) {
              return this.print(this._script + ": no such command '" + arg + "'", 1);
           }
           else {
              // no command but command expected e.g. 'git -v'
              var helpStringBuilder = {
                list : function() {
                   return 'one of: ' + _(this.commands).keys().join(", ");
                },
                twoColumn : function() {
                  // find the longest command name to ensure horizontal alignment
                  var maxLength = _(this.commands).max(function (cmd) {
                    return cmd.name.length;
                  }).name.length;
    
                  // create the two column text strings
                  var cmdHelp = _.map(this.commands, function(cmd, name) {
                    var diff = maxLength - name.length;
                    var pad = new Array(diff + 4).join(" ");
                    return "  " + [ name, pad, cmd.help ].join(" ");
                  });
                  return "\n" + cmdHelp.join("\n");
                }
              };
    
              // if there are a small number of commands and all have help strings,
              // display them in a two column table; otherwise use the brief version.
              // The arbitrary choice of "20" comes from the number commands git
              // displays as "common commands"
              var helpType = 'list';
              if (_(this.commands).size() <= 20) {
                if (_(this.commands).every(function (cmd) { return cmd.help; })) {
                    helpType = 'twoColumn';
                }
              }
    
              this.specs.command = {
                position: 0,
                help: helpStringBuilder[helpType].call(this)
              }
    
              if (this.fallback) {
                _(this.specs).extend(this.fallback.specs);
                this._help = this.fallback.help;
              } else {
                this.specs.command.required = true;
              }
           }
        }
    
        if (this.specs.length === undefined) {
          // specs is a hash not an array
          this.specs = _(this.specs).map(function(opt, name) {
            opt.name = name;
            return opt;
          });
        }
        this.specs = this.specs.map(function(opt) {
          return Opt(opt);
        });
    
        if (argv.indexOf("--help") >= 0 || argv.indexOf("-h") >= 0) {
          return this.print(this.getUsage());
        }
    
        var options = {};
        var args = argv.map(function(arg) {
          return Arg(arg);
        })
        .concat(Arg());
    
        var positionals = [];
    
        /* parse the args */
        var that = this;
        args.reduce(function(arg, val) {
          /* positional */
          if (arg.isValue) {
            positionals.push(arg.value);
          }
          else if (arg.chars) {
            var last = arg.chars.pop();
    
            /* -cfv */
            (arg.chars).forEach(function(ch) {
              that.setOption(options, ch, true);
            });
    
            /* -v key */
            if (!that.opt(last).flag) {
               if (val.isValue)  {
                  that.setOption(options, last, val.value);
                  return Arg(); // skip next turn - swallow arg
               }
               else {
                  that.print("'-" + (that.opt(last).name || last) + "'"
                    + " expects a value\n\n" + that.getUsage(), 1);
               }
            }
            else {
              /* -v */
              that.setOption(options, last, true);
            }
    
          }
          else if (arg.full) {
            var value = arg.value;
    
            /* --key */
            if (value === undefined) {
              /* --key value */
              if (!that.opt(arg.full).flag) {
                if (val.isValue) {
                  that.setOption(options, arg.full, val.value);
                  return Arg();
                }
                else {
                  that.print("'--" + (that.opt(arg.full).name || arg.full) + "'"
                    + " expects a value\n\n" + that.getUsage(), 1);
                }
              }
              else {
                /* --flag */
                value = true;
              }
            }
            that.setOption(options, arg.full, value);
          }
          return val;
        });
    
        positionals.forEach(function(pos, index) {
          this.setOption(options, index, pos);
        }, this);
    
        options._ = positionals;
    
        this.specs.forEach(function(opt) {
          if (opt.default !== undefined && options[opt.name] === undefined) {
            options[opt.name] = opt.default;
          }
        }, this);
    
        // exit if required arg isn't present
        this.specs.forEach(function(opt) {
          if (opt.required && options[opt.name] === undefined) {
             var msg = opt.name + " argument is required";
             msg = this._nocolors ? msg : chalk.red(msg);
    
             this.print("\n" + msg + "\n" + this.getUsage(), 1);
          }
        }, this);
    
        if (command && command.cb) {
          command.cb(options);
        }
        else if (this.fallback && this.fallback.cb) {
          this.fallback.cb(options);
        }
    
        return options;
      },
    
      getUsage : function() {
        if (this.command && this.command._usage) {
          return this.command._usage;
        }
        else if (this.fallback && this.fallback._usage) {
          return this.fallback._usage;
        }
        if (this._usage) {
          return this._usage;
        }
    
        // todo: use a template
        var str = "\n"
        if (!this._nocolors) {
          str += chalk.bold("Usage:");
        }
        else {
          str += "Usage:";
        }
        str += " " + this._script;
    
        var positionals = _(this.specs).select(function(opt) {
          return opt.position != undefined;
        })
        positionals = _(positionals).sortBy(function(opt) {
          return opt.position;
        });
        var options = _(this.specs).select(function(opt) {
          return opt.position === undefined;
        });
    
        // assume there are no gaps in the specified pos. args
        positionals.forEach(function(pos) {
          str += " ";
          var posStr = pos.string;
          if (!posStr) {
            posStr = pos.name || "arg" + pos.position;
            if (pos.required) {
                posStr = "<" + posStr + ">";
            } else {
                posStr = "[" + posStr + "]";
            }
            if (pos.list) {
              posStr += "...";
            }
          }
          str += posStr;
        });
    
        if (options.length) {
          if (!this._nocolors) {
            // must be a better way to do this
            str += chalk.blue(" [options]");
          }
          else {
            str += " [options]";
          }
        }
    
        if (options.length || positionals.length) {
          str += "\n\n";
        }
    
        function spaces(length) {
          var spaces = "";
          for (var i = 0; i < length; i++) {
            spaces += " ";
          }
          return spaces;
        }
        var longest = positionals.reduce(function(max, pos) {
          return pos.name.length > max ? pos.name.length : max;
        }, 0);
    
        positionals.forEach(function(pos) {
          var posStr = pos.string || pos.name;
          str += posStr + spaces(longest - posStr.length) + "     ";
          if (!this._nocolors) {
            str += chalk.grey(pos.help || "")
          }
          else {
            str += (pos.help || "")
          }
          str += "\n";
        }, this);
        if (positionals.length && options.length) {
          str += "\n";
        }
    
        if (options.length) {
          if (!this._nocolors) {
            str += chalk.blue("Options:");
          }
          else {
            str += "Options:";
          }
          str += "\n"
    
          var longest = options.reduce(function(max, opt) {
            return opt.string.length > max && !opt.hidden ? opt.string.length : max;
          }, 0);
    
          options.forEach(function(opt) {
            if (!opt.hidden) {
              str += "   " + opt.string + spaces(longest - opt.string.length) + "   ";
    
              var defaults = (opt.default != null ? "  [" + opt.default + "]" : "");
              var help = opt.help ? opt.help + defaults : "";
              str += this._nocolors ? help: chalk.grey(help);
    
              str += "\n";
            }
          }, this);
        }
    
        if (this._help) {
          str += "\n" + this._help;
        }
        return str;
      }
    };
    
    ArgParser.prototype.opt = function(arg) {
      // get the specified opt for this parsed arg
      var match = Opt({});
      this.specs.forEach(function(opt) {
        if (opt.matches(arg)) {
           match = opt;
        }
      });
      return match;
    };
    
    ArgParser.prototype.setOption = function(options, arg, value) {
      var option = this.opt(arg);
      if (option.callback) {
        var message = option.callback(value);
    
        if (typeof message == "string") {
          this.print(message, 1);
        }
      }
    
      if (option.type != "string") {
         try {
           // infer type by JSON parsing the string
           value = JSON.parse(value)
         }
         catch(e) {}
      }
    
      if (option.transform) {
         value = option.transform(value);
      }
    
      var name = option.name || arg;
      if (option.choices && option.choices.indexOf(value) == -1) {
         this.print(name + " must be one of: " + option.choices.join(", "), 1);
      }
    
      if (option.list) {
        if (!options[name]) {
          options[name] = [value];
        }
        else {
          options[name].push(value);
        }
      }
      else {
        options[name] = value;
      }
    };
    
    
    /* an arg is an item that's actually parsed from the command line
       e.g. "-l", "log.txt", or "--logfile=log.txt" */
    var Arg = function(str) {
      var abbrRegex = /^\-(\w+?)$/,
          fullRegex = /^\-\-(no\-)?(.+?)(?:=(.+))?$/,
          valRegex = /^[^\-].*/;
    
      var charMatch = abbrRegex.exec(str),
          chars = charMatch && charMatch[1].split("");
    
      var fullMatch = fullRegex.exec(str),
          full = fullMatch && fullMatch[2];
    
      var isValue = str !== undefined && (str === "" || valRegex.test(str));
      var value;
      if (isValue) {
        value = str;
      }
      else if (full) {
        value = fullMatch[1] ? false : fullMatch[3];
      }
    
      return {
        str: str,
        chars: chars,
        full: full,
        value: value,
        isValue: isValue
      }
    }
    
    
    /* an opt is what's specified by the user in opts hash */
    var Opt = function(opt) {
      var strings = (opt.string || "").split(","),
          abbr, full, metavar;
      for (var i = 0; i < strings.length; i++) {
        var string = strings[i].trim(),
            matches;
        if (matches = string.match(/^\-([^-])(?:\s+(.*))?$/)) {
          abbr = matches[1];
          metavar = matches[2];
        }
        else if (matches = string.match(/^\-\-(.+?)(?:[=\s]+(.+))?$/)) {
          full = matches[1];
          metavar = metavar || matches[2];
        }
      }
    
      matches = matches || [];
      var abbr = opt.abbr || abbr,   // e.g. v from -v
          full = opt.full || full, // e.g. verbose from --verbose
          metavar = opt.metavar || metavar;  // e.g. PATH from '--config=PATH'
    
      var string;
      if (opt.string) {
        string = opt.string;
      }
      else if (opt.position === undefined) {
        string = "";
        if (abbr) {
          string += "-" + abbr;
          if (metavar)
            string += " " + metavar
          string += ", ";
        }
        string += "--" + (full || opt.name);
        if (metavar) {
          string += " " + metavar;
        }
      }
    
      opt = _(opt).extend({
        name: opt.name || full || abbr,
        string: string,
        abbr: abbr,
        full: full,
        metavar: metavar,
        matches: function(arg) {
          return opt.full == arg || opt.abbr == arg || opt.position == arg
            || opt.name == arg || (opt.list && arg >= opt.position);
        }
      });
      return opt;
    }
    
    
    var createParser = function() {
      return new ArgParser();
    }
    
    var nomnom = createParser();
    
    for (var i in nomnom) {
      if (typeof nomnom[i] == "function") {
         createParser[i] = _(nomnom[i]).bind(nomnom);
      }
    }
    
    module.exports = createParser;
    
  provide("nomnom", module.exports);
}(global));

// pakmanager:JSV/lib/uri/uri
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * URI.js
     * 
     * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @version 1.3
     * @see http://github.com/garycourt/uri-js
     * @license URI.js v1.3 (c) 2010 Gary Court. License: http://github.com/garycourt/uri-js
     */
    
    /**
     * Copyright 2010 Gary Court. All rights reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification, are
     * permitted provided that the following conditions are met:
     * 
     *    1. Redistributions of source code must retain the above copyright notice, this list of
     *       conditions and the following disclaimer.
     * 
     *    2. Redistributions in binary form must reproduce the above copyright notice, this list
     *       of conditions and the following disclaimer in the documentation and/or other materials
     *       provided with the distribution.
     * 
     * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * The views and conclusions contained in the software and documentation are those of the
     * authors and should not be interpreted as representing official policies, either expressed
     * or implied, of Gary Court.
     */
    
    /*jslint white: true, sub: true, onevar: true, undef: true, eqeqeq: true, newcap: true, immed: true, indent: 4 */
    /*global exports:true, require:true */
    
    if (typeof exports === "undefined") {
    	exports = {}; 
    }
    if (typeof require !== "function") {
    	require = function (id) {
    		return exports;
    	};
    }
    (function () {
    	var	
    		/**
    		 * @param {...string} sets
    		 * @return {string}
    		 */
    		mergeSet = function (sets) {
    			var set = arguments[0],
    				x = 1,
    				nextSet = arguments[x];
    			
    			while (nextSet) {
    				set = set.slice(0, -1) + nextSet.slice(1);
    				nextSet = arguments[++x];
    			}
    			
    			return set;
    		},
    		
    		/**
    		 * @param {string} str
    		 * @return {string}
    		 */
    		subexp = function (str) {
    			return "(?:" + str + ")";
    		},
    	
    		ALPHA$$ = "[A-Za-z]",
    		CR$ = "[\\x0D]",
    		DIGIT$$ = "[0-9]",
    		DQUOTE$$ = "[\\x22]",
    		HEXDIG$$ = mergeSet(DIGIT$$, "[A-Fa-f]"),  //case-insensitive
    		LF$$ = "[\\x0A]",
    		SP$$ = "[\\x20]",
    		PCT_ENCODED$ = subexp("%" + HEXDIG$$ + HEXDIG$$),
    		GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
    		SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
    		RESERVED$$ = mergeSet(GEN_DELIMS$$, SUB_DELIMS$$),
    		UNRESERVED$$ = mergeSet(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]"),
    		SCHEME$ = subexp(ALPHA$$ + mergeSet(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
    		USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + mergeSet(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
    		DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
    		IPV4ADDRESS$ = subexp(DEC_OCTET$ + "\\." + DEC_OCTET$ + "\\." + DEC_OCTET$ + "\\." + DEC_OCTET$),
    		H16$ = subexp(HEXDIG$$ + "{1,4}"),
    		LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
    		IPV6ADDRESS$ = subexp(mergeSet(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),  //FIXME
    		IPVFUTURE$ = subexp("v" + HEXDIG$$ + "+\\." + mergeSet(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
    		IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
    		REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + mergeSet(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
    		HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "|" + REG_NAME$),
    		PORT$ = subexp(DIGIT$$ + "*"),
    		AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
    		PCHAR$ = subexp(PCT_ENCODED$ + "|" + mergeSet(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
    		SEGMENT$ = subexp(PCHAR$ + "*"),
    		SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
    		SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + mergeSet(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
    		PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
    		PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),  //simplified
    		PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified
    		PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified
    		PATH_EMPTY$ = subexp(""),  //simplified
    		PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
    		QUERY$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
    		FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
    		HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
    		URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
    		RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
    		RELATIVE_REF$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
    		URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE_REF$),
    		ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
    		
    		URI_REF = new RegExp("^" + subexp("(" + URI$ + ")|(" + RELATIVE_REF$ + ")") + "$"),
    		GENERIC_REF  = new RegExp("^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$"),
    		RELATIVE_REF = new RegExp("^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$"),
    		ABSOLUTE_REF = new RegExp("^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$"),
    		SAMEDOC_REF = new RegExp("^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$"),
    		AUTHORITY = new RegExp("^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$"),
    		
    		NOT_SCHEME = new RegExp(mergeSet("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
    		NOT_USERINFO = new RegExp(mergeSet("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
    		NOT_HOST = new RegExp(mergeSet("[^\\%]", UNRESERVED$$, SUB_DELIMS$$), "g"),
    		NOT_PATH = new RegExp(mergeSet("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
    		NOT_PATH_NOSCHEME = new RegExp(mergeSet("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
    		NOT_QUERY = new RegExp(mergeSet("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
    		NOT_FRAGMENT = NOT_QUERY,
    		ESCAPE = new RegExp(mergeSet("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
    		UNRESERVED = new RegExp(UNRESERVED$$, "g"),
    		OTHER_CHARS = new RegExp(mergeSet("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
    		PCT_ENCODEDS = new RegExp(PCT_ENCODED$ + "+", "g"),
    		URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?([^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/i,
    		RDS1 = /^\.\.?\//,
    		RDS2 = /^\/\.(\/|$)/,
    		RDS3 = /^\/\.\.(\/|$)/,
    		RDS4 = /^\.\.?$/,
    		RDS5 = /^\/?.*?(?=\/|$)/,
    		NO_MATCH_IS_UNDEFINED = ("").match(/(){0}/)[1] === undefined,
    		
    		/**
    		 * @param {string} chr
    		 * @return {string}
    		 */
    		pctEncChar = function (chr) {
    			var c = chr.charCodeAt(0);
     
    			if (c < 128) {
    				return "%" + c.toString(16).toUpperCase();
    			}
    			else if ((c > 127) && (c < 2048)) {
    				return "%" + ((c >> 6) | 192).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();
    			}
    			else {
    				return "%" + ((c >> 12) | 224).toString(16).toUpperCase() + "%" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();
    			}
    		},
    		
    		/**
    		 * @param {string} str
    		 * @return {string}
    		 */
    		pctDecUnreserved = function (str) {
    			var newStr = "", 
    				i = 0,
    				c, s;
    	 
    			while (i < str.length) {
    				c = parseInt(str.substr(i + 1, 2), 16);
    	 
    				if (c < 128) {
    					s = String.fromCharCode(c);
    					if (s.match(UNRESERVED)) {
    						newStr += s;
    					} else {
    						newStr += str.substr(i, 3);
    					}
    					i += 3;
    				}
    				else if ((c > 191) && (c < 224)) {
    					newStr += str.substr(i, 6);
    					i += 6;
    				}
    				else {
    					newStr += str.substr(i, 9);
    					i += 9;
    				}
    			}
    	 
    			return newStr;
    		},
    		
    		/**
    		 * @param {string} str
    		 * @return {string}
    		 */
    		pctDecChars = function (str) {
    			var newStr = "", 
    				i = 0,
    				c, c2, c3;
    	 
    			while (i < str.length) {
    				c = parseInt(str.substr(i + 1, 2), 16);
    	 
    				if (c < 128) {
    					newStr += String.fromCharCode(c);
    					i += 3;
    				}
    				else if ((c > 191) && (c < 224)) {
    					c2 = parseInt(str.substr(i + 4, 2), 16);
    					newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
    					i += 6;
    				}
    				else {
    					c2 = parseInt(str.substr(i + 4, 2), 16);
    					c3 = parseInt(str.substr(i + 7, 2), 16);
    					newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
    					i += 9;
    				}
    			}
    	 
    			return newStr;
    		},
    		
    		/**
    		 * @return {string}
    		 */
    		typeOf = function (o) {
    			return o === undefined ? "undefined" : (o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase());
    		},
    		
    		/**
    		 * @constructor
    		 * @implements URIComponents
    		 */
    		Components = function () {
    			this.errors = [];
    		}, 
    		
    		/** @namespace */ 
    		URI = exports;
    	
    	/**
    	 * Components
    	 */
    	
    	Components.prototype = {
    		/**
    		 * @type String
    		 */
    		
    		scheme : undefined,
    		
    		/**
    		 * @type String
    		 */
    		
    		authority : undefined,
    		
    		/**
    		 * @type String
    		 */
    		
    		userinfo : undefined,
    		
    		/**
    		 * @type String
    		 */
    		
    		host : undefined,
    		
    		/**
    		 * @type number
    		 */
    		
    		port : undefined,
    		
    		/**
    		 * @type string
    		 */
    		
    		path : undefined,
    		
    		/**
    		 * @type string
    		 */
    		
    		query : undefined,
    		
    		/**
    		 * @type string
    		 */
    		
    		fragment : undefined,
    		
    		/**
    		 * @type string
    		 * @values "uri", "absolute", "relative", "same-document"
    		 */
    		
    		reference : undefined,
    		
    		/**
    		 * @type Array
    		 */
    		
    		errors : undefined
    	};
    	
    	/**
    	 * URI
    	 */
    	
    	/**
    	 * @namespace
    	 */
    	
    	URI.SCHEMES = {};
    	
    	/**
    	 * @param {string} uriString
    	 * @param {Options} [options]
    	 * @returns {URIComponents}
    	 */
    	
    	URI.parse = function (uriString, options) {
    		var matches, 
    			components = new Components(),
    			schemeHandler;
    		
    		uriString = uriString ? uriString.toString() : "";
    		options = options || {};
    		
    		if (options.reference === "suffix") {
    			uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    		}
    		
    		matches = uriString.match(URI_REF);
    		
    		if (matches) {
    			if (matches[1]) {
    				//generic URI
    				matches = uriString.match(GENERIC_REF);
    			} else {
    				//relative URI
    				matches = uriString.match(RELATIVE_REF);
    			}
    		} 
    		
    		if (!matches) {
    			if (!options.tolerant) {
    				components.errors.push("URI is not strictly valid.");
    			}
    			matches = uriString.match(URI_PARSE);
    		}
    		
    		if (matches) {
    			if (NO_MATCH_IS_UNDEFINED) {
    				//store each component
    				components.scheme = matches[1];
    				components.authority = matches[2];
    				components.userinfo = matches[3];
    				components.host = matches[4];
    				components.port = parseInt(matches[5], 10);
    				components.path = matches[6] || "";
    				components.query = matches[7];
    				components.fragment = matches[8];
    				
    				//fix port number
    				if (isNaN(components.port)) {
    					components.port = matches[5];
    				}
    			} else {  //IE FIX for improper RegExp matching
    				//store each component
    				components.scheme = matches[1] || undefined;
    				components.authority = (uriString.indexOf("//") !== -1 ? matches[2] : undefined);
    				components.userinfo = (uriString.indexOf("@") !== -1 ? matches[3] : undefined);
    				components.host = (uriString.indexOf("//") !== -1 ? matches[4] : undefined);
    				components.port = parseInt(matches[5], 10);
    				components.path = matches[6] || "";
    				components.query = (uriString.indexOf("?") !== -1 ? matches[7] : undefined);
    				components.fragment = (uriString.indexOf("#") !== -1 ? matches[8] : undefined);
    				
    				//fix port number
    				if (isNaN(components.port)) {
    					components.port = (uriString.match(/\/\/.*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined);
    				}
    			}
    			
    			//determine reference type
    			if (!components.scheme && !components.authority && !components.path && !components.query) {
    				components.reference = "same-document";
    			} else if (!components.scheme) {
    				components.reference = "relative";
    			} else if (!components.fragment) {
    				components.reference = "absolute";
    			} else {
    				components.reference = "uri";
    			}
    			
    			//check for reference errors
    			if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
    				components.errors.push("URI is not a " + options.reference + " reference.");
    			}
    			
    			//check if a handler for the scheme exists
    			schemeHandler = URI.SCHEMES[(components.scheme || options.scheme || "").toLowerCase()];
    			if (schemeHandler && schemeHandler.parse) {
    				//perform extra parsing
    				schemeHandler.parse(components, options);
    			}
    		} else {
    			components.errors.push("URI can not be parsed.");
    		}
    		
    		return components;
    	};
    	
    	/**
    	 * @private
    	 * @param {URIComponents} components
    	 * @returns {string|undefined}
    	 */
    	
    	URI._recomposeAuthority = function (components) {
    		var uriTokens = [];
    		
    		if (components.userinfo !== undefined || components.host !== undefined || typeof components.port === "number") {
    			if (components.userinfo !== undefined) {
    				uriTokens.push(components.userinfo.toString().replace(NOT_USERINFO, pctEncChar));
    				uriTokens.push("@");
    			}
    			if (components.host !== undefined) {
    				uriTokens.push(components.host.toString().toLowerCase().replace(NOT_HOST, pctEncChar));
    			}
    			if (typeof components.port === "number") {
    				uriTokens.push(":");
    				uriTokens.push(components.port.toString(10));
    			}
    		}
    		
    		return uriTokens.length ? uriTokens.join("") : undefined;
    	};
    	
    	/**
    	 * @param {string} input
    	 * @returns {string}
    	 */
    	
    	URI.removeDotSegments = function (input) {
    		var output = [], s;
    		
    		while (input.length) {
    			if (input.match(RDS1)) {
    				input = input.replace(RDS1, "");
    			} else if (input.match(RDS2)) {
    				input = input.replace(RDS2, "/");
    			} else if (input.match(RDS3)) {
    				input = input.replace(RDS3, "/");
    				output.pop();
    			} else if (input === "." || input === "..") {
    				input = "";
    			} else {
    				s = input.match(RDS5)[0];
    				input = input.slice(s.length);
    				output.push(s);
    			}
    		}
    		
    		return output.join("");
    	};
    	
    	/**
    	 * @param {URIComponents} components
    	 * @param {Options} [options]
    	 * @returns {string}
    	 */
    	
    	URI.serialize = function (components, options) {
    		var uriTokens = [], 
    			schemeHandler, 
    			s;
    		options = options || {};
    		
    		//check if a handler for the scheme exists
    		schemeHandler = URI.SCHEMES[components.scheme || options.scheme];
    		if (schemeHandler && schemeHandler.serialize) {
    			//perform extra serialization
    			schemeHandler.serialize(components, options);
    		}
    		
    		if (options.reference !== "suffix" && components.scheme) {
    			uriTokens.push(components.scheme.toString().toLowerCase().replace(NOT_SCHEME, ""));
    			uriTokens.push(":");
    		}
    		
    		components.authority = URI._recomposeAuthority(components);
    		if (components.authority !== undefined) {
    			if (options.reference !== "suffix") {
    				uriTokens.push("//");
    			}
    			
    			uriTokens.push(components.authority);
    			
    			if (components.path && components.path.charAt(0) !== "/") {
    				uriTokens.push("/");
    			}
    		}
    		
    		if (components.path) {
    			s = URI.removeDotSegments(components.path.toString().replace(/%2E/ig, "."));
    			
    			if (components.scheme) {
    				s = s.replace(NOT_PATH, pctEncChar);
    			} else {
    				s = s.replace(NOT_PATH_NOSCHEME, pctEncChar);
    			}
    			
    			if (components.authority === undefined) {
    				s = s.replace(/^\/\//, "/%2F");  //don't allow the path to start with "//"
    			}
    			uriTokens.push(s);
    		}
    		
    		if (components.query) {
    			uriTokens.push("?");
    			uriTokens.push(components.query.toString().replace(NOT_QUERY, pctEncChar));
    		}
    		
    		if (components.fragment) {
    			uriTokens.push("#");
    			uriTokens.push(components.fragment.toString().replace(NOT_FRAGMENT, pctEncChar));
    		}
    		
    		return uriTokens
    			.join('')  //merge tokens into a string
    			.replace(PCT_ENCODEDS, pctDecUnreserved)  //undecode unreserved characters
    			//.replace(OTHER_CHARS, pctEncChar)  //replace non-URI characters
    			.replace(/%[0-9A-Fa-f]{2}/g, function (str) {  //uppercase percent encoded characters
    				return str.toUpperCase();
    			})
    		;
    	};
    	
    	/**
    	 * @param {URIComponents} base
    	 * @param {URIComponents} relative
    	 * @param {Options} [options]
    	 * @param {boolean} [skipNormalization]
    	 * @returns {URIComponents}
    	 */
    	
    	URI.resolveComponents = function (base, relative, options, skipNormalization) {
    		var target = new Components();
    		
    		if (!skipNormalization) {
    			base = URI.parse(URI.serialize(base, options), options);  //normalize base components
    			relative = URI.parse(URI.serialize(relative, options), options);  //normalize relative components
    		}
    		options = options || {};
    		
    		if (!options.tolerant && relative.scheme) {
    			target.scheme = relative.scheme;
    			target.authority = relative.authority;
    			target.userinfo = relative.userinfo;
    			target.host = relative.host;
    			target.port = relative.port;
    			target.path = URI.removeDotSegments(relative.path);
    			target.query = relative.query;
    		} else {
    			if (relative.authority !== undefined) {
    				target.authority = relative.authority;
    				target.userinfo = relative.userinfo;
    				target.host = relative.host;
    				target.port = relative.port;
    				target.path = URI.removeDotSegments(relative.path);
    				target.query = relative.query;
    			} else {
    				if (!relative.path) {
    					target.path = base.path;
    					if (relative.query !== undefined) {
    						target.query = relative.query;
    					} else {
    						target.query = base.query;
    					}
    				} else {
    					if (relative.path.charAt(0) === "/") {
    						target.path = URI.removeDotSegments(relative.path);
    					} else {
    						if (base.authority !== undefined && !base.path) {
    							target.path = "/" + relative.path;
    						} else if (!base.path) {
    							target.path = relative.path;
    						} else {
    							target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
    						}
    						target.path = URI.removeDotSegments(target.path);
    					}
    					target.query = relative.query;
    				}
    				target.authority = base.authority;
    				target.userinfo = base.userinfo;
    				target.host = base.host;
    				target.port = base.port;
    			}
    			target.scheme = base.scheme;
    		}
    		
    		target.fragment = relative.fragment;
    		
    		return target;
    	};
    	
    	/**
    	 * @param {string} baseURI
    	 * @param {string} relativeURI
    	 * @param {Options} [options]
    	 * @returns {string}
    	 */
    	
    	URI.resolve = function (baseURI, relativeURI, options) {
    		return URI.serialize(URI.resolveComponents(URI.parse(baseURI, options), URI.parse(relativeURI, options), options, true), options);
    	};
    	
    	/**
    	 * @param {string|URIComponents} uri
    	 * @param {Options} options
    	 * @returns {string|URIComponents}
    	 */
    	
    	URI.normalize = function (uri, options) {
    		if (typeof uri === "string") {
    			return URI.serialize(URI.parse(uri, options), options);
    		} else if (typeOf(uri) === "object") {
    			return URI.parse(URI.serialize(uri, options), options);
    		}
    		
    		return uri;
    	};
    	
    	/**
    	 * @param {string|URIComponents} uriA
    	 * @param {string|URIComponents} uriB
    	 * @param {Options} options
    	 */
    	
    	URI.equal = function (uriA, uriB, options) {
    		if (typeof uriA === "string") {
    			uriA = URI.serialize(URI.parse(uriA, options), options);
    		} else if (typeOf(uriA) === "object") {
    			uriA = URI.serialize(uriA, options);
    		}
    		
    		if (typeof uriB === "string") {
    			uriB = URI.serialize(URI.parse(uriB, options), options);
    		} else if (typeOf(uriB) === "object") {
    			uriB = URI.serialize(uriB, options);
    		}
    		
    		return uriA === uriB;
    	};
    	
    	/**
    	 * @param {string} str
    	 * @returns {string}
    	 */
    	
    	URI.escapeComponent = function (str) {
    		return str && str.toString().replace(ESCAPE, pctEncChar);
    	};
    	
    	/**
    	 * @param {string} str
    	 * @returns {string}
    	 */
    	
    	URI.unescapeComponent = function (str) {
    		return str && str.toString().replace(PCT_ENCODEDS, pctDecChars);
    	};
    	
    	//export API
    	exports.pctEncChar = pctEncChar;
    	exports.pctDecChars = pctDecChars;
    	exports.Components = Components;
    	exports.URI = URI;
    	
    	//name-safe export API
    	exports["pctEncChar"] = pctEncChar;
    	exports["pctDecChars"] = pctDecChars;
    	exports["Components"] = Components;
    	exports["URI"] = {
    		"SCHEMES" : URI.SCHEMES,
    		"parse" : URI.parse,
    		"removeDotSegments" : URI.removeDotSegments,
    		"serialize" : URI.serialize,
    		"resolveComponents" : URI.resolveComponents,
    		"resolve" : URI.resolve,
    		"normalize" : URI.normalize,
    		"equal" : URI.equal,
    		"escapeComponent" : URI.escapeComponent,
    		"unescapeComponent" : URI.unescapeComponent
    	};
    	
    }());
  provide("JSV/lib/uri/uri", module.exports);
}(global));

// pakmanager:JSV/lib/jsv
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * JSV: JSON Schema Validator
     * 
     * @fileOverview A JavaScript implementation of a extendable, fully compliant JSON Schema validator.
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @version 4.0.2
     * @see http://github.com/garycourt/JSV
     */
    
    /*
     * Copyright 2010 Gary Court. All rights reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification, are
     * permitted provided that the following conditions are met:
     * 
     *    1. Redistributions of source code must retain the above copyright notice, this list of
     *       conditions and the following disclaimer.
     * 
     *    2. Redistributions in binary form must reproduce the above copyright notice, this list
     *       of conditions and the following disclaimer in the documentation and/or other materials
     *       provided with the distribution.
     * 
     * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * The views and conclusions contained in the software and documentation are those of the
     * authors and should not be interpreted as representing official policies, either expressed
     * or implied, of Gary Court or the JSON Schema specification.
     */
    
    /*jslint white: true, sub: true, onevar: true, undef: true, eqeqeq: true, newcap: true, immed: true, indent: 4 */
    
    var exports = exports || this,
    	require = require || function () {
    		return exports;
    	};
    
    (function () {
    	
    	var URI =  require('JSV/lib/uri/uri').URI,
    		O = {},
    		I2H = "0123456789abcdef".split(""),
    		mapArray, filterArray, searchArray,
    		
    		JSV;
    	
    	//
    	// Utility functions
    	//
    	
    	function typeOf(o) {
    		return o === undefined ? "undefined" : (o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase());
    	}
    	
    	/** @inner */
    	function F() {}
    	
    	function createObject(proto) {
    		F.prototype = proto || {};
    		return new F();
    	}
    	
    	function mapObject(obj, func, scope) {
    		var newObj = {}, key;
    		for (key in obj) {
    			if (obj[key] !== O[key]) {
    				newObj[key] = func.call(scope, obj[key], key, obj);
    			}
    		}
    		return newObj;
    	}
    	
    	/** @ignore */
    	mapArray = function (arr, func, scope) {
    		var x = 0, xl = arr.length, newArr = new Array(xl);
    		for (; x < xl; ++x) {
    			newArr[x] = func.call(scope, arr[x], x, arr);
    		}
    		return newArr;
    	};
    		
    	if (Array.prototype.map) {
    		/** @ignore */
    		mapArray = function (arr, func, scope) {
    			return Array.prototype.map.call(arr, func, scope);
    		};
    	}
    	
    	/** @ignore */
    	filterArray = function (arr, func, scope) {
    		var x = 0, xl = arr.length, newArr = [];
    		for (; x < xl; ++x) {
    			if (func.call(scope, arr[x], x, arr)) {
    				newArr[newArr.length] = arr[x];
    			}
    		}
    		return newArr;
    	};
    	
    	if (Array.prototype.filter) {
    		/** @ignore */
    		filterArray = function (arr, func, scope) {
    			return Array.prototype.filter.call(arr, func, scope);
    		};
    	}
    	
    	/** @ignore */
    	searchArray = function (arr, o) {
    		var x = 0, xl = arr.length;
    		for (; x < xl; ++x) {
    			if (arr[x] === o) {
    				return x;
    			}
    		}
    		return -1;
    	};
    	
    	if (Array.prototype.indexOf) {
    		/** @ignore */
    		searchArray = function (arr, o) {
    			return Array.prototype.indexOf.call(arr, o);
    		};
    	}
    	
    	function toArray(o) {
    		return o !== undefined && o !== null ? (o instanceof Array && !o.callee ? o : (typeof o.length !== "number" || o.split || o.setInterval || o.call ? [ o ] : Array.prototype.slice.call(o))) : [];
    	}
    	
    	function keys(o) {
    		var result = [], key;
    		
    		switch (typeOf(o)) {
    		case "object":
    			for (key in o) {
    				if (o[key] !== O[key]) {
    					result[result.length] = key;
    				}
    			}
    			break;
    		case "array":
    			for (key = o.length - 1; key >= 0; --key) {
    				result[key] = key;
    			}
    			break;
    		}
    		
    		return result;
    	}
    	
    	function pushUnique(arr, o) {
    		if (searchArray(arr, o) === -1) {
    			arr.push(o);
    		}
    		return arr;
    	}
    	
    	function popFirst(arr, o) {
    		var index = searchArray(arr, o);
    		if (index > -1) {
    			arr.splice(index, 1);
    		}
    		return arr;
    	}
    	
    	function randomUUID() {
    		return [
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-",
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-4",  //set 4 high bits of time_high field to version
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-",
    			I2H[(Math.floor(Math.random() * 0x10) & 0x3) | 0x8],  //specify 2 high bits of clock sequence
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-",
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)]
    		].join("");
    	}
    	
    	function escapeURIComponent(str) {
    		return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
    	}
    	
    	function formatURI(uri) {
    		if (typeof uri === "string" && uri.indexOf("#") === -1) {
    			uri += "#";
    		}
    		return uri;
    	}
    	
    	function stripInstances(o) {
    		if (o instanceof JSONInstance) {
    			return o.getURI();
    		}
    		
    		switch (typeOf(o)) {
    		case "undefined":
    		case "null":
    		case "boolean":
    		case "number":
    		case "string":
    			return o;  //do nothing
    		
    		case "object":
    			return mapObject(o, stripInstances);
    		
    		case "array":
    			return mapArray(o, stripInstances);
    		
    		default:
    			return o.toString();
    		}
    	}
    	
    	/**
    	 * The exception that is thrown when a schema fails to be created.
    	 * 
    	 * @name InitializationError
    	 * @class
    	 * @param {JSONInstance|String} instance The instance (or instance URI) that is invalid
    	 * @param {JSONSchema|String} schema The schema (or schema URI) that was validating the instance
    	 * @param {String} attr The attribute that failed to validated
    	 * @param {String} message A user-friendly message on why the schema attribute failed to validate the instance
    	 * @param {Any} details The value of the schema attribute
    	 */
    	
    	function InitializationError(instance, schema, attr, message, details) {
    		Error.call(this, message);
    		
    		this.uri = instance instanceof JSONInstance ? instance.getURI() : instance;
    		this.schemaUri = schema instanceof JSONInstance ? schema.getURI() : schema;
    		this.attribute = attr;
    		this.message = message;
    		this.description = message;  //IE
    		this.details = details;
    	}
    	
    	InitializationError.prototype = new Error();
    	InitializationError.prototype.constructor = InitializationError;
    	InitializationError.prototype.name = "InitializationError";
    	
    	/**
    	 * Defines an error, found by a schema, with an instance.
    	 * This class can only be instantiated by {@link Report#addError}. 
    	 * 
    	 * @name ValidationError
    	 * @class
    	 * @see Report#addError
    	 */
    	
    	/**
    	 * The URI of the instance that has the error.
    	 * 
    	 * @name ValidationError.prototype.uri
    	 * @type String
    	 */
    	
    	/**
    	 * The URI of the schema that generated the error.
    	 * 
    	 * @name ValidationError.prototype.schemaUri
    	 * @type String
    	 */
    	
    	/**
    	 * The name of the schema attribute that generated the error.
    	 * 
    	 * @name ValidationError.prototype.attribute
    	 * @type String
    	 */
    	
    	/**
    	 * An user-friendly (English) message about what failed to validate.
    	 * 
    	 * @name ValidationError.prototype.message
    	 * @type String
    	 */
    	
    	/**
    	 * The value of the schema attribute that generated the error.
    	 * 
    	 * @name ValidationError.prototype.details
    	 * @type Any
    	 */
    	
    	/**
    	 * Reports are returned from validation methods to describe the result of a validation.
    	 * 
    	 * @name Report
    	 * @class
    	 * @see JSONSchema#validate
    	 * @see Environment#validate
    	 */
    	
    	function Report() {
    		/**
    		 * An array of {@link ValidationError} objects that define all the errors generated by the schema against the instance.
    		 * 
    		 * @name Report.prototype.errors
    		 * @type Array
    		 * @see Report#addError
    		 */
    		this.errors = [];
    		
    		/**
    		 * A hash table of every instance and what schemas were validated against it.
    		 * <p>
    		 * The key of each item in the table is the URI of the instance that was validated.
    		 * The value of this key is an array of strings of URIs of the schema that validated it.
    		 * </p>
    		 * 
    		 * @name Report.prototype.validated
    		 * @type Object
    		 * @see Report#registerValidation
    		 * @see Report#isValidatedBy
    		 */
    		this.validated = {};
    		
    		/**
    		 * If the report is generated by {@link Environment#validate}, this field is the generated instance.
    		 * 
    		 * @name Report.prototype.instance
    		 * @type JSONInstance
    		 * @see Environment#validate
    		 */
    		
    		/**
    		 * If the report is generated by {@link Environment#validate}, this field is the generated schema.
    		 * 
    		 * @name Report.prototype.schema
    		 * @type JSONSchema
    		 * @see Environment#validate
    		 */
    		 
    		/**
    		 * If the report is generated by {@link Environment#validate}, this field is the schema's schema.
    		 * This value is the same as calling <code>schema.getSchema()</code>.
    		 * 
    		 * @name Report.prototype.schemaSchema
    		 * @type JSONSchema
    		 * @see Environment#validate
    		 * @see JSONSchema#getSchema
    		 */
    	}
    	
    	/**
    	 * Adds a {@link ValidationError} object to the <a href="#errors"><code>errors</code></a> field.
    	 * 
    	 * @param {JSONInstance|String} instance The instance (or instance URI) that is invalid
    	 * @param {JSONSchema|String} schema The schema (or schema URI) that was validating the instance
    	 * @param {String} attr The attribute that failed to validated
    	 * @param {String} message A user-friendly message on why the schema attribute failed to validate the instance
    	 * @param {Any} details The value of the schema attribute
    	 */
    	
    	Report.prototype.addError = function (instance, schema, attr, message, details) {
    		this.errors.push({
    			uri : instance instanceof JSONInstance ? instance.getURI() : instance,
    			schemaUri : schema instanceof JSONInstance ? schema.getURI() : schema,
    			attribute : attr,
    			message : message,
    			details : stripInstances(details)
    		});
    	};
    	
    	/**
    	 * Registers that the provided instance URI has been validated by the provided schema URI. 
    	 * This is recorded in the <a href="#validated"><code>validated</code></a> field.
    	 * 
    	 * @param {String} uri The URI of the instance that was validated
    	 * @param {String} schemaUri The URI of the schema that validated the instance
    	 */
    	
    	Report.prototype.registerValidation = function (uri, schemaUri) {
    		if (!this.validated[uri]) {
    			this.validated[uri] = [ schemaUri ];
    		} else {
    			this.validated[uri].push(schemaUri);
    		}
    	};
    	
    	/**
    	 * Returns if an instance with the provided URI has been validated by the schema with the provided URI. 
    	 * 
    	 * @param {String} uri The URI of the instance
    	 * @param {String} schemaUri The URI of a schema
    	 * @returns {Boolean} If the instance has been validated by the schema.
    	 */
    	
    	Report.prototype.isValidatedBy = function (uri, schemaUri) {
    		return !!this.validated[uri] && searchArray(this.validated[uri], schemaUri) !== -1;
    	};
    	
    	/**
    	 * A wrapper class for binding an Environment, URI and helper methods to an instance. 
    	 * This class is most commonly instantiated with {@link Environment#createInstance}.
    	 * 
    	 * @name JSONInstance
    	 * @class
    	 * @param {Environment} env The environment this instance belongs to
    	 * @param {JSONInstance|Any} json The value of the instance
    	 * @param {String} [uri] The URI of the instance. If undefined, the URI will be a randomly generated UUID. 
    	 * @param {String} [fd] The fragment delimiter for properties. If undefined, uses the environment default.
    	 */
    	
    	function JSONInstance(env, json, uri, fd) {
    		if (json instanceof JSONInstance) {
    			if (typeof fd !== "string") {
    				fd = json._fd;
    			}
    			if (typeof uri !== "string") {
    				uri = json._uri;
    			}
    			json = json._value;
    		}
    		
    		if (typeof uri !== "string") {
    			uri = "urn:uuid:" + randomUUID() + "#";
    		} else if (uri.indexOf(":") === -1) {
    			uri = formatURI(URI.resolve("urn:uuid:" + randomUUID() + "#", uri));
    		}
    		
    		this._env = env;
    		this._value = json;
    		this._uri = uri;
    		this._fd = fd || this._env._options["defaultFragmentDelimiter"];
    	}
    	
    	/**
    	 * Returns the environment the instance is bound to.
    	 * 
    	 * @returns {Environment} The environment of the instance
    	 */
    	
    	JSONInstance.prototype.getEnvironment = function () {
    		return this._env;
    	};
    	
    	/**
    	 * Returns the name of the type of the instance.
    	 * 
    	 * @returns {String} The name of the type of the instance
    	 */
    	
    	JSONInstance.prototype.getType = function () {
    		return typeOf(this._value);
    	};
    	
    	/**
    	 * Returns the JSON value of the instance.
    	 * 
    	 * @returns {Any} The actual JavaScript value of the instance
    	 */
    	
    	JSONInstance.prototype.getValue = function () {
    		return this._value;
    	};
    	
    	/**
    	 * Returns the URI of the instance.
    	 * 
    	 * @returns {String} The URI of the instance
    	 */
    	
    	JSONInstance.prototype.getURI = function () {
    		return this._uri;
    	};
    	
    	/**
    	 * Returns a resolved URI of a provided relative URI against the URI of the instance.
    	 * 
    	 * @param {String} uri The relative URI to resolve
    	 * @returns {String} The resolved URI
    	 */
    	
    	JSONInstance.prototype.resolveURI = function (uri) {
    		return formatURI(URI.resolve(this._uri, uri));
    	};
    	
    	/**
    	 * Returns an array of the names of all the properties.
    	 * 
    	 * @returns {Array} An array of strings which are the names of all the properties
    	 */
    	
    	JSONInstance.prototype.getPropertyNames = function () {
    		return keys(this._value);
    	};
    	
    	/**
    	 * Returns a {@link JSONInstance} of the value of the provided property name. 
    	 * 
    	 * @param {String} key The name of the property to fetch
    	 * @returns {JSONInstance} The instance of the property value
    	 */
    	
    	JSONInstance.prototype.getProperty = function (key) {
    		var value = this._value ? this._value[key] : undefined;
    		if (value instanceof JSONInstance) {
    			return value;
    		}
    		//else
    		return new JSONInstance(this._env, value, this._uri + this._fd + escapeURIComponent(key), this._fd);
    	};
    	
    	/**
    	 * Returns all the property instances of the target instance.
    	 * <p>
    	 * If the target instance is an Object, then the method will return a hash table of {@link JSONInstance}s of all the properties. 
    	 * If the target instance is an Array, then the method will return an array of {@link JSONInstance}s of all the items.
    	 * </p> 
    	 * 
    	 * @returns {Object|Array|undefined} The list of instances for all the properties
    	 */
    	
    	JSONInstance.prototype.getProperties = function () {
    		var type = typeOf(this._value),
    			self = this;
    		
    		if (type === "object") {
    			return mapObject(this._value, function (value, key) {
    				if (value instanceof JSONInstance) {
    					return value;
    				}
    				return new JSONInstance(self._env, value, self._uri + self._fd + escapeURIComponent(key), self._fd);
    			});
    		} else if (type === "array") {
    			return mapArray(this._value, function (value, key) {
    				if (value instanceof JSONInstance) {
    					return value;
    				}
    				return new JSONInstance(self._env, value, self._uri + self._fd + escapeURIComponent(key), self._fd);
    			});
    		}
    	};
    	
    	/**
    	 * Returns the JSON value of the provided property name. 
    	 * This method is a faster version of calling <code>instance.getProperty(key).getValue()</code>.
    	 * 
    	 * @param {String} key The name of the property
    	 * @returns {Any} The JavaScript value of the instance
    	 * @see JSONInstance#getProperty
    	 * @see JSONInstance#getValue
    	 */
    	
    	JSONInstance.prototype.getValueOfProperty = function (key) {
    		if (this._value) {
    			if (this._value[key] instanceof JSONInstance) {
    				return this._value[key]._value;
    			}
    			return this._value[key];
    		}
    	};
    	
    	/**
    	 * Return if the provided value is the same as the value of the instance.
    	 * 
    	 * @param {JSONInstance|Any} instance The value to compare
    	 * @returns {Boolean} If both the instance and the value match
    	 */
    	
    	JSONInstance.prototype.equals = function (instance) {
    		if (instance instanceof JSONInstance) {
    			return this._value === instance._value;
    		}
    		//else
    		return this._value === instance;
    	};
    	
    	/**
    	 * Warning: Not a generic clone function
    	 * Produces a JSV acceptable clone
    	 */
    	
    	function clone(obj, deep) {
    		var newObj, x;
    		
    		if (obj instanceof JSONInstance) {
    			obj = obj.getValue();
    		}
    		
    		switch (typeOf(obj)) {
    		case "object":
    			if (deep) {
    				newObj = {};
    				for (x in obj) {
    					if (obj[x] !== O[x]) {
    						newObj[x] = clone(obj[x], deep);
    					}
    				}
    				return newObj;
    			} else {
    				return createObject(obj);
    			}
    			break;
    		case "array":
    			if (deep) {
    				newObj = new Array(obj.length);
    				x = obj.length;
    				while (--x >= 0) {
    					newObj[x] = clone(obj[x], deep);
    				}
    				return newObj;
    			} else {
    				return Array.prototype.slice.call(obj);
    			}
    			break;
    		default:
    			return obj;
    		}
    	}
    	
    	/**
    	 * This class binds a {@link JSONInstance} with a {@link JSONSchema} to provided context aware methods. 
    	 * 
    	 * @name JSONSchema
    	 * @class
    	 * @param {Environment} env The environment this schema belongs to
    	 * @param {JSONInstance|Any} json The value of the schema
    	 * @param {String} [uri] The URI of the schema. If undefined, the URI will be a randomly generated UUID. 
    	 * @param {JSONSchema|Boolean} [schema] The schema to bind to the instance. If <code>undefined</code>, the environment's default schema will be used. If <code>true</code>, the instance's schema will be itself.
    	 * @extends JSONInstance
    	 */
    	
    	function JSONSchema(env, json, uri, schema) {
    		var fr;
    		JSONInstance.call(this, env, json, uri);
    		
    		if (schema === true) {
    			this._schema = this;
    		} else if (json instanceof JSONSchema && !(schema instanceof JSONSchema)) {
    			this._schema = json._schema;  //TODO: Make sure cross environments don't mess everything up
    		} else {
    			this._schema = schema instanceof JSONSchema ? schema : this._env.getDefaultSchema() || this._env.createEmptySchema();
    		}
    		
    		//determine fragment delimiter from schema
    		fr = this._schema.getValueOfProperty("fragmentResolution");
    		if (fr === "dot-delimited") {
    			this._fd = ".";
    		} else if (fr === "slash-delimited") {
    			this._fd = "/";
    		}
    		
    		return this.rebuild();  //this works even when called with "new"
    	}
    	
    	JSONSchema.prototype = createObject(JSONInstance.prototype);
    	
    	/**
    	 * Returns the schema of the schema.
    	 * 
    	 * @returns {JSONSchema} The schema of the schema
    	 */
    	
    	JSONSchema.prototype.getSchema = function () {
    		var uri = this._refs && this._refs["describedby"],
    			newSchema;
    		
    		if (uri) {
    			newSchema = uri && this._env.findSchema(uri);
    			
    			if (newSchema) {
    				if (!newSchema.equals(this._schema)) {
    					this._schema = newSchema;
    					this.rebuild();  //if the schema has changed, the context has changed - so everything must be rebuilt
    				}
    			} else if (this._env._options["enforceReferences"]) {
    				throw new InitializationError(this, this._schema, "{describedby}", "Unknown schema reference", uri);
    			}
    		}
    		
    		return this._schema;
    	};
    	
    	/**
    	 * Returns the value of the provided attribute name.
    	 * <p>
    	 * This method is different from {@link JSONInstance#getProperty} as the named property 
    	 * is converted using a parser defined by the schema's schema before being returned. This
    	 * makes the return value of this method attribute dependent.
    	 * </p>
    	 * 
    	 * @param {String} key The name of the attribute
    	 * @param {Any} [arg] Some attribute parsers accept special arguments for returning resolved values. This is attribute dependent.
    	 * @returns {JSONSchema|Any} The value of the attribute
    	 */
    	
    	JSONSchema.prototype.getAttribute = function (key, arg) {
    		var schemaProperty, parser, property, result,
    			schema = this.getSchema();  //we do this here to make sure the "describedby" reference has not changed, and that the attribute cache is up-to-date
    		
    		if (!arg && this._attributes && this._attributes.hasOwnProperty(key)) {
    			return this._attributes[key];
    		}
    		
    		schemaProperty = schema.getProperty("properties").getProperty(key);
    		parser = schemaProperty.getValueOfProperty("parser");
    		property = this.getProperty(key);
    		if (typeof parser === "function") {
    			result = parser(property, schemaProperty, arg);
    			if (!arg && this._attributes) {
    				this._attributes[key] = result;
    			}
    			return result;
    		}
    		//else
    		return property.getValue();
    	};
    	
    	/**
    	 * Returns all the attributes of the schema.
    	 * 
    	 * @returns {Object} A map of all parsed attribute values
    	 */
    	
    	JSONSchema.prototype.getAttributes = function () {
    		var properties, schemaProperties, key, schemaProperty, parser,
    			schema = this.getSchema();  //we do this here to make sure the "describedby" reference has not changed, and that the attribute cache is up-to-date
    		
    		if (!this._attributes && this.getType() === "object") {
    			properties = this.getProperties();
    			schemaProperties = schema.getProperty("properties");
    			this._attributes = {};
    			for (key in properties) {
    				if (properties[key] !== O[key]) {
    					schemaProperty = schemaProperties && schemaProperties.getProperty(key);
    					parser = schemaProperty && schemaProperty.getValueOfProperty("parser");
    					if (typeof parser === "function") {
    						this._attributes[key] = parser(properties[key], schemaProperty);
    					} else {
    						this._attributes[key] = properties[key].getValue();
    					}
    				}
    			}
    		}
    		
    		return clone(this._attributes, false);
    	};
    	
    	/**
    	 * Convenience method for retrieving a link or link object from a schema. 
    	 * This method is the same as calling <code>schema.getAttribute("links", [rel, instance])[0];</code>.
    	 * 
    	 * @param {String} rel The link relationship
    	 * @param {JSONInstance} [instance] The instance to resolve any URIs from
    	 * @returns {String|Object|undefined} If <code>instance</code> is provided, a string containing the resolve URI of the link is returned.
    	 *   If <code>instance</code> is not provided, a link object is returned with details of the link.
    	 *   If no link with the provided relationship exists, <code>undefined</code> is returned.
    	 * @see JSONSchema#getAttribute
    	 */
    	
    	JSONSchema.prototype.getLink = function (rel, instance) {
    		var schemaLinks = this.getAttribute("links", [rel, instance]);
    		if (schemaLinks && schemaLinks.length && schemaLinks[schemaLinks.length - 1]) {
    			return schemaLinks[schemaLinks.length - 1];
    		}
    	};
    	
    	/**
    	 * Validates the provided instance against the target schema and returns a {@link Report}.
    	 * 
    	 * @param {JSONInstance|Any} instance The instance to validate; may be a {@link JSONInstance} or any JavaScript value
    	 * @param {Report} [report] A {@link Report} to concatenate the result of the validation to. If <code>undefined</code>, a new {@link Report} is created. 
    	 * @param {JSONInstance} [parent] The parent/containing instance of the provided instance
    	 * @param {JSONSchema} [parentSchema] The schema of the parent/containing instance
    	 * @param {String} [name] The name of the parent object's property that references the instance
    	 * @returns {Report} The result of the validation
    	 */
    	
    	JSONSchema.prototype.validate = function (instance, report, parent, parentSchema, name) {
    		var schemaSchema = this.getSchema(),
    			validator = schemaSchema.getValueOfProperty("validator");
    		
    		if (!(instance instanceof JSONInstance)) {
    			instance = this.getEnvironment().createInstance(instance);
    		}
    		
    		if (!(report instanceof Report)) {
    			report = new Report();
    		}
    		
    		if (this._env._options["validateReferences"] && this._refs) {
    			if (this._refs["describedby"] && !this._env.findSchema(this._refs["describedby"])) {
    				report.addError(this, this._schema, "{describedby}", "Unknown schema reference", this._refs["describedby"]);
    			}
    			if (this._refs["full"] && !this._env.findSchema(this._refs["full"])) {
    				report.addError(this, this._schema, "{full}", "Unknown schema reference", this._refs["full"]);
    			}
    		}
    		
    		if (typeof validator === "function" && !report.isValidatedBy(instance.getURI(), this.getURI())) {
    			report.registerValidation(instance.getURI(), this.getURI());
    			validator(instance, this, schemaSchema, report, parent, parentSchema, name);
    		}
    		
    		return report;
    	};
    	
    	/** @inner */
    	function createFullLookupWrapper(func) {
    		return /** @inner */ function fullLookupWrapper() {
    			var scope = this,
    				stack = [],
    				uri = scope._refs && scope._refs["full"],
    				schema;
    			
    			while (uri) {
    				schema = scope._env.findSchema(uri);
    				if (schema) {
    					if (schema._value === scope._value) {
    						break;
    					}
    					scope = schema;
    					stack.push(uri);
    					uri = scope._refs && scope._refs["full"];
    					if (stack.indexOf(uri) > -1) {
    						break;  //stop infinite loop
    					}
    				} else if (scope._env._options["enforceReferences"]) {
    					throw new InitializationError(scope, scope._schema, "{full}", "Unknown schema reference", uri);
    				} else {
    					uri = null;
    				}
    			}
    			return func.apply(scope, arguments);
    		};
    	}
    	
    	/**
    	 * Wraps all JSONInstance methods with a function that resolves the "full" reference.
    	 * 
    	 * @inner
    	 */
    	
    	(function () {
    		var key;
    		for (key in JSONSchema.prototype) {
    			if (JSONSchema.prototype[key] !== O[key] && typeOf(JSONSchema.prototype[key]) === "function") {
    				JSONSchema.prototype[key] = createFullLookupWrapper(JSONSchema.prototype[key]);
    			}
    		}
    	}());
    	
    	/**
    	 * Reinitializes/re-registers/rebuilds the schema.
    	 * <br/>
    	 * This is used internally, and should only be called when a schema's private variables are modified directly.
    	 * 
    	 * @private
    	 * @return {JSONSchema} The newly rebuilt schema
    	 */
    	
    	JSONSchema.prototype.rebuild = function () {
    		var instance = this,
    			initializer = instance.getSchema().getValueOfProperty("initializer");
    		
    		//clear previous built values
    		instance._refs = null;
    		instance._attributes = null;
    		
    		if (typeof initializer === "function") {
    			instance = initializer(instance);
    		}
    		
    		//register schema
    		instance._env._schemas[instance._uri] = instance;
    		
    		//build & cache the rest of the schema
    		instance.getAttributes();
    		
    		return instance;
    	};
    	
    	/**
    	 * Set the provided reference to the given value.
    	 * <br/>
    	 * References are used for establishing soft-links to other {@link JSONSchema}s.
    	 * Currently, the following references are natively supported:
    	 * <dl>
    	 *   <dt><code>full</code></dt>
    	 *   <dd>The value is the URI to the full instance of this instance.</dd>
    	 *   <dt><code>describedby</code></dt>
    	 *   <dd>The value is the URI to the schema of this instance.</dd>
    	 * </dl>
    	 * 
    	 * @param {String} name The name of the reference
    	 * @param {String} uri The URI of the schema to refer to
    	 */
    	
    	JSONSchema.prototype.setReference = function (name, uri) {
    		if (!this._refs) {
    			this._refs = {};
    		}
    		this._refs[name] = this.resolveURI(uri);
    	};
    	
    	/**
    	 * Returns the value of the provided reference name.
    	 * 
    	 * @param {String} name The name of the reference
    	 * @return {String} The value of the provided reference name
    	 */
    	
    	JSONSchema.prototype.getReference = function (name) {
    		return this._refs && this._refs[name];
    	};
    	
    	/**
    	 * Merges two schemas/instances together.
    	 */
    	
    	function inherits(base, extra, extension) {
    		var baseType = typeOf(base),
    			extraType = typeOf(extra),
    			child, x;
    		
    		if (extraType === "undefined") {
    			return clone(base, true);
    		} else if (baseType === "undefined" || extraType !== baseType) {
    			return clone(extra, true);
    		} else if (extraType === "object") {
    			if (base instanceof JSONSchema) {
    				base = base.getAttributes();
    			}
    			if (extra instanceof JSONSchema) {
    				extra = extra.getAttributes();
    				if (extra["extends"] && extension && extra["extends"] instanceof JSONSchema) {
    					extra["extends"] = [ extra["extends"] ];
    				}
    			}
    			child = clone(base, true);  //this could be optimized as some properties get overwritten
    			for (x in extra) {
    				if (extra[x] !== O[x]) {
    					child[x] = inherits(base[x], extra[x], extension);
    				}
    			}
    			return child;
    		} else {
    			return clone(extra, true);
    		}
    	}
    	
    	/**
    	 * An Environment is a sandbox of schemas thats behavior is different from other environments.
    	 * 
    	 * @name Environment
    	 * @class
    	 */
    	
    	function Environment() {
    		this._id = randomUUID();
    		this._schemas = {};
    		this._options = {};
    		
    		this.createSchema({}, true, "urn:jsv:empty-schema#");
    	}
    	
    	/**
    	 * Returns a clone of the target environment.
    	 * 
    	 * @returns {Environment} A new {@link Environment} that is a exact copy of the target environment 
    	 */
    	
    	Environment.prototype.clone = function () {
    		var env = new Environment();
    		env._schemas = createObject(this._schemas);
    		env._options = createObject(this._options);
    		
    		return env;
    	};
    	
    	/**
    	 * Returns a new {@link JSONInstance} of the provided data.
    	 * 
    	 * @param {JSONInstance|Any} data The value of the instance
    	 * @param {String} [uri] The URI of the instance. If undefined, the URI will be a randomly generated UUID. 
    	 * @returns {JSONInstance} A new {@link JSONInstance} from the provided data
    	 */
    	
    	Environment.prototype.createInstance = function (data, uri) {
    		uri = formatURI(uri);
    		
    		if (data instanceof JSONInstance && (!uri || data.getURI() === uri)) {
    			return data;
    		}
    
    		return new JSONInstance(this, data, uri);
    	};
    	
    	/**
    	 * Creates a new {@link JSONSchema} from the provided data, and registers it with the environment. 
    	 * 
    	 * @param {JSONInstance|Any} data The value of the schema
    	 * @param {JSONSchema|Boolean} [schema] The schema to bind to the instance. If <code>undefined</code>, the environment's default schema will be used. If <code>true</code>, the instance's schema will be itself.
    	 * @param {String} [uri] The URI of the schema. If undefined, the URI will be a randomly generated UUID. 
    	 * @returns {JSONSchema} A new {@link JSONSchema} from the provided data
    	 * @throws {InitializationError} If a schema that is not registered with the environment is referenced 
    	 */
    	
    	Environment.prototype.createSchema = function (data, schema, uri) {
    		uri = formatURI(uri);
    		
    		if (data instanceof JSONSchema && (!uri || data._uri === uri) && (!schema || data.getSchema().equals(schema))) {
    			return data;
    		}
    		
    		return new JSONSchema(this, data, uri, schema);
    	};
    	
    	/**
    	 * Creates an empty schema.
    	 * 
    	 * @returns {JSONSchema} The empty schema, who's schema is itself.
    	 */
    	
    	Environment.prototype.createEmptySchema = function () {
    		return this._schemas["urn:jsv:empty-schema#"];
    	};
    	
    	/**
    	 * Returns the schema registered with the provided URI.
    	 * 
    	 * @param {String} uri The absolute URI of the required schema
    	 * @returns {JSONSchema|undefined} The request schema, or <code>undefined</code> if not found
    	 */
    	
    	Environment.prototype.findSchema = function (uri) {
    		return this._schemas[formatURI(uri)];
    	};
    	
    	/**
    	 * Sets the specified environment option to the specified value.
    	 * 
    	 * @param {String} name The name of the environment option to set
    	 * @param {Any} value The new value of the environment option
    	 */
    	
    	Environment.prototype.setOption = function (name, value) {
    		this._options[name] = value;
    	};
    	
    	/**
    	 * Returns the specified environment option.
    	 * 
    	 * @param {String} name The name of the environment option to set
    	 * @returns {Any} The value of the environment option
    	 */
    	
    	Environment.prototype.getOption = function (name) {
    		return this._options[name];
    	};
    	
    	/**
    	 * Sets the default fragment delimiter of the environment.
    	 * 
    	 * @deprecated Use {@link Environment#setOption} with option "defaultFragmentDelimiter"
    	 * @param {String} fd The fragment delimiter character
    	 */
    	
    	Environment.prototype.setDefaultFragmentDelimiter = function (fd) {
    		if (typeof fd === "string" && fd.length > 0) {
    			this._options["defaultFragmentDelimiter"] = fd;
    		}
    	};
    	
    	/**
    	 * Returns the default fragment delimiter of the environment.
    	 * 
    	 * @deprecated Use {@link Environment#getOption} with option "defaultFragmentDelimiter"
    	 * @returns {String} The fragment delimiter character
    	 */
    	
    	Environment.prototype.getDefaultFragmentDelimiter = function () {
    		return this._options["defaultFragmentDelimiter"];
    	};
    	
    	/**
    	 * Sets the URI of the default schema for the environment.
    	 * 
    	 * @deprecated Use {@link Environment#setOption} with option "defaultSchemaURI"
    	 * @param {String} uri The default schema URI
    	 */
    	
    	Environment.prototype.setDefaultSchemaURI = function (uri) {
    		if (typeof uri === "string") {
    			this._options["defaultSchemaURI"] = formatURI(uri);
    		}
    	};
    	
    	/**
    	 * Returns the default schema of the environment.
    	 * 
    	 * @returns {JSONSchema} The default schema
    	 */
    	
    	Environment.prototype.getDefaultSchema = function () {
    		return this.findSchema(this._options["defaultSchemaURI"]);
    	};
    	
    	/**
    	 * Validates both the provided schema and the provided instance, and returns a {@link Report}. 
    	 * If the schema fails to validate, the instance will not be validated.
    	 * 
    	 * @param {JSONInstance|Any} instanceJSON The {@link JSONInstance} or JavaScript value to validate.
    	 * @param {JSONSchema|Any} schemaJSON The {@link JSONSchema} or JavaScript value to use in the validation. This will also be validated againt the schema's schema.
    	 * @returns {Report} The result of the validation
    	 */
    	
    	Environment.prototype.validate = function (instanceJSON, schemaJSON) {
    		var instance,
    			schema,
    			schemaSchema,
    			report = new Report();
    		
    		try {
    			instance = this.createInstance(instanceJSON);
    			report.instance = instance;
    		} catch (e) {
    			report.addError(e.uri, e.schemaUri, e.attribute, e.message, e.details);
    		}
    		
    		try {
    			schema = this.createSchema(schemaJSON);
    			report.schema = schema;
    			
    			schemaSchema = schema.getSchema();
    			report.schemaSchema = schemaSchema;
    		} catch (f) {
    			report.addError(f.uri, f.schemaUri, f.attribute, f.message, f.details);
    		}
    		
    		if (schemaSchema) {
    			schemaSchema.validate(schema, report);
    		}
    			
    		if (report.errors.length) {
    			return report;
    		}
    		
    		return schema.validate(instance, report);
    	};
    	
    	/**
    	 * @private
    	 */
    	
    	Environment.prototype._checkForInvalidInstances = function (stackSize, schemaURI) {
    		var result = [],
    			stack = [
    				[schemaURI, this._schemas[schemaURI]]
    			], 
    			counter = 0,
    			item, uri, instance, properties, key;
    		
    		while (counter++ < stackSize && stack.length) {
    			item = stack.shift();
    			uri = item[0];
    			instance = item[1];
    			
    			if (instance instanceof JSONSchema) {
    				if (this._schemas[instance._uri] !== instance) {
    					result.push("Instance " + uri + " does not match " + instance._uri);
    				} else {
    					//schema = instance.getSchema();
    					//stack.push([uri + "/{schema}", schema]);
    					
    					properties = instance.getAttributes();
    					for (key in properties) {
    						if (properties[key] !== O[key]) {
    							stack.push([uri + "/" + escapeURIComponent(key), properties[key]]);
    						}
    					}
    				}
    			} else if (typeOf(instance) === "object") {
    				properties = instance;
    				for (key in properties) {
    					if (properties.hasOwnProperty(key)) {
    						stack.push([uri + "/" + escapeURIComponent(key), properties[key]]);
    					}
    				}
    			} else if (typeOf(instance) === "array") {
    				properties = instance;
    				for (key = 0; key < properties.length; ++key) {
    					stack.push([uri + "/" + escapeURIComponent(key), properties[key]]);
    				}
    			}
    		}
    		
    		return result.length ? result : counter;
    	};
    	
    	/**
    	 * A globaly accessible object that provides the ability to create and manage {@link Environments},
    	 * as well as providing utility methods.
    	 * 
    	 * @namespace
    	 */
    	
    	JSV = {
    		_environments : {},
    		_defaultEnvironmentID : "",
    		
    		/**
    		 * Returns if the provide value is an instance of {@link JSONInstance}.
    		 * 
    		 * @param o The value to test
    		 * @returns {Boolean} If the provide value is an instance of {@link JSONInstance}
    		 */
    		
    		isJSONInstance : function (o) {
    			return o instanceof JSONInstance;
    		},
    		
    		/**
    		 * Returns if the provide value is an instance of {@link JSONSchema}.
    		 * 
    		 * @param o The value to test
    		 * @returns {Boolean} If the provide value is an instance of {@link JSONSchema}
    		 */
    		
    		isJSONSchema : function (o) {
    			return o instanceof JSONSchema;
    		},
    		
    		/**
    		 * Creates and returns a new {@link Environment} that is a clone of the environment registered with the provided ID.
    		 * If no environment ID is provided, the default environment is cloned.
    		 * 
    		 * @param {String} [id] The ID of the environment to clone. If <code>undefined</code>, the default environment ID is used.
    		 * @returns {Environment} A newly cloned {@link Environment}
    		 * @throws {Error} If there is no environment registered with the provided ID
    		 */
    		
    		createEnvironment : function (id) {
    			id = id || this._defaultEnvironmentID;
    			
    			if (!this._environments[id]) {
    				throw new Error("Unknown Environment ID");
    			}
    			//else
    			return this._environments[id].clone();
    		},
    		
    		Environment : Environment,
    		
    		/**
    		 * Registers the provided {@link Environment} with the provided ID.
    		 * 
    		 * @param {String} id The ID of the environment
    		 * @param {Environment} env The environment to register
    		 */
    		
    		registerEnvironment : function (id, env) {
    			id = id || (env || 0)._id;
    			if (id && !this._environments[id] && env instanceof Environment) {
    				env._id = id;
    				this._environments[id] = env;
    			}
    		},
    		
    		/**
    		 * Sets which registered ID is the default environment.
    		 * 
    		 * @param {String} id The ID of the registered environment that is default
    		 * @throws {Error} If there is no registered environment with the provided ID
    		 */
    		
    		setDefaultEnvironmentID : function (id) {
    			if (typeof id === "string") {
    				if (!this._environments[id]) {
    					throw new Error("Unknown Environment ID");
    				}
    				
    				this._defaultEnvironmentID = id;
    			}
    		},
    		
    		/**
    		 * Returns the ID of the default environment.
    		 * 
    		 * @returns {String} The ID of the default environment
    		 */
    		
    		getDefaultEnvironmentID : function () {
    			return this._defaultEnvironmentID;
    		},
    		
    		//
    		// Utility Functions
    		//
    		
    		/**
    		 * Returns the name of the type of the provided value.
    		 *
    		 * @event //utility
    		 * @param {Any} o The value to determine the type of
    		 * @returns {String} The name of the type of the value
    		 */
    		typeOf : typeOf,
    		
    		/**
    		 * Return a new object that inherits all of the properties of the provided object.
    		 *
    		 * @event //utility
    		 * @param {Object} proto The prototype of the new object
    		 * @returns {Object} A new object that inherits all of the properties of the provided object
    		 */
    		createObject : createObject,
    		
    		/**
    		 * Returns a new object with each property transformed by the iterator.
    		 *
    		 * @event //utility
    		 * @param {Object} obj The object to transform
    		 * @param {Function} iterator A function that returns the new value of the provided property
    		 * @param {Object} [scope] The value of <code>this</code> in the iterator
    		 * @returns {Object} A new object with each property transformed
    		 */
    		mapObject : mapObject,
    		
    		/**
    		 * Returns a new array with each item transformed by the iterator.
    		 * 
    		 * @event //utility
    		 * @param {Array} arr The array to transform
    		 * @param {Function} iterator A function that returns the new value of the provided item
    		 * @param {Object} scope The value of <code>this</code> in the iterator
    		 * @returns {Array} A new array with each item transformed
    		 */
    		mapArray : mapArray,
    		
    		/**
    		 * Returns a new array that only contains the items allowed by the iterator.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to filter
    		 * @param {Function} iterator The function that returns true if the provided property should be added to the array
    		 * @param {Object} scope The value of <code>this</code> within the iterator
    		 * @returns {Array} A new array that contains the items allowed by the iterator
    		 */
    		filterArray : filterArray,
    		
    		/**
    		 * Returns the first index in the array that the provided item is located at.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to search
    		 * @param {Any} o The item being searched for
    		 * @returns {Number} The index of the item in the array, or <code>-1</code> if not found
    		 */
    		searchArray : searchArray,
    			
    		/**
    		 * Returns an array representation of a value.
    		 * <ul>
    		 * <li>For array-like objects, the value will be casted as an Array type.</li>
    		 * <li>If an array is provided, the function will simply return the same array.</li>
    		 * <li>For a null or undefined value, the result will be an empty Array.</li>
    		 * <li>For all other values, the value will be the first element in a new Array. </li>
    		 * </ul>
    		 *
    		 * @event //utility
    		 * @param {Any} o The value to convert into an array
    		 * @returns {Array} The value as an array
    		 */
    		toArray : toArray,
    		
    		/**
    		 * Returns an array of the names of all properties of an object.
    		 * 
    		 * @event //utility
    		 * @param {Object|Array} o The object in question
    		 * @returns {Array} The names of all properties
    		 */
    		keys : keys,
    		
    		/**
    		 * Mutates the array by pushing the provided value onto the array only if it is not already there.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to modify
    		 * @param {Any} o The object to add to the array if it is not already there
    		 * @returns {Array} The provided array for chaining
    		 */
    		pushUnique : pushUnique,
    		
    		/**
    		 * Mutates the array by removing the first item that matches the provided value in the array.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to modify
    		 * @param {Any} o The object to remove from the array
    		 * @returns {Array} The provided array for chaining
    		 */
    		popFirst : popFirst,
    		
    		/**
    		 * Creates a copy of the target object.
    		 * <p>
    		 * This method will create a new instance of the target, and then mixin the properties of the target.
    		 * If <code>deep</code> is <code>true</code>, then each property will be cloned before mixin.
    		 * </p>
    		 * <p><b>Warning</b>: This is not a generic clone function, as it will only properly clone objects and arrays.</p>
    		 * 
    		 * @event //utility
    		 * @param {Any} o The value to clone 
    		 * @param {Boolean} [deep=false] If each property should be recursively cloned
    		 * @returns A cloned copy of the provided value
    		 */
    		clone : clone,
    		
    		/**
    		 * Generates a pseudo-random UUID.
    		 * 
    		 * @event //utility
    		 * @returns {String} A new universally unique ID
    		 */
    		randomUUID : randomUUID,
    		
    		/**
    		 * Properly escapes a URI component for embedding into a URI string.
    		 * 
    		 * @event //utility
    		 * @param {String} str The URI component to escape
    		 * @returns {String} The escaped URI component
    		 */
    		escapeURIComponent : escapeURIComponent,
    		
    		/**
    		 * Returns a URI that is formated for JSV. Currently, this only ensures that the URI ends with a hash tag (<code>#</code>).
    		 * 
    		 * @event //utility
    		 * @param {String} uri The URI to format
    		 * @returns {String} The URI formatted for JSV
    		 */
    		formatURI : formatURI,
    		
    		/**
    		 * Merges two schemas/instance together.
    		 * 
    		 * @event //utility
    		 * @param {JSONSchema|Any} base The old value to merge
    		 * @param {JSONSchema|Any} extra The new value to merge
    		 * @param {Boolean} extension If the merge is a JSON Schema extension
    		 * @return {Any} The modified base value
    		 */
    		 
    		inherits : inherits,
    		
    		/**
    		 * @private
    		 * @event //utility
    		 */
    		
    		InitializationError : InitializationError
    	};
    	
    	this.JSV = JSV;  //set global object
    	exports.JSV = JSV;  //export to CommonJS
    	
    	 require('JSV/lib/environments');  //load default environments
    	
    }());
  provide("JSV/lib/jsv", module.exports);
}(global));

// pakmanager:JSV/lib/json-schema-draft-01
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * json-schema-draft-01 Environment
     * 
     * @fileOverview Implementation of the first revision of the JSON Schema specification draft.
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @version 1.7.1
     * @see http://github.com/garycourt/JSV
     */
    
    /*
     * Copyright 2010 Gary Court. All rights reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification, are
     * permitted provided that the following conditions are met:
     * 
     *    1. Redistributions of source code must retain the above copyright notice, this list of
     *       conditions and the following disclaimer.
     * 
     *    2. Redistributions in binary form must reproduce the above copyright notice, this list
     *       of conditions and the following disclaimer in the documentation and/or other materials
     *       provided with the distribution.
     * 
     * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * The views and conclusions contained in the software and documentation are those of the
     * authors and should not be interpreted as representing official policies, either expressed
     * or implied, of Gary Court or the JSON Schema specification.
     */
    
    /*jslint white: true, sub: true, onevar: true, undef: true, eqeqeq: true, newcap: true, immed: true, indent: 4 */
    /*global require */
    
    (function () {
    	var O = {},
    		JSV =  require('JSV/lib/jsv').JSV,
    		ENVIRONMENT,
    		TYPE_VALIDATORS,
    		SCHEMA,
    		HYPERSCHEMA,
    		LINKS;
    	
    	TYPE_VALIDATORS = {
    		"string" : function (instance, report) {
    			return instance.getType() === "string";
    		},
    		
    		"number" : function (instance, report) {
    			return instance.getType() === "number";
    		},
    		
    		"integer" : function (instance, report) {
    			return instance.getType() === "number" && instance.getValue() % 1 === 0;
    		},
    		
    		"boolean" : function (instance, report) {
    			return instance.getType() === "boolean";
    		},
    		
    		"object" : function (instance, report) {
    			return instance.getType() === "object";
    		},
    		
    		"array" : function (instance, report) {
    			return instance.getType() === "array";
    		},
    		
    		"null" : function (instance, report) {
    			return instance.getType() === "null";
    		},
    		
    		"any" : function (instance, report) {
    			return true;
    		}
    	};
    	
    	ENVIRONMENT = new JSV.Environment();
    	ENVIRONMENT.setOption("defaultFragmentDelimiter", ".");
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/schema#");  //updated later
    	
    	SCHEMA = ENVIRONMENT.createSchema({
    		"$schema" : "http://json-schema.org/hyper-schema#",
    		"id" : "http://json-schema.org/schema#",
    		"type" : "object",
    		
    		"properties" : {
    			"type" : {
    				"type" : ["string", "array"],
    				"items" : {
    					"type" : ["string", {"$ref" : "#"}]
    				},
    				"optional" : true,
    				"uniqueItems" : true,
    				"default" : "any",
    				
    				"parser" : function (instance, self) {
    					var parser;
    					
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					} else if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(
    							instance, 
    							self.getEnvironment().findSchema(self.resolveURI("#"))
    						);
    					} else if (instance.getType() === "array") {
    						parser = self.getValueOfProperty("parser");
    						return JSV.mapArray(instance.getProperties(), function (prop) {
    							return parser(prop, self);
    						});
    					}
    					//else
    					return "any";
    				},
    			
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var requiredTypes = JSV.toArray(schema.getAttribute("type")),
    						x, xl, type, subreport, typeValidators;
    					
    					//for instances that are required to be a certain type
    					if (instance.getType() !== "undefined" && requiredTypes && requiredTypes.length) {
    						typeValidators = self.getValueOfProperty("typeValidators") || {};
    						
    						//ensure that type matches for at least one of the required types
    						for (x = 0, xl = requiredTypes.length; x < xl; ++x) {
    							type = requiredTypes[x];
    							if (JSV.isJSONSchema(type)) {
    								subreport = JSV.createObject(report);
    								subreport.errors = [];
    								subreport.validated = JSV.clone(report.validated);
    								if (type.validate(instance, subreport, parent, parentSchema, name).errors.length === 0) {
    									return true;  //instance matches this schema
    								}
    							} else {
    								if (typeValidators[type] !== O[type] && typeof typeValidators[type] === "function") {
    									if (typeValidators[type](instance, report)) {
    										return true;  //type is valid
    									}
    								} else {
    									return true;  //unknown types are assumed valid
    								}
    							}
    						}
    						
    						//if we get to this point, type is invalid
    						report.addError(instance, schema, "type", "Instance is not a required type", requiredTypes);
    						return false;
    					}
    					//else, anything is allowed if no type is specified
    					return true;
    				},
    				
    				"typeValidators" : TYPE_VALIDATORS
    			},
    			
    			"properties" : {
    				"type" : "object",
    				"additionalProperties" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self, arg) {
    					var env = instance.getEnvironment(),
    						selfEnv = self.getEnvironment();
    					if (instance.getType() === "object") {
    						if (arg) {
    							return env.createSchema(instance.getProperty(arg), selfEnv.findSchema(self.resolveURI("#")));
    						} else {
    							return JSV.mapObject(instance.getProperties(), function (instance) {
    								return env.createSchema(instance, selfEnv.findSchema(self.resolveURI("#")));
    							});
    						}
    					}
    					//else
    					return {};
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var propertySchemas, key;
    					//this attribute is for object type instances only
    					if (instance.getType() === "object") {
    						//for each property defined in the schema
    						propertySchemas = schema.getAttribute("properties");
    						for (key in propertySchemas) {
    							if (propertySchemas[key] !== O[key] && propertySchemas[key]) {
    								//ensure that instance property is valid
    								propertySchemas[key].validate(instance.getProperty(key), report, instance, schema, key);
    							}
    						}
    					}
    				}
    			},
    			
    			"items" : {
    				"type" : [{"$ref" : "#"}, "array"],
    				"items" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "array") {
    						return JSV.mapArray(instance.getProperties(), function (instance) {
    							return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    						});
    					}
    					//else
    					return instance.getEnvironment().createEmptySchema();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var properties, items, x, xl, itemSchema, additionalProperties;
    					
    					if (instance.getType() === "array") {
    						properties = instance.getProperties();
    						items = schema.getAttribute("items");
    						additionalProperties = schema.getAttribute("additionalProperties");
    						
    						if (JSV.typeOf(items) === "array") {
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema = items[x] || additionalProperties;
    								if (itemSchema !== false) {
    									itemSchema.validate(properties[x], report, instance, schema, x);
    								} else {
    									report.addError(instance, schema, "additionalProperties", "Additional items are not allowed", itemSchema);
    								}
    							}
    						} else {
    							itemSchema = items || additionalProperties;
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema.validate(properties[x], report, instance, schema, x);
    							}
    						}
    					}
    				}
    			},
    			
    			"optional" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					if (instance.getType() === "undefined" && !schema.getAttribute("optional")) {
    						report.addError(instance, schema, "optional", "Property is required", false);
    					}
    				},
    				
    				"validationRequired" : true
    			},
    			
    			"additionalProperties" : {
    				"type" : [{"$ref" : "#"}, "boolean"],
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "boolean" && instance.getValue() === false) {
    						return false;
    					}
    					//else
    					return instance.getEnvironment().createEmptySchema();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var additionalProperties, propertySchemas, properties, key;
    					//we only need to check against object types as arrays do their own checking on this property
    					if (instance.getType() === "object") {
    						additionalProperties = schema.getAttribute("additionalProperties");
    						propertySchemas = schema.getAttribute("properties") || {};
    						properties = instance.getProperties();
    						for (key in properties) {
    							if (properties[key] !== O[key] && properties[key] && !propertySchemas[key]) {
    								if (JSV.isJSONSchema(additionalProperties)) {
    									additionalProperties.validate(properties[key], report, instance, schema, key);
    								} else if (additionalProperties === false) {
    									report.addError(instance, schema, "additionalProperties", "Additional properties are not allowed", additionalProperties);
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"requires" : {
    				"type" : ["string", {"$ref" : "#"}],
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					} else if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var requires;
    					if (instance.getType() !== "undefined" && parent && parent.getType() !== "undefined") {
    						requires = schema.getAttribute("requires");
    						if (typeof requires === "string") {
    							if (parent.getProperty(requires).getType() === "undefined") {
    								report.addError(instance, schema, "requires", 'Property requires sibling property "' + requires + '"', requires);
    							}
    						} else if (JSV.isJSONSchema(requires)) {
    							requires.validate(parent, report);  //WATCH: A "requires" schema does not support the "requires" attribute
    						}
    					}
    				}
    			},
    			
    			"minimum" : {
    				"type" : "number",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minimum, minimumCanEqual;
    					if (instance.getType() === "number") {
    						minimum = schema.getAttribute("minimum");
    						minimumCanEqual = schema.getAttribute("minimumCanEqual");
    						if (typeof minimum === "number" && (instance.getValue() < minimum || (minimumCanEqual === false && instance.getValue() === minimum))) {
    							report.addError(instance, schema, "minimum", "Number is less than the required minimum value", minimum);
    						}
    					}
    				}
    			},
    			
    			"maximum" : {
    				"type" : "number",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maximum, maximumCanEqual;
    					if (instance.getType() === "number") {
    						maximum = schema.getAttribute("maximum");
    						maximumCanEqual = schema.getAttribute("maximumCanEqual");
    						if (typeof maximum === "number" && (instance.getValue() > maximum || (maximumCanEqual === false && instance.getValue() === maximum))) {
    							report.addError(instance, schema, "maximum", "Number is greater than the required maximum value", maximum);
    						}
    					}
    				}
    			},
    			
    			"minimumCanEqual" : {
    				"type" : "boolean",
    				"optional" : true,
    				"requires" : "minimum",
    				"default" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "boolean") {
    						return instance.getValue();
    					}
    					//else
    					return true;
    				}
    			},
    			
    			"maximumCanEqual" : {
    				"type" : "boolean",
    				"optional" : true,
    				"requires" : "maximum",
    				"default" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "boolean") {
    						return instance.getValue();
    					}
    					//else
    					return true;
    				}
    			},
    			
    			"minItems" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				"default" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    					//else
    					return 0;
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minItems;
    					if (instance.getType() === "array") {
    						minItems = schema.getAttribute("minItems");
    						if (typeof minItems === "number" && instance.getProperties().length < minItems) {
    							report.addError(instance, schema, "minItems", "The number of items is less than the required minimum", minItems);
    						}
    					}
    				}
    			},
    			
    			"maxItems" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxItems;
    					if (instance.getType() === "array") {
    						maxItems = schema.getAttribute("maxItems");
    						if (typeof maxItems === "number" && instance.getProperties().length > maxItems) {
    							report.addError(instance, schema, "maxItems", "The number of items is greater than the required maximum", maxItems);
    						}
    					}
    				}
    			},
    			
    			"pattern" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "regex",
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var pattern;
    					try {
    						pattern = new RegExp(schema.getAttribute("pattern"));
    						if (instance.getType() === "string" && pattern && !pattern.test(instance.getValue())) {
    							report.addError(instance, schema, "pattern", "String does not match pattern", pattern.toString());
    						}
    					} catch (e) {
    						report.addError(instance, schema, "pattern", "Invalid pattern", e);
    					}
    				}
    			},
    			
    			"minLength" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				"default" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    					//else
    					return 0;
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minLength;
    					if (instance.getType() === "string") {
    						minLength = schema.getAttribute("minLength");
    						if (typeof minLength === "number" && instance.getValue().length < minLength) {
    							report.addError(instance, schema, "minLength", "String is less than the required minimum length", minLength);
    						}
    					}
    				}
    			},
    			
    			"maxLength" : {
    				"type" : "integer",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxLength;
    					if (instance.getType() === "string") {
    						maxLength = schema.getAttribute("maxLength");
    						if (typeof maxLength === "number" && instance.getValue().length > maxLength) {
    							report.addError(instance, schema, "maxLength", "String is greater than the required maximum length", maxLength);
    						}
    					}
    				}
    			},
    			
    			"enum" : {
    				"type" : "array",
    				"optional" : true,
    				"minItems" : 1,
    				"uniqueItems" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "array") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var enums, x, xl;
    					if (instance.getType() !== "undefined") {
    						enums = schema.getAttribute("enum");
    						if (enums) {
    							for (x = 0, xl = enums.length; x < xl; ++x) {
    								if (instance.equals(enums[x])) {
    									return true;
    								}
    							}
    							report.addError(instance, schema, "enum", "Instance is not one of the possible values", enums);
    						}
    					}
    				}
    			},
    			
    			"title" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"description" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"format" : {
    				"type" : "string",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var format, formatValidators;
    					if (instance.getType() === "string") {
    						format = schema.getAttribute("format");
    						formatValidators = self.getValueOfProperty("formatValidators");
    						if (typeof format === "string" && formatValidators[format] !== O[format] && typeof formatValidators[format] === "function" && !formatValidators[format].call(this, instance, report)) {
    							report.addError(instance, schema, "format", "String is not in the required format", format);
    						}
    					}
    				},
    				
    				"formatValidators" : {}
    			},
    			
    			"contentEncoding" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"default" : {
    				"type" : "any",
    				"optional" : true
    			},
    			
    			"maxDecimal" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    								
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxDecimal, decimals;
    					if (instance.getType() === "number") {
    						maxDecimal = schema.getAttribute("maxDecimal");
    						if (typeof maxDecimal === "number") {
    							decimals = instance.getValue().toString(10).split('.')[1];
    							if (decimals && decimals.length > maxDecimal) {
    								report.addError(instance, schema, "maxDecimal", "The number of decimal places is greater than the allowed maximum", maxDecimal);
    							}
    						}
    					}
    				}
    			},
    			
    			"disallow" : {
    				"type" : ["string", "array"],
    				"items" : {"type" : "string"},
    				"optional" : true,
    				"uniqueItems" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string" || instance.getType() === "array") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var disallowedTypes = JSV.toArray(schema.getAttribute("disallow")),
    						x, xl, key, typeValidators;
    					
    					//for instances that are required to be a certain type
    					if (instance.getType() !== "undefined" && disallowedTypes && disallowedTypes.length) {
    						typeValidators = self.getValueOfProperty("typeValidators") || {};
    						
    						//ensure that type matches for at least one of the required types
    						for (x = 0, xl = disallowedTypes.length; x < xl; ++x) {
    							key = disallowedTypes[x];
    							if (typeValidators[key] !== O[key] && typeof typeValidators[key] === "function") {
    								if (typeValidators[key](instance, report)) {
    									report.addError(instance, schema, "disallow", "Instance is a disallowed type", disallowedTypes);
    									return false;
    								}
    							} 
    							/*
    							else {
    								report.addError(instance, schema, "disallow", "Instance may be a disallowed type", disallowedTypes);
    								return false;
    							}
    							*/
    						}
    						
    						//if we get to this point, type is valid
    						return true;
    					}
    					//else, everything is allowed if no disallowed types are specified
    					return true;
    				},
    				
    				"typeValidators" : TYPE_VALIDATORS
    			},
    		
    			"extends" : {
    				"type" : [{"$ref" : "#"}, "array"],
    				"items" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "array") {
    						return JSV.mapArray(instance.getProperties(), function (instance) {
    							return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    						});
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var extensions = schema.getAttribute("extends"), x, xl;
    					if (extensions) {
    						if (JSV.isJSONSchema(extensions)) {
    							extensions.validate(instance, report, parent, parentSchema, name);
    						} else if (JSV.typeOf(extensions) === "array") {
    							for (x = 0, xl = extensions.length; x < xl; ++x) {
    								extensions[x].validate(instance, report, parent, parentSchema, name);
    							}
    						}
    					}
    				}
    			}
    		},
    		
    		"optional" : true,
    		"default" : {},
    		"fragmentResolution" : "dot-delimited",
    		
    		"parser" : function (instance, self) {
    			if (instance.getType() === "object") {
    				return instance.getEnvironment().createSchema(instance, self);
    			}
    		},
    		
    		"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    			var propNames = schema.getPropertyNames(), 
    				x, xl,
    				attributeSchemas = self.getAttribute("properties"),
    				validator;
    			
    			for (x in attributeSchemas) {
    				if (attributeSchemas[x] !== O[x] && attributeSchemas[x].getValueOfProperty("validationRequired")) {
    					JSV.pushUnique(propNames, x);
    				}
    			}
    			
    			for (x = 0, xl = propNames.length; x < xl; ++x) {
    				if (attributeSchemas[propNames[x]] !== O[propNames[x]]) {
    					validator = attributeSchemas[propNames[x]].getValueOfProperty("validator");
    					if (typeof validator === "function") {
    						validator(instance, schema, attributeSchemas[propNames[x]], report, parent, parentSchema, name);
    					}
    				}
    			}
    		},
    				
    		"initializer" : function (instance) {
    			var link, extension, extended;
    			
    			//if there is a link to a different schema, set reference
    			link = instance._schema.getLink("describedby", instance);
    			if (link && instance._schema._uri !== link) {
    				instance.setReference("describedby", link);
    			}
    			
    			//if instance has a URI link to itself, update it's own URI
    			link = instance._schema.getLink("self", instance);
    			if (JSV.typeOf(link) === "string") {
    				instance._uri = JSV.formatURI(link);
    			}
    			
    			//if there is a link to the full representation, set reference
    			link = instance._schema.getLink("full", instance);
    			if (link && instance._uri !== link) {
    				instance.setReference("full", link);
    			}
    			
    			//extend schema
    			extension = instance.getAttribute("extends");
    			if (JSV.isJSONSchema(extension)) {
    				extended = JSV.inherits(extension, instance, true);
    				instance = instance._env.createSchema(extended, instance._schema, instance._uri);
    			}
    			
    			return instance;
    		}
    	}, true, "http://json-schema.org/schema#");
    	
    	HYPERSCHEMA = ENVIRONMENT.createSchema(JSV.inherits(SCHEMA, ENVIRONMENT.createSchema({
    		"$schema" : "http://json-schema.org/hyper-schema#",
    		"id" : "http://json-schema.org/hyper-schema#",
    	
    		"properties" : {
    			"links" : {
    				"type" : "array",
    				"items" : {"$ref" : "links#"},
    				"optional" : true,
    				
    				"parser" : function (instance, self, arg) {
    					var links,
    						linkSchemaURI = self.getValueOfProperty("items")["$ref"],
    						linkSchema = self.getEnvironment().findSchema(linkSchemaURI),
    						linkParser = linkSchema && linkSchema.getValueOfProperty("parser");
    					arg = JSV.toArray(arg);
    					
    					if (typeof linkParser === "function") {
    						links = JSV.mapArray(instance.getProperties(), function (link) {
    							return linkParser(link, linkSchema);
    						});
    					} else {
    						links = JSV.toArray(instance.getValue());
    					}
    					
    					if (arg[0]) {
    						links = JSV.filterArray(links, function (link) {
    							return link["rel"] === arg[0];
    						});
    					}
    					
    					if (arg[1]) {
    						links = JSV.mapArray(links, function (link) {
    							var instance = arg[1],
    								href = link["href"];
    							href = href.replace(/\{(.+)\}/g, function (str, p1, offset, s) {
    								var value; 
    								if (p1 === "-this") {
    									value = instance.getValue();
    								} else {
    									value = instance.getValueOfProperty(p1);
    								}
    								return value !== undefined ? String(value) : "";
    							});
    							return href ? JSV.formatURI(instance.resolveURI(href)) : href;
    						});
    					}
    					
    					return links;
    				}
    			},
    			
    			"fragmentResolution" : {
    				"type" : "string",
    				"optional" : true,
    				"default" : "dot-delimited"
    			},
    			
    			"root" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false
    			},
    			
    			"readonly" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false
    			},
    			
    			"pathStart" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "uri",
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var pathStart;
    					if (instance.getType() !== "undefined") {
    						pathStart = schema.getAttribute("pathStart");
    						if (typeof pathStart === "string") {
    							//TODO: Find out what pathStart is relative to
    							if (instance.getURI().indexOf(pathStart) !== 0) {
    								report.addError(instance, schema, "pathStart", "Instance's URI does not start with " + pathStart, pathStart);
    							}
    						}
    					}
    				}
    			},
    			
    			"mediaType" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "media-type"
    			},
    			
    			"alternate" : {
    				"type" : "array",
    				"items" : {"$ref" : "#"},
    				"optional" : true
    			}
    		},
    		
    		"links" : [
    			{
    				"href" : "{$ref}",
    				"rel" : "full"
    			},
    			
    			{
    				"href" : "{$schema}",
    				"rel" : "describedby"
    			},
    			
    			{
    				"href" : "{id}",
    				"rel" : "self"
    			}
    		]//,
    		
    		//not needed as JSV.inherits does the job for us
    		//"extends" : {"$ref" : "http://json-schema.org/schema#"}
    	}, SCHEMA), true), true, "http://json-schema.org/hyper-schema#");
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/hyper-schema#");
    	
    	LINKS = ENVIRONMENT.createSchema({
    		"$schema" : "http://json-schema.org/hyper-schema#",
    		"id" : "http://json-schema.org/links#",
    		"type" : "object",
    		
    		"properties" : {
    			"href" : {
    				"type" : "string"
    			},
    			
    			"rel" : {
    				"type" : "string"
    			},
    			
    			"method" : {
    				"type" : "string",
    				"default" : "GET",
    				"optional" : true
    			},
    			
    			"enctype" : {
    				"type" : "string",
    				"requires" : "method",
    				"optional" : true
    			},
    			
    			"properties" : {
    				"type" : "object",
    				"additionalProperties" : {"$ref" : "hyper-schema#"},
    				"optional" : true,
    				
    				"parser" : function (instance, self, arg) {
    					var env = instance.getEnvironment(),
    						selfEnv = self.getEnvironment(),
    						additionalPropertiesSchemaURI = self.getValueOfProperty("additionalProperties")["$ref"];
    					if (instance.getType() === "object") {
    						if (arg) {
    							return env.createSchema(instance.getProperty(arg), selfEnv.findSchema(self.resolveURI(additionalPropertiesSchemaURI)));
    						} else {
    							return JSV.mapObject(instance.getProperties(), function (instance) {
    								return env.createSchema(instance, selfEnv.findSchema(self.resolveURI(additionalPropertiesSchemaURI)));
    							});
    						}
    					}
    				}
    			}
    		},
    		
    		"parser" : function (instance, self) {
    			var selfProperties = self.getProperty("properties");
    			if (instance.getType() === "object") {
    				return JSV.mapObject(instance.getProperties(), function (property, key) {
    					var propertySchema = selfProperties.getProperty(key),
    						parser = propertySchema && propertySchema.getValueOfProperty("parser");
    					if (typeof parser === "function") {
    						return parser(property, propertySchema);
    					}
    					//else
    					return property.getValue();
    				});
    			}
    			return instance.getValue();
    		}
    	}, HYPERSCHEMA, "http://json-schema.org/links#");
    	
    	JSV.registerEnvironment("json-schema-draft-00", ENVIRONMENT);
    	JSV.registerEnvironment("json-schema-draft-01", JSV.createEnvironment("json-schema-draft-00"));
    	
    	if (!JSV.getDefaultEnvironmentID()) {
    		JSV.setDefaultEnvironmentID("json-schema-draft-01");
    	}
    	
    }());
  provide("JSV/lib/json-schema-draft-01", module.exports);
}(global));

// pakmanager:JSV/lib/json-schema-draft-02
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * json-schema-draft-02 Environment
     * 
     * @fileOverview Implementation of the second revision of the JSON Schema specification draft.
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @version 1.7.1
     * @see http://github.com/garycourt/JSV
     */
    
    /*
     * Copyright 2010 Gary Court. All rights reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification, are
     * permitted provided that the following conditions are met:
     * 
     *    1. Redistributions of source code must retain the above copyright notice, this list of
     *       conditions and the following disclaimer.
     * 
     *    2. Redistributions in binary form must reproduce the above copyright notice, this list
     *       of conditions and the following disclaimer in the documentation and/or other materials
     *       provided with the distribution.
     * 
     * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * The views and conclusions contained in the software and documentation are those of the
     * authors and should not be interpreted as representing official policies, either expressed
     * or implied, of Gary Court or the JSON Schema specification.
     */
    
    /*jslint white: true, sub: true, onevar: true, undef: true, eqeqeq: true, newcap: true, immed: true, indent: 4 */
    /*global require */
    
    (function () {
    	var O = {},
    		JSV =  require('JSV/lib/jsv').JSV,
    		ENVIRONMENT,
    		TYPE_VALIDATORS,
    		SCHEMA,
    		HYPERSCHEMA,
    		LINKS;
    	
    	TYPE_VALIDATORS = {
    		"string" : function (instance, report) {
    			return instance.getType() === "string";
    		},
    		
    		"number" : function (instance, report) {
    			return instance.getType() === "number";
    		},
    		
    		"integer" : function (instance, report) {
    			return instance.getType() === "number" && instance.getValue() % 1 === 0;
    		},
    		
    		"boolean" : function (instance, report) {
    			return instance.getType() === "boolean";
    		},
    		
    		"object" : function (instance, report) {
    			return instance.getType() === "object";
    		},
    		
    		"array" : function (instance, report) {
    			return instance.getType() === "array";
    		},
    		
    		"null" : function (instance, report) {
    			return instance.getType() === "null";
    		},
    		
    		"any" : function (instance, report) {
    			return true;
    		}
    	};
    	
    	ENVIRONMENT = new JSV.Environment();
    	ENVIRONMENT.setOption("defaultFragmentDelimiter", "/");
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/schema#");  //updated later
    	
    	SCHEMA = ENVIRONMENT.createSchema({
    		"$schema" : "http://json-schema.org/hyper-schema#",
    		"id" : "http://json-schema.org/schema#",
    		"type" : "object",
    		
    		"properties" : {
    			"type" : {
    				"type" : ["string", "array"],
    				"items" : {
    					"type" : ["string", {"$ref" : "#"}]
    				},
    				"optional" : true,
    				"uniqueItems" : true,
    				"default" : "any",
    				
    				"parser" : function (instance, self) {
    					var parser;
    					
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					} else if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(
    							instance, 
    							self.getEnvironment().findSchema(self.resolveURI("#"))
    						);
    					} else if (instance.getType() === "array") {
    						parser = self.getValueOfProperty("parser");
    						return JSV.mapArray(instance.getProperties(), function (prop) {
    							return parser(prop, self);
    						});
    					}
    					//else
    					return "any";
    				},
    			
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var requiredTypes = JSV.toArray(schema.getAttribute("type")),
    						x, xl, type, subreport, typeValidators;
    					
    					//for instances that are required to be a certain type
    					if (instance.getType() !== "undefined" && requiredTypes && requiredTypes.length) {
    						typeValidators = self.getValueOfProperty("typeValidators") || {};
    						
    						//ensure that type matches for at least one of the required types
    						for (x = 0, xl = requiredTypes.length; x < xl; ++x) {
    							type = requiredTypes[x];
    							if (JSV.isJSONSchema(type)) {
    								subreport = JSV.createObject(report);
    								subreport.errors = [];
    								subreport.validated = JSV.clone(report.validated);
    								if (type.validate(instance, subreport, parent, parentSchema, name).errors.length === 0) {
    									return true;  //instance matches this schema
    								}
    							} else {
    								if (typeValidators[type] !== O[type] && typeof typeValidators[type] === "function") {
    									if (typeValidators[type](instance, report)) {
    										return true;  //type is valid
    									}
    								} else {
    									return true;  //unknown types are assumed valid
    								}
    							}
    						}
    						
    						//if we get to this point, type is invalid
    						report.addError(instance, schema, "type", "Instance is not a required type", requiredTypes);
    						return false;
    					}
    					//else, anything is allowed if no type is specified
    					return true;
    				},
    				
    				"typeValidators" : TYPE_VALIDATORS
    			},
    			
    			"properties" : {
    				"type" : "object",
    				"additionalProperties" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self, arg) {
    					var env = instance.getEnvironment(),
    						selfEnv = self.getEnvironment();
    					if (instance.getType() === "object") {
    						if (arg) {
    							return env.createSchema(instance.getProperty(arg), selfEnv.findSchema(self.resolveURI("#")));
    						} else {
    							return JSV.mapObject(instance.getProperties(), function (instance) {
    								return env.createSchema(instance, selfEnv.findSchema(self.resolveURI("#")));
    							});
    						}
    					}
    					//else
    					return {};
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var propertySchemas, key;
    					//this attribute is for object type instances only
    					if (instance.getType() === "object") {
    						//for each property defined in the schema
    						propertySchemas = schema.getAttribute("properties");
    						for (key in propertySchemas) {
    							if (propertySchemas[key] !== O[key] && propertySchemas[key]) {
    								//ensure that instance property is valid
    								propertySchemas[key].validate(instance.getProperty(key), report, instance, schema, key);
    							}
    						}
    					}
    				}
    			},
    			
    			"items" : {
    				"type" : [{"$ref" : "#"}, "array"],
    				"items" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "array") {
    						return JSV.mapArray(instance.getProperties(), function (instance) {
    							return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    						});
    					}
    					//else
    					return instance.getEnvironment().createEmptySchema();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var properties, items, x, xl, itemSchema, additionalProperties;
    					
    					if (instance.getType() === "array") {
    						properties = instance.getProperties();
    						items = schema.getAttribute("items");
    						additionalProperties = schema.getAttribute("additionalProperties");
    						
    						if (JSV.typeOf(items) === "array") {
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema = items[x] || additionalProperties;
    								if (itemSchema !== false) {
    									itemSchema.validate(properties[x], report, instance, schema, x);
    								} else {
    									report.addError(instance, schema, "additionalProperties", "Additional items are not allowed", itemSchema);
    								}
    							}
    						} else {
    							itemSchema = items || additionalProperties;
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema.validate(properties[x], report, instance, schema, x);
    							}
    						}
    					}
    				}
    			},
    			
    			"optional" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					if (instance.getType() === "undefined" && !schema.getAttribute("optional")) {
    						report.addError(instance, schema, "optional", "Property is required", false);
    					}
    				},
    				
    				"validationRequired" : true
    			},
    			
    			"additionalProperties" : {
    				"type" : [{"$ref" : "#"}, "boolean"],
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "boolean" && instance.getValue() === false) {
    						return false;
    					}
    					//else
    					return instance.getEnvironment().createEmptySchema();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var additionalProperties, propertySchemas, properties, key;
    					//we only need to check against object types as arrays do their own checking on this property
    					if (instance.getType() === "object") {
    						additionalProperties = schema.getAttribute("additionalProperties");
    						propertySchemas = schema.getAttribute("properties") || {};
    						properties = instance.getProperties();
    						for (key in properties) {
    							if (properties[key] !== O[key] && properties[key] && !propertySchemas[key]) {
    								if (JSV.isJSONSchema(additionalProperties)) {
    									additionalProperties.validate(properties[key], report, instance, schema, key);
    								} else if (additionalProperties === false) {
    									report.addError(instance, schema, "additionalProperties", "Additional properties are not allowed", additionalProperties);
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"requires" : {
    				"type" : ["string", {"$ref" : "#"}],
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					} else if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var requires;
    					if (instance.getType() !== "undefined" && parent && parent.getType() !== "undefined") {
    						requires = schema.getAttribute("requires");
    						if (typeof requires === "string") {
    							if (parent.getProperty(requires).getType() === "undefined") {
    								report.addError(instance, schema, "requires", 'Property requires sibling property "' + requires + '"', requires);
    							}
    						} else if (JSV.isJSONSchema(requires)) {
    							requires.validate(parent, report);  //WATCH: A "requires" schema does not support the "requires" attribute
    						}
    					}
    				}
    			},
    			
    			"minimum" : {
    				"type" : "number",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minimum, minimumCanEqual;
    					if (instance.getType() === "number") {
    						minimum = schema.getAttribute("minimum");
    						minimumCanEqual = schema.getAttribute("minimumCanEqual");
    						if (typeof minimum === "number" && (instance.getValue() < minimum || (minimumCanEqual === false && instance.getValue() === minimum))) {
    							report.addError(instance, schema, "minimum", "Number is less than the required minimum value", minimum);
    						}
    					}
    				}
    			},
    			
    			"maximum" : {
    				"type" : "number",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maximum, maximumCanEqual;
    					if (instance.getType() === "number") {
    						maximum = schema.getAttribute("maximum");
    						maximumCanEqual = schema.getAttribute("maximumCanEqual");
    						if (typeof maximum === "number" && (instance.getValue() > maximum || (maximumCanEqual === false && instance.getValue() === maximum))) {
    							report.addError(instance, schema, "maximum", "Number is greater than the required maximum value", maximum);
    						}
    					}
    				}
    			},
    			
    			"minimumCanEqual" : {
    				"type" : "boolean",
    				"optional" : true,
    				"requires" : "minimum",
    				"default" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "boolean") {
    						return instance.getValue();
    					}
    					//else
    					return true;
    				}
    			},
    			
    			"maximumCanEqual" : {
    				"type" : "boolean",
    				"optional" : true,
    				"requires" : "maximum",
    				"default" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "boolean") {
    						return instance.getValue();
    					}
    					//else
    					return true;
    				}
    			},
    			
    			"minItems" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				"default" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    					//else
    					return 0;
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minItems;
    					if (instance.getType() === "array") {
    						minItems = schema.getAttribute("minItems");
    						if (typeof minItems === "number" && instance.getProperties().length < minItems) {
    							report.addError(instance, schema, "minItems", "The number of items is less than the required minimum", minItems);
    						}
    					}
    				}
    			},
    			
    			"maxItems" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxItems;
    					if (instance.getType() === "array") {
    						maxItems = schema.getAttribute("maxItems");
    						if (typeof maxItems === "number" && instance.getProperties().length > maxItems) {
    							report.addError(instance, schema, "maxItems", "The number of items is greater than the required maximum", maxItems);
    						}
    					}
    				}
    			},
    			
    			"uniqueItems" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var value, x, xl, y, yl;
    					if (instance.getType() === "array" && schema.getAttribute("uniqueItems")) {
    						value = instance.getProperties();
    						for (x = 0, xl = value.length - 1; x < xl; ++x) {
    							for (y = x + 1, yl = value.length; y < yl; ++y) {
    								if (value[x].equals(value[y])) {
    									report.addError(instance, schema, "uniqueItems", "Array can only contain unique items", { x : x, y : y });
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"pattern" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "regex",
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var pattern;
    					try {
    						pattern = new RegExp(schema.getAttribute("pattern"));
    						if (instance.getType() === "string" && pattern && !pattern.test(instance.getValue())) {
    							report.addError(instance, schema, "pattern", "String does not match pattern", pattern.toString());
    						}
    					} catch (e) {
    						report.addError(instance, schema, "pattern", "Invalid pattern", e);
    					}
    				}
    			},
    			
    			"minLength" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				"default" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    					//else
    					return 0;
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minLength;
    					if (instance.getType() === "string") {
    						minLength = schema.getAttribute("minLength");
    						if (typeof minLength === "number" && instance.getValue().length < minLength) {
    							report.addError(instance, schema, "minLength", "String is less than the required minimum length", minLength);
    						}
    					}
    				}
    			},
    			
    			"maxLength" : {
    				"type" : "integer",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxLength;
    					if (instance.getType() === "string") {
    						maxLength = schema.getAttribute("maxLength");
    						if (typeof maxLength === "number" && instance.getValue().length > maxLength) {
    							report.addError(instance, schema, "maxLength", "String is greater than the required maximum length", maxLength);
    						}
    					}
    				}
    			},
    			
    			"enum" : {
    				"type" : "array",
    				"optional" : true,
    				"minItems" : 1,
    				"uniqueItems" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "array") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var enums, x, xl;
    					if (instance.getType() !== "undefined") {
    						enums = schema.getAttribute("enum");
    						if (enums) {
    							for (x = 0, xl = enums.length; x < xl; ++x) {
    								if (instance.equals(enums[x])) {
    									return true;
    								}
    							}
    							report.addError(instance, schema, "enum", "Instance is not one of the possible values", enums);
    						}
    					}
    				}
    			},
    			
    			"title" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"description" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"format" : {
    				"type" : "string",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var format, formatValidators;
    					if (instance.getType() === "string") {
    						format = schema.getAttribute("format");
    						formatValidators = self.getValueOfProperty("formatValidators");
    						if (typeof format === "string" && formatValidators[format] !== O[format] && typeof formatValidators[format] === "function" && !formatValidators[format].call(this, instance, report)) {
    							report.addError(instance, schema, "format", "String is not in the required format", format);
    						}
    					}
    				},
    				
    				"formatValidators" : {}
    			},
    			
    			"contentEncoding" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"default" : {
    				"type" : "any",
    				"optional" : true
    			},
    			
    			"divisibleBy" : {
    				"type" : "number",
    				"minimum" : 0,
    				"minimumCanEqual" : false,
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var divisor;
    					if (instance.getType() === "number") {
    						divisor = schema.getAttribute("divisibleBy");
    						if (divisor === 0) {
    							report.addError(instance, schema, "divisibleBy", "Nothing is divisible by 0", divisor);
    						} else if (divisor !== 1 && ((instance.getValue() / divisor) % 1) !== 0) {
    							report.addError(instance, schema, "divisibleBy", "Number is not divisible by " + divisor, divisor);
    						}
    					}
    				}
    			},
    			
    			"disallow" : {
    				"type" : ["string", "array"],
    				"items" : {"type" : "string"},
    				"optional" : true,
    				"uniqueItems" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string" || instance.getType() === "array") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var disallowedTypes = JSV.toArray(schema.getAttribute("disallow")),
    						x, xl, key, typeValidators;
    					
    					//for instances that are required to be a certain type
    					if (instance.getType() !== "undefined" && disallowedTypes && disallowedTypes.length) {
    						typeValidators = self.getValueOfProperty("typeValidators") || {};
    						
    						//ensure that type matches for at least one of the required types
    						for (x = 0, xl = disallowedTypes.length; x < xl; ++x) {
    							key = disallowedTypes[x];
    							if (typeValidators[key] !== O[key] && typeof typeValidators[key] === "function") {
    								if (typeValidators[key](instance, report)) {
    									report.addError(instance, schema, "disallow", "Instance is a disallowed type", disallowedTypes);
    									return false;
    								}
    							} 
    							/*
    							else {
    								report.addError(instance, schema, "disallow", "Instance may be a disallowed type", disallowedTypes);
    								return false;
    							}
    							*/
    						}
    						
    						//if we get to this point, type is valid
    						return true;
    					}
    					//else, everything is allowed if no disallowed types are specified
    					return true;
    				},
    				
    				"typeValidators" : TYPE_VALIDATORS
    			},
    		
    			"extends" : {
    				"type" : [{"$ref" : "#"}, "array"],
    				"items" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "array") {
    						return JSV.mapArray(instance.getProperties(), function (instance) {
    							return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    						});
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var extensions = schema.getAttribute("extends"), x, xl;
    					if (extensions) {
    						if (JSV.isJSONSchema(extensions)) {
    							extensions.validate(instance, report, parent, parentSchema, name);
    						} else if (JSV.typeOf(extensions) === "array") {
    							for (x = 0, xl = extensions.length; x < xl; ++x) {
    								extensions[x].validate(instance, report, parent, parentSchema, name);
    							}
    						}
    					}
    				}
    			}
    		},
    		
    		"optional" : true,
    		"default" : {},
    		"fragmentResolution" : "slash-delimited",
    		
    		"parser" : function (instance, self) {
    			if (instance.getType() === "object") {
    				return instance.getEnvironment().createSchema(instance, self);
    			}
    		},
    		
    		"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    			var propNames = schema.getPropertyNames(), 
    				x, xl,
    				attributeSchemas = self.getAttribute("properties"),
    				validator;
    			
    			for (x in attributeSchemas) {
    				if (attributeSchemas[x] !== O[x] && attributeSchemas[x].getValueOfProperty("validationRequired")) {
    					JSV.pushUnique(propNames, x);
    				}
    			}
    			
    			for (x = 0, xl = propNames.length; x < xl; ++x) {
    				if (attributeSchemas[propNames[x]] !== O[propNames[x]]) {
    					validator = attributeSchemas[propNames[x]].getValueOfProperty("validator");
    					if (typeof validator === "function") {
    						validator(instance, schema, attributeSchemas[propNames[x]], report, parent, parentSchema, name);
    					}
    				}
    			}
    		},
    				
    		"initializer" : function (instance) {
    			var link, extension, extended;
    			
    			//if there is a link to a different schema, set reference
    			link = instance._schema.getLink("describedby", instance);
    			if (link && instance._schema._uri !== link) {
    				instance.setReference("describedby", link);
    			}
    			
    			//if instance has a URI link to itself, update it's own URI
    			link = instance._schema.getLink("self", instance);
    			if (JSV.typeOf(link) === "string") {
    				instance._uri = JSV.formatURI(link);
    			}
    			
    			//if there is a link to the full representation, set reference
    			link = instance._schema.getLink("full", instance);
    			if (link && instance._uri !== link) {
    				instance.setReference("full", link);
    			}
    			
    			//extend schema
    			extension = instance.getAttribute("extends");
    			if (JSV.isJSONSchema(extension)) {
    				extended = JSV.inherits(extension, instance, true);
    				instance = instance._env.createSchema(extended, instance._schema, instance._uri);
    			}
    			
    			return instance;
    		}
    	}, true, "http://json-schema.org/schema#");
    	
    	HYPERSCHEMA = ENVIRONMENT.createSchema(JSV.inherits(SCHEMA, ENVIRONMENT.createSchema({
    		"$schema" : "http://json-schema.org/hyper-schema#",
    		"id" : "http://json-schema.org/hyper-schema#",
    	
    		"properties" : {
    			"links" : {
    				"type" : "array",
    				"items" : {"$ref" : "links#"},
    				"optional" : true,
    				
    				"parser" : function (instance, self, arg) {
    					var links,
    						linkSchemaURI = self.getValueOfProperty("items")["$ref"],
    						linkSchema = self.getEnvironment().findSchema(linkSchemaURI),
    						linkParser = linkSchema && linkSchema.getValueOfProperty("parser");
    					arg = JSV.toArray(arg);
    					
    					if (typeof linkParser === "function") {
    						links = JSV.mapArray(instance.getProperties(), function (link) {
    							return linkParser(link, linkSchema);
    						});
    					} else {
    						links = JSV.toArray(instance.getValue());
    					}
    					
    					if (arg[0]) {
    						links = JSV.filterArray(links, function (link) {
    							return link["rel"] === arg[0];
    						});
    					}
    					
    					if (arg[1]) {
    						links = JSV.mapArray(links, function (link) {
    							var instance = arg[1],
    								href = link["href"];
    							href = href.replace(/\{(.+)\}/g, function (str, p1, offset, s) {
    								var value; 
    								if (p1 === "-this") {
    									value = instance.getValue();
    								} else {
    									value = instance.getValueOfProperty(p1);
    								}
    								return value !== undefined ? String(value) : "";
    							});
    							return href ? JSV.formatURI(instance.resolveURI(href)) : href;
    						});
    					}
    					
    					return links;
    				}
    			},
    			
    			"fragmentResolution" : {
    				"type" : "string",
    				"optional" : true,
    				"default" : "slash-delimited"
    			},
    			
    			"root" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false
    			},
    			
    			"readonly" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false
    			},
    			
    			"pathStart" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "uri",
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var pathStart;
    					if (instance.getType() !== "undefined") {
    						pathStart = schema.getAttribute("pathStart");
    						if (typeof pathStart === "string") {
    							//TODO: Find out what pathStart is relative to
    							if (instance.getURI().indexOf(pathStart) !== 0) {
    								report.addError(instance, schema, "pathStart", "Instance's URI does not start with " + pathStart, pathStart);
    							}
    						}
    					}
    				}
    			},
    			
    			"mediaType" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "media-type"
    			},
    			
    			"alternate" : {
    				"type" : "array",
    				"items" : {"$ref" : "#"},
    				"optional" : true
    			}
    		},
    		
    		"links" : [
    			{
    				"href" : "{$ref}",
    				"rel" : "full"
    			},
    			
    			{
    				"href" : "{$schema}",
    				"rel" : "describedby"
    			},
    			
    			{
    				"href" : "{id}",
    				"rel" : "self"
    			}
    		]//,
    		
    		//not needed as JSV.inherits does the job for us
    		//"extends" : {"$ref" : "http://json-schema.org/schema#"}
    	}, SCHEMA), true), true, "http://json-schema.org/hyper-schema#");
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/hyper-schema#");
    	
    	LINKS = ENVIRONMENT.createSchema({
    		"$schema" : "http://json-schema.org/hyper-schema#",
    		"id" : "http://json-schema.org/links#",
    		"type" : "object",
    		
    		"properties" : {
    			"href" : {
    				"type" : "string"
    			},
    			
    			"rel" : {
    				"type" : "string"
    			},
    			
    			"targetSchema" : {
    				"$ref" : "hyper-schema#",
    				
    				//need this here because parsers are run before links are resolved
    				"parser" : HYPERSCHEMA.getAttribute("parser")
    			},
    			
    			"method" : {
    				"type" : "string",
    				"default" : "GET",
    				"optional" : true
    			},
    			
    			"enctype" : {
    				"type" : "string",
    				"requires" : "method",
    				"optional" : true
    			},
    			
    			"properties" : {
    				"type" : "object",
    				"additionalProperties" : {"$ref" : "hyper-schema#"},
    				"optional" : true,
    				
    				"parser" : function (instance, self, arg) {
    					var env = instance.getEnvironment(),
    						selfEnv = self.getEnvironment(),
    						additionalPropertiesSchemaURI = self.getValueOfProperty("additionalProperties")["$ref"];
    					if (instance.getType() === "object") {
    						if (arg) {
    							return env.createSchema(instance.getProperty(arg), selfEnv.findSchema(self.resolveURI(additionalPropertiesSchemaURI)));
    						} else {
    							return JSV.mapObject(instance.getProperties(), function (instance) {
    								return env.createSchema(instance, selfEnv.findSchema(self.resolveURI(additionalPropertiesSchemaURI)));
    							});
    						}
    					}
    				}
    			}
    		},
    		
    		"parser" : function (instance, self) {
    			var selfProperties = self.getProperty("properties");
    			if (instance.getType() === "object") {
    				return JSV.mapObject(instance.getProperties(), function (property, key) {
    					var propertySchema = selfProperties.getProperty(key),
    						parser = propertySchema && propertySchema.getValueOfProperty("parser");
    					if (typeof parser === "function") {
    						return parser(property, propertySchema);
    					}
    					//else
    					return property.getValue();
    				});
    			}
    			return instance.getValue();
    		}
    	}, HYPERSCHEMA, "http://json-schema.org/links#");
    	
    	JSV.registerEnvironment("json-schema-draft-02", ENVIRONMENT);
    	if (!JSV.getDefaultEnvironmentID() || JSV.getDefaultEnvironmentID() === "json-schema-draft-01") {
    		JSV.setDefaultEnvironmentID("json-schema-draft-02");
    	}
    	
    }());
  provide("JSV/lib/json-schema-draft-02", module.exports);
}(global));

// pakmanager:JSV/lib/json-schema-draft-03
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * json-schema-draft-03 Environment
     * 
     * @fileOverview Implementation of the third revision of the JSON Schema specification draft.
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @version 1.5.1
     * @see http://github.com/garycourt/JSV
     */
    
    /*
     * Copyright 2010 Gary Court. All rights reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification, are
     * permitted provided that the following conditions are met:
     * 
     *    1. Redistributions of source code must retain the above copyright notice, this list of
     *       conditions and the following disclaimer.
     * 
     *    2. Redistributions in binary form must reproduce the above copyright notice, this list
     *       of conditions and the following disclaimer in the documentation and/or other materials
     *       provided with the distribution.
     * 
     * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * The views and conclusions contained in the software and documentation are those of the
     * authors and should not be interpreted as representing official policies, either expressed
     * or implied, of Gary Court or the JSON Schema specification.
     */
    
    /*jslint white: true, sub: true, onevar: true, undef: true, eqeqeq: true, newcap: true, immed: true, indent: 4 */
    /*global require */
    
    (function () {
    	var O = {},
    		JSV =  require('JSV/lib/jsv').JSV,
    		TYPE_VALIDATORS,
    		ENVIRONMENT,
    		SCHEMA_00_JSON,
    		HYPERSCHEMA_00_JSON,
    		LINKS_00_JSON, 
    		SCHEMA_00,
    		HYPERSCHEMA_00,
    		LINKS_00, 
    		SCHEMA_01_JSON,
    		HYPERSCHEMA_01_JSON,
    		LINKS_01_JSON, 
    		SCHEMA_01,
    		HYPERSCHEMA_01,
    		LINKS_01, 
    		SCHEMA_02_JSON,
    		HYPERSCHEMA_02_JSON,
    		LINKS_02_JSON,
    		SCHEMA_02,
    		HYPERSCHEMA_02,
    		LINKS_02, 
    		SCHEMA_03_JSON,
    		HYPERSCHEMA_03_JSON,
    		LINKS_03_JSON,
    		SCHEMA_03,
    		HYPERSCHEMA_03,
    		LINKS_03;
    	
    	TYPE_VALIDATORS = {
    		"string" : function (instance, report) {
    			return instance.getType() === "string";
    		},
    		
    		"number" : function (instance, report) {
    			return instance.getType() === "number";
    		},
    		
    		"integer" : function (instance, report) {
    			return instance.getType() === "number" && instance.getValue() % 1 === 0;
    		},
    		
    		"boolean" : function (instance, report) {
    			return instance.getType() === "boolean";
    		},
    		
    		"object" : function (instance, report) {
    			return instance.getType() === "object";
    		},
    		
    		"array" : function (instance, report) {
    			return instance.getType() === "array";
    		},
    		
    		"null" : function (instance, report) {
    			return instance.getType() === "null";
    		},
    		
    		"any" : function (instance, report) {
    			return true;
    		}
    	};
    	
    	ENVIRONMENT = new JSV.Environment();
    	ENVIRONMENT.setOption("validateReferences", true);
    	ENVIRONMENT.setOption("enforceReferences", false);
    	ENVIRONMENT.setOption("strict", false);
    	
    	//
    	// draft-00
    	//
    	
    	SCHEMA_00_JSON = {
    		"$schema" : "http://json-schema.org/draft-00/hyper-schema#",
    		"id" : "http://json-schema.org/draft-00/schema#",
    		"type" : "object",
    		
    		"properties" : {
    			"type" : {
    				"type" : ["string", "array"],
    				"items" : {
    					"type" : ["string", {"$ref" : "#"}]
    				},
    				"optional" : true,
    				"uniqueItems" : true,
    				"default" : "any",
    				
    				"parser" : function (instance, self) {
    					var parser;
    					
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					} else if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(
    							instance, 
    							self.getEnvironment().findSchema(self.resolveURI("#"))
    						);
    					} else if (instance.getType() === "array") {
    						parser = self.getValueOfProperty("parser");
    						return JSV.mapArray(instance.getProperties(), function (prop) {
    							return parser(prop, self);
    						});
    					}
    					//else
    					return "any";
    				},
    			
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var requiredTypes = JSV.toArray(schema.getAttribute("type")),
    						x, xl, type, subreport, typeValidators;
    					
    					//for instances that are required to be a certain type
    					if (instance.getType() !== "undefined" && requiredTypes && requiredTypes.length) {
    						typeValidators = self.getValueOfProperty("typeValidators") || {};
    						
    						//ensure that type matches for at least one of the required types
    						for (x = 0, xl = requiredTypes.length; x < xl; ++x) {
    							type = requiredTypes[x];
    							if (JSV.isJSONSchema(type)) {
    								subreport = JSV.createObject(report);
    								subreport.errors = [];
    								subreport.validated = JSV.clone(report.validated);
    								if (type.validate(instance, subreport, parent, parentSchema, name).errors.length === 0) {
    									return true;  //instance matches this schema
    								}
    							} else {
    								if (typeValidators[type] !== O[type] && typeof typeValidators[type] === "function") {
    									if (typeValidators[type](instance, report)) {
    										return true;  //type is valid
    									}
    								} else {
    									return true;  //unknown types are assumed valid
    								}
    							}
    						}
    						
    						//if we get to this point, type is invalid
    						report.addError(instance, schema, "type", "Instance is not a required type", requiredTypes);
    						return false;
    					}
    					//else, anything is allowed if no type is specified
    					return true;
    				},
    				
    				"typeValidators" : TYPE_VALIDATORS
    			},
    			
    			"properties" : {
    				"type" : "object",
    				"additionalProperties" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self, arg) {
    					var env = instance.getEnvironment(),
    						selfEnv = self.getEnvironment();
    					if (instance.getType() === "object") {
    						if (arg) {
    							return env.createSchema(instance.getProperty(arg), selfEnv.findSchema(self.resolveURI("#")));
    						} else {
    							return JSV.mapObject(instance.getProperties(), function (instance) {
    								return env.createSchema(instance, selfEnv.findSchema(self.resolveURI("#")));
    							});
    						}
    					}
    					//else
    					return {};
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var propertySchemas, key;
    					//this attribute is for object type instances only
    					if (instance.getType() === "object") {
    						//for each property defined in the schema
    						propertySchemas = schema.getAttribute("properties");
    						for (key in propertySchemas) {
    							if (propertySchemas[key] !== O[key] && propertySchemas[key]) {
    								//ensure that instance property is valid
    								propertySchemas[key].validate(instance.getProperty(key), report, instance, schema, key);
    							}
    						}
    					}
    				}
    			},
    			
    			"items" : {
    				"type" : [{"$ref" : "#"}, "array"],
    				"items" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "array") {
    						return JSV.mapArray(instance.getProperties(), function (instance) {
    							return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    						});
    					}
    					//else
    					return instance.getEnvironment().createEmptySchema();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var properties, items, x, xl, itemSchema, additionalProperties;
    					
    					if (instance.getType() === "array") {
    						properties = instance.getProperties();
    						items = schema.getAttribute("items");
    						additionalProperties = schema.getAttribute("additionalProperties");
    						
    						if (JSV.typeOf(items) === "array") {
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema = items[x] || additionalProperties;
    								if (itemSchema !== false) {
    									itemSchema.validate(properties[x], report, instance, schema, x);
    								} else {
    									report.addError(instance, schema, "additionalProperties", "Additional items are not allowed", itemSchema);
    								}
    							}
    						} else {
    							itemSchema = items || additionalProperties;
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema.validate(properties[x], report, instance, schema, x);
    							}
    						}
    					}
    				}
    			},
    			
    			"optional" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					if (instance.getType() === "undefined" && !schema.getAttribute("optional")) {
    						report.addError(instance, schema, "optional", "Property is required", false);
    					}
    				},
    				
    				"validationRequired" : true
    			},
    			
    			"additionalProperties" : {
    				"type" : [{"$ref" : "#"}, "boolean"],
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "boolean" && instance.getValue() === false) {
    						return false;
    					}
    					//else
    					return instance.getEnvironment().createEmptySchema();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var additionalProperties, propertySchemas, properties, key;
    					//we only need to check against object types as arrays do their own checking on this property
    					if (instance.getType() === "object") {
    						additionalProperties = schema.getAttribute("additionalProperties");
    						propertySchemas = schema.getAttribute("properties") || {};
    						properties = instance.getProperties();
    						for (key in properties) {
    							if (properties[key] !== O[key] && properties[key] && propertySchemas[key] === O[key]) {
    								if (JSV.isJSONSchema(additionalProperties)) {
    									additionalProperties.validate(properties[key], report, instance, schema, key);
    								} else if (additionalProperties === false) {
    									report.addError(instance, schema, "additionalProperties", "Additional properties are not allowed", additionalProperties);
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"requires" : {
    				"type" : ["string", {"$ref" : "#"}],
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					} else if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var requires;
    					if (instance.getType() !== "undefined" && parent && parent.getType() !== "undefined") {
    						requires = schema.getAttribute("requires");
    						if (typeof requires === "string") {
    							if (parent.getProperty(requires).getType() === "undefined") {
    								report.addError(instance, schema, "requires", 'Property requires sibling property "' + requires + '"', requires);
    							}
    						} else if (JSV.isJSONSchema(requires)) {
    							requires.validate(parent, report);  //WATCH: A "requires" schema does not support the "requires" attribute
    						}
    					}
    				}
    			},
    			
    			"minimum" : {
    				"type" : "number",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minimum, minimumCanEqual;
    					if (instance.getType() === "number") {
    						minimum = schema.getAttribute("minimum");
    						minimumCanEqual = schema.getAttribute("minimumCanEqual");
    						if (typeof minimum === "number" && (instance.getValue() < minimum || (minimumCanEqual === false && instance.getValue() === minimum))) {
    							report.addError(instance, schema, "minimum", "Number is less than the required minimum value", minimum);
    						}
    					}
    				}
    			},
    			
    			"maximum" : {
    				"type" : "number",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maximum, maximumCanEqual;
    					if (instance.getType() === "number") {
    						maximum = schema.getAttribute("maximum");
    						maximumCanEqual = schema.getAttribute("maximumCanEqual");
    						if (typeof maximum === "number" && (instance.getValue() > maximum || (maximumCanEqual === false && instance.getValue() === maximum))) {
    							report.addError(instance, schema, "maximum", "Number is greater than the required maximum value", maximum);
    						}
    					}
    				}
    			},
    			
    			"minimumCanEqual" : {
    				"type" : "boolean",
    				"optional" : true,
    				"requires" : "minimum",
    				"default" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "boolean") {
    						return instance.getValue();
    					}
    					//else
    					return true;
    				}
    			},
    			
    			"maximumCanEqual" : {
    				"type" : "boolean",
    				"optional" : true,
    				"requires" : "maximum",
    				"default" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "boolean") {
    						return instance.getValue();
    					}
    					//else
    					return true;
    				}
    			},
    			
    			"minItems" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				"default" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    					//else
    					return 0;
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minItems;
    					if (instance.getType() === "array") {
    						minItems = schema.getAttribute("minItems");
    						if (typeof minItems === "number" && instance.getProperties().length < minItems) {
    							report.addError(instance, schema, "minItems", "The number of items is less than the required minimum", minItems);
    						}
    					}
    				}
    			},
    			
    			"maxItems" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxItems;
    					if (instance.getType() === "array") {
    						maxItems = schema.getAttribute("maxItems");
    						if (typeof maxItems === "number" && instance.getProperties().length > maxItems) {
    							report.addError(instance, schema, "maxItems", "The number of items is greater than the required maximum", maxItems);
    						}
    					}
    				}
    			},
    			
    			"pattern" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "regex",
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var pattern;
    					try {
    						pattern = new RegExp(schema.getAttribute("pattern"));
    						if (instance.getType() === "string" && pattern && !pattern.test(instance.getValue())) {
    							report.addError(instance, schema, "pattern", "String does not match pattern", pattern.toString());
    						}
    					} catch (e) {
    						report.addError(schema, self, "pattern", "Invalid pattern", schema.getValueOfProperty("pattern"));
    					}
    				}
    			},
    			
    			"minLength" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    				"default" : 0,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    					//else
    					return 0;
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minLength;
    					if (instance.getType() === "string") {
    						minLength = schema.getAttribute("minLength");
    						if (typeof minLength === "number" && instance.getValue().length < minLength) {
    							report.addError(instance, schema, "minLength", "String is less than the required minimum length", minLength);
    						}
    					}
    				}
    			},
    			
    			"maxLength" : {
    				"type" : "integer",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxLength;
    					if (instance.getType() === "string") {
    						maxLength = schema.getAttribute("maxLength");
    						if (typeof maxLength === "number" && instance.getValue().length > maxLength) {
    							report.addError(instance, schema, "maxLength", "String is greater than the required maximum length", maxLength);
    						}
    					}
    				}
    			},
    			
    			"enum" : {
    				"type" : "array",
    				"optional" : true,
    				"minItems" : 1,
    				"uniqueItems" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "array") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var enums, x, xl;
    					if (instance.getType() !== "undefined") {
    						enums = schema.getAttribute("enum");
    						if (enums) {
    							for (x = 0, xl = enums.length; x < xl; ++x) {
    								if (instance.equals(enums[x])) {
    									return true;
    								}
    							}
    							report.addError(instance, schema, "enum", "Instance is not one of the possible values", enums);
    						}
    					}
    				}
    			},
    			
    			"title" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"description" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"format" : {
    				"type" : "string",
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var format, formatValidators;
    					if (instance.getType() === "string") {
    						format = schema.getAttribute("format");
    						formatValidators = self.getValueOfProperty("formatValidators");
    						if (typeof format === "string" && formatValidators[format] !== O[format] && typeof formatValidators[format] === "function" && !formatValidators[format].call(this, instance, report)) {
    							report.addError(instance, schema, "format", "String is not in the required format", format);
    						}
    					}
    				},
    				
    				"formatValidators" : {}
    			},
    			
    			"contentEncoding" : {
    				"type" : "string",
    				"optional" : true
    			},
    			
    			"default" : {
    				"type" : "any",
    				"optional" : true
    			},
    			
    			"maxDecimal" : {
    				"type" : "integer",
    				"optional" : true,
    				"minimum" : 0,
    								
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maxDecimal, decimals;
    					if (instance.getType() === "number") {
    						maxDecimal = schema.getAttribute("maxDecimal");
    						if (typeof maxDecimal === "number") {
    							decimals = instance.getValue().toString(10).split('.')[1];
    							if (decimals && decimals.length > maxDecimal) {
    								report.addError(instance, schema, "maxDecimal", "The number of decimal places is greater than the allowed maximum", maxDecimal);
    							}
    						}
    					}
    				}
    			},
    			
    			"disallow" : {
    				"type" : ["string", "array"],
    				"items" : {"type" : "string"},
    				"optional" : true,
    				"uniqueItems" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "string" || instance.getType() === "array") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var disallowedTypes = JSV.toArray(schema.getAttribute("disallow")),
    						x, xl, key, typeValidators, subreport;
    					
    					//for instances that are required to be a certain type
    					if (instance.getType() !== "undefined" && disallowedTypes && disallowedTypes.length) {
    						typeValidators = self.getValueOfProperty("typeValidators") || {};
    						
    						//ensure that type matches for at least one of the required types
    						for (x = 0, xl = disallowedTypes.length; x < xl; ++x) {
    							key = disallowedTypes[x];
    							if (JSV.isJSONSchema(key)) {  //this is supported draft-03 and on
    								subreport = JSV.createObject(report);
    								subreport.errors = [];
    								subreport.validated = JSV.clone(report.validated);
    								if (key.validate(instance, subreport, parent, parentSchema, name).errors.length === 0) {
    									//instance matches this schema
    									report.addError(instance, schema, "disallow", "Instance is a disallowed type", disallowedTypes);
    									return false;  
    								}
    							} else if (typeValidators[key] !== O[key] && typeof typeValidators[key] === "function") {
    								if (typeValidators[key](instance, report)) {
    									report.addError(instance, schema, "disallow", "Instance is a disallowed type", disallowedTypes);
    									return false;
    								}
    							} 
    							/*
    							else {
    								report.addError(instance, schema, "disallow", "Instance may be a disallowed type", disallowedTypes);
    								return false;
    							}
    							*/
    						}
    						
    						//if we get to this point, type is valid
    						return true;
    					}
    					//else, everything is allowed if no disallowed types are specified
    					return true;
    				},
    				
    				"typeValidators" : TYPE_VALIDATORS
    			},
    		
    			"extends" : {
    				"type" : [{"$ref" : "#"}, "array"],
    				"items" : {"$ref" : "#"},
    				"optional" : true,
    				"default" : {},
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "object") {
    						return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    					} else if (instance.getType() === "array") {
    						return JSV.mapArray(instance.getProperties(), function (instance) {
    							return instance.getEnvironment().createSchema(instance, self.getEnvironment().findSchema(self.resolveURI("#")));
    						});
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var extensions = schema.getAttribute("extends"), x, xl;
    					if (extensions) {
    						if (JSV.isJSONSchema(extensions)) {
    							extensions.validate(instance, report, parent, parentSchema, name);
    						} else if (JSV.typeOf(extensions) === "array") {
    							for (x = 0, xl = extensions.length; x < xl; ++x) {
    								extensions[x].validate(instance, report, parent, parentSchema, name);
    							}
    						}
    					}
    				}
    			}
    		},
    		
    		"optional" : true,
    		"default" : {},
    		"fragmentResolution" : "dot-delimited",
    		
    		"parser" : function (instance, self) {
    			if (instance.getType() === "object") {
    				return instance.getEnvironment().createSchema(instance, self);
    			}
    		},
    		
    		"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    			var propNames = schema.getPropertyNames(), 
    				x, xl,
    				attributeSchemas = self.getAttribute("properties"),
    				strict = instance.getEnvironment().getOption("strict"),
    				validator;
    			
    			for (x in attributeSchemas) {
    				if (attributeSchemas[x] !== O[x]) {
    					if (attributeSchemas[x].getValueOfProperty("validationRequired")) {
    						JSV.pushUnique(propNames, x);
    					}
    					if (strict && attributeSchemas[x].getValueOfProperty("deprecated")) {
    						JSV.popFirst(propNames, x);
    					}
    				}
    			}
    			
    			for (x = 0, xl = propNames.length; x < xl; ++x) {
    				if (attributeSchemas[propNames[x]] !== O[propNames[x]]) {
    					validator = attributeSchemas[propNames[x]].getValueOfProperty("validator");
    					if (typeof validator === "function") {
    						validator(instance, schema, attributeSchemas[propNames[x]], report, parent, parentSchema, name);
    					}
    				}
    			}
    		}
    	};
    	
    	HYPERSCHEMA_00_JSON = {
    		"$schema" : "http://json-schema.org/draft-00/hyper-schema#",
    		"id" : "http://json-schema.org/draft-00/hyper-schema#",
    	
    		"properties" : {
    			"links" : {
    				"type" : "array",
    				"items" : {"$ref" : "links#"},
    				"optional" : true,
    				
    				"parser" : function (instance, self, arg) {
    					var links,
    						linkSchemaURI = self.getValueOfProperty("items")["$ref"],
    						linkSchema = self.getEnvironment().findSchema(linkSchemaURI),
    						linkParser = linkSchema && linkSchema.getValueOfProperty("parser"),
    						selfReferenceVariable;
    					arg = JSV.toArray(arg);
    					
    					if (typeof linkParser === "function") {
    						links = JSV.mapArray(instance.getProperties(), function (link) {
    							return linkParser(link, linkSchema);
    						});
    					} else {
    						links = JSV.toArray(instance.getValue());
    					}
    					
    					if (arg[0]) {
    						links = JSV.filterArray(links, function (link) {
    							return link["rel"] === arg[0];
    						});
    					}
    					
    					if (arg[1]) {
    						selfReferenceVariable = self.getValueOfProperty("selfReferenceVariable");
    						links = JSV.mapArray(links, function (link) {
    							var instance = arg[1],
    								href = link["href"];
    							href = href.replace(/\{(.+)\}/g, function (str, p1, offset, s) {
    								var value; 
    								if (p1 === selfReferenceVariable) {
    									value = instance.getValue();
    								} else {
    									value = instance.getValueOfProperty(p1);
    								}
    								return value !== undefined ? String(value) : "";
    							});
    							return href ? JSV.formatURI(instance.resolveURI(href)) : href;
    						});
    					}
    					
    					return links;
    				},
    				
    				"selfReferenceVariable" : "-this"
    			},
    			
    			"fragmentResolution" : {
    				"type" : "string",
    				"optional" : true,
    				"default" : "dot-delimited"
    			},
    			
    			"root" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false
    			},
    			
    			"readonly" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false
    			},
    			
    			"pathStart" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "uri",
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var pathStart;
    					if (instance.getType() !== "undefined") {
    						pathStart = schema.getAttribute("pathStart");
    						if (typeof pathStart === "string") {
    							//TODO: Find out what pathStart is relative to
    							if (instance.getURI().indexOf(pathStart) !== 0) {
    								report.addError(instance, schema, "pathStart", "Instance's URI does not start with " + pathStart, pathStart);
    							}
    						}
    					}
    				}
    			},
    			
    			"mediaType" : {
    				"type" : "string",
    				"optional" : true,
    				"format" : "media-type"
    			},
    			
    			"alternate" : {
    				"type" : "array",
    				"items" : {"$ref" : "#"},
    				"optional" : true
    			}
    		},
    		
    		"links" : [
    			{
    				"href" : "{$ref}",
    				"rel" : "full"
    			},
    			
    			{
    				"href" : "{$schema}",
    				"rel" : "describedby"
    			},
    			
    			{
    				"href" : "{id}",
    				"rel" : "self"
    			}
    		],
    				
    		"initializer" : function (instance) {
    			var link, extension, extended;
    			
    			//if there is a link to a different schema, set reference
    			link = instance._schema.getLink("describedby", instance);
    			if (link && instance._schema._uri !== link) {
    				instance.setReference("describedby", link);
    			}
    			
    			//if instance has a URI link to itself, update it's own URI
    			link = instance._schema.getLink("self", instance);
    			if (JSV.typeOf(link) === "string") {
    				instance._uri = JSV.formatURI(link);
    			}
    			
    			//if there is a link to the full representation, set reference
    			link = instance._schema.getLink("full", instance);
    			if (link && instance._uri !== link) {
    				instance.setReference("full", link);
    			}
    			
    			//extend schema
    			extension = instance.getAttribute("extends");
    			if (JSV.isJSONSchema(extension)) {
    				extended = JSV.inherits(extension, instance, true);
    				instance = instance._env.createSchema(extended, instance._schema, instance._uri);
    			}
    			
    			return instance;
    		}
    		
    		//not needed as JSV.inherits does the job for us
    		//"extends" : {"$ref" : "http://json-schema.org/schema#"}
    	};
    	
    	LINKS_00_JSON = {
    		"$schema" : "http://json-schema.org/draft-00/hyper-schema#",
    		"id" : "http://json-schema.org/draft-00/links#",
    		"type" : "object",
    		
    		"properties" : {
    			"href" : {
    				"type" : "string"
    			},
    			
    			"rel" : {
    				"type" : "string"
    			},
    			
    			"method" : {
    				"type" : "string",
    				"default" : "GET",
    				"optional" : true
    			},
    			
    			"enctype" : {
    				"type" : "string",
    				"requires" : "method",
    				"optional" : true
    			},
    			
    			"properties" : {
    				"type" : "object",
    				"additionalProperties" : {"$ref" : "hyper-schema#"},
    				"optional" : true,
    				
    				"parser" : function (instance, self, arg) {
    					var env = instance.getEnvironment(),
    						selfEnv = self.getEnvironment(),
    						additionalPropertiesSchemaURI = self.getValueOfProperty("additionalProperties")["$ref"];
    					if (instance.getType() === "object") {
    						if (arg) {
    							return env.createSchema(instance.getProperty(arg), selfEnv.findSchema(self.resolveURI(additionalPropertiesSchemaURI)));
    						} else {
    							return JSV.mapObject(instance.getProperties(), function (instance) {
    								return env.createSchema(instance, selfEnv.findSchema(self.resolveURI(additionalPropertiesSchemaURI)));
    							});
    						}
    					}
    				}
    			}
    		},
    		
    		"parser" : function (instance, self) {
    			var selfProperties = self.getProperty("properties");
    			if (instance.getType() === "object") {
    				return JSV.mapObject(instance.getProperties(), function (property, key) {
    					var propertySchema = selfProperties.getProperty(key),
    						parser = propertySchema && propertySchema.getValueOfProperty("parser");
    					if (typeof parser === "function") {
    						return parser(property, propertySchema);
    					}
    					//else
    					return property.getValue();
    				});
    			}
    			return instance.getValue();
    		}
    	};
    	
    	ENVIRONMENT.setOption("defaultFragmentDelimiter", ".");
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-00/schema#");  //updated later
    	
    	SCHEMA_00 = ENVIRONMENT.createSchema(SCHEMA_00_JSON, true, "http://json-schema.org/draft-00/schema#");
    	HYPERSCHEMA_00 = ENVIRONMENT.createSchema(JSV.inherits(SCHEMA_00, ENVIRONMENT.createSchema(HYPERSCHEMA_00_JSON, true, "http://json-schema.org/draft-00/hyper-schema#"), true), true, "http://json-schema.org/draft-00/hyper-schema#");
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-00/hyper-schema#");
    	
    	LINKS_00 = ENVIRONMENT.createSchema(LINKS_00_JSON, HYPERSCHEMA_00, "http://json-schema.org/draft-00/links#");
    	
    	//
    	// draft-01
    	//
    		
    	SCHEMA_01_JSON = JSV.inherits(SCHEMA_00_JSON, {
    		"$schema" : "http://json-schema.org/draft-01/hyper-schema#",
    		"id" : "http://json-schema.org/draft-01/schema#"
    	});
    	
    	HYPERSCHEMA_01_JSON = JSV.inherits(HYPERSCHEMA_00_JSON, {
    		"$schema" : "http://json-schema.org/draft-01/hyper-schema#",
    		"id" : "http://json-schema.org/draft-01/hyper-schema#"
    	});
    	
    	LINKS_01_JSON = JSV.inherits(LINKS_00_JSON, {
    		"$schema" : "http://json-schema.org/draft-01/hyper-schema#",
    		"id" : "http://json-schema.org/draft-01/links#"
    	});
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-01/schema#");  //update later
    	
    	SCHEMA_01 = ENVIRONMENT.createSchema(SCHEMA_01_JSON, true, "http://json-schema.org/draft-01/schema#");
    	HYPERSCHEMA_01 = ENVIRONMENT.createSchema(JSV.inherits(SCHEMA_01, ENVIRONMENT.createSchema(HYPERSCHEMA_01_JSON, true, "http://json-schema.org/draft-01/hyper-schema#"), true), true, "http://json-schema.org/draft-01/hyper-schema#");
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-01/hyper-schema#");
    	
    	LINKS_01 = ENVIRONMENT.createSchema(LINKS_01_JSON, HYPERSCHEMA_01, "http://json-schema.org/draft-01/links#");
    	
    	//
    	// draft-02
    	//
    	
    	SCHEMA_02_JSON = JSV.inherits(SCHEMA_01_JSON, {
    		"$schema" : "http://json-schema.org/draft-02/hyper-schema#",
    		"id" : "http://json-schema.org/draft-02/schema#",
    		
    		"properties" : {
    			"uniqueItems" : {
    				"type" : "boolean",
    				"optional" : true,
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var value, x, xl, y, yl;
    					if (instance.getType() === "array" && schema.getAttribute("uniqueItems")) {
    						value = instance.getProperties();
    						for (x = 0, xl = value.length - 1; x < xl; ++x) {
    							for (y = x + 1, yl = value.length; y < yl; ++y) {
    								if (value[x].equals(value[y])) {
    									report.addError(instance, schema, "uniqueItems", "Array can only contain unique items", { x : x, y : y });
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"maxDecimal" : {
    				"deprecated" : true
    			},
    			
    			"divisibleBy" : {
    				"type" : "number",
    				"minimum" : 0,
    				"minimumCanEqual" : false,
    				"optional" : true,
    				
    				"parser" : function (instance, self) {
    					if (instance.getType() === "number") {
    						return instance.getValue();
    					}
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var divisor, value, digits;
    					if (instance.getType() === "number") {
    						divisor = schema.getAttribute("divisibleBy");
    						if (divisor === 0) {
    							report.addError(instance, schema, "divisibleBy", "Nothing is divisible by 0", divisor);
    						} else if (divisor !== 1) {
    							value = instance.getValue();
    							digits = Math.max((value.toString().split(".")[1] || " ").length, (divisor.toString().split(".")[1] || " ").length);
    							digits = parseFloat(((value / divisor) % 1).toFixed(digits));  //cut out floating point errors
    							if (0 < digits && digits < 1) {
    								report.addError(instance, schema, "divisibleBy", "Number is not divisible by " + divisor, divisor);
    							}
    						}
    					}
    				}
    			}
    		},
    		
    		"fragmentResolution" : "slash-delimited"
    	});
    	
    	HYPERSCHEMA_02_JSON = JSV.inherits(HYPERSCHEMA_01_JSON, {
    		"id" : "http://json-schema.org/draft-02/hyper-schema#",
    		
    		"properties" : {
    			"fragmentResolution" : {
    				"default" : "slash-delimited"
    			}
    		}
    	});
    	
    	LINKS_02_JSON = JSV.inherits(LINKS_01_JSON, {
    		"$schema" : "http://json-schema.org/draft-02/hyper-schema#",
    		"id" : "http://json-schema.org/draft-02/links#",
    		
    		"properties" : {
    			"targetSchema" : {
    				"$ref" : "hyper-schema#",
    				
    				//need this here because parsers are run before links are resolved
    				"parser" : HYPERSCHEMA_01.getAttribute("parser")
    			}
    		}
    	});
    	
    	ENVIRONMENT.setOption("defaultFragmentDelimiter", "/");
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-02/schema#");  //update later
    	
    	SCHEMA_02 = ENVIRONMENT.createSchema(SCHEMA_02_JSON, true, "http://json-schema.org/draft-02/schema#");
    	HYPERSCHEMA_02 = ENVIRONMENT.createSchema(JSV.inherits(SCHEMA_02, ENVIRONMENT.createSchema(HYPERSCHEMA_02_JSON, true, "http://json-schema.org/draft-02/hyper-schema#"), true), true, "http://json-schema.org/draft-02/hyper-schema#");
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-02/hyper-schema#");
    	
    	LINKS_02 = ENVIRONMENT.createSchema(LINKS_02_JSON, HYPERSCHEMA_02, "http://json-schema.org/draft-02/links#");
    	
    	//
    	// draft-03
    	//
    	
    	function getMatchedPatternProperties(instance, schema, report, self) {
    		var matchedProperties = {}, patternProperties, pattern, regexp, properties, key;
    		
    		if (instance.getType() === "object") {
    			patternProperties = schema.getAttribute("patternProperties");
    			properties = instance.getProperties();
    			for (pattern in patternProperties) {
    				if (patternProperties[pattern] !== O[pattern]) {
    					regexp = null;
    					try {
    						regexp = new RegExp(pattern);
    					} catch (e) {
    						if (report) {
    							report.addError(schema, self, "patternProperties", "Invalid pattern", pattern);
    						}
    					}
    					
    					if (regexp) {
    						for (key in properties) {
    							if (properties[key] !== O[key]  && regexp.test(key)) {
    								matchedProperties[key] = matchedProperties[key] ? JSV.pushUnique(matchedProperties[key], patternProperties[pattern]) : [ patternProperties[pattern] ];
    							}
    						}
    					}
    				}
    			}
    		}
    		
    		return matchedProperties;
    	}
    	
    	SCHEMA_03_JSON = JSV.inherits(SCHEMA_02_JSON, {
    		"$schema" : "http://json-schema.org/draft-03/schema#",
    		"id" : "http://json-schema.org/draft-03/schema#",
    		
    		"properties" : {
    			"patternProperties" : {
    				"type" : "object",
    				"additionalProperties" : {"$ref" : "#"},
    				"default" : {},
    				
    				"parser" : SCHEMA_02.getValueOfProperty("properties")["properties"]["parser"],
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var matchedProperties, key, x;
    					if (instance.getType() === "object") {
    						matchedProperties = getMatchedPatternProperties(instance, schema, report, self);
    						for (key in matchedProperties) {
    							if (matchedProperties[key] !== O[key]) {
    								x = matchedProperties[key].length;
    								while (x--) {
    									matchedProperties[key][x].validate(instance.getProperty(key), report, instance, schema, key);
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"additionalProperties" : {
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var additionalProperties, propertySchemas, properties, matchedProperties, key;
    					if (instance.getType() === "object") {
    						additionalProperties = schema.getAttribute("additionalProperties");
    						propertySchemas = schema.getAttribute("properties") || {};
    						properties = instance.getProperties();
    						matchedProperties = getMatchedPatternProperties(instance, schema);
    						for (key in properties) {
    							if (properties[key] !== O[key] && properties[key] && propertySchemas[key] === O[key] && matchedProperties[key] === O[key]) {
    								if (JSV.isJSONSchema(additionalProperties)) {
    									additionalProperties.validate(properties[key], report, instance, schema, key);
    								} else if (additionalProperties === false) {
    									report.addError(instance, schema, "additionalProperties", "Additional properties are not allowed", additionalProperties);
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"items" : {
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var properties, items, x, xl, itemSchema, additionalItems;
    					
    					if (instance.getType() === "array") {
    						properties = instance.getProperties();
    						items = schema.getAttribute("items");
    						additionalItems = schema.getAttribute("additionalItems");
    						
    						if (JSV.typeOf(items) === "array") {
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema = items[x] || additionalItems;
    								if (itemSchema !== false) {
    									itemSchema.validate(properties[x], report, instance, schema, x);
    								} else {
    									report.addError(instance, schema, "additionalItems", "Additional items are not allowed", itemSchema);
    								}
    							}
    						} else {
    							itemSchema = items || additionalItems;
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								itemSchema.validate(properties[x], report, instance, schema, x);
    							}
    						}
    					}
    				}
    			},
    			
    			"additionalItems" : {
    				"type" : [{"$ref" : "#"}, "boolean"],
    				"default" : {},
    				
    				"parser" : SCHEMA_02.getValueOfProperty("properties")["additionalProperties"]["parser"],
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var additionalItems, properties, x, xl;
    					//only validate if the "items" attribute is undefined
    					if (instance.getType() === "array" && schema.getProperty("items").getType() === "undefined") {
    						additionalItems = schema.getAttribute("additionalItems");
    						properties = instance.getProperties();
    						
    						if (additionalItems !== false) {
    							for (x = 0, xl = properties.length; x < xl; ++x) {
    								additionalItems.validate(properties[x], report, instance, schema, x);
    							}
    						} else if (properties.length) {
    							report.addError(instance, schema, "additionalItems", "Additional items are not allowed", additionalItems);
    						}
    					}
    				}
    			},
    			
    			"optional" : {
    				"validationRequired" : false,
    				"deprecated" : true
    			},
    			
    			"required" : {
    				"type" : "boolean",
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					if (instance.getType() === "undefined" && schema.getAttribute("required")) {
    						report.addError(instance, schema, "required", "Property is required", true);
    					}
    				}
    			},
    			
    			"requires" : {
    				"deprecated" : true
    			},
    			
    			"dependencies" : {
    				"type" : "object",
    				"additionalProperties" : {
    					"type" : ["string", "array", {"$ref" : "#"}],
    					"items" : {
    						"type" : "string"
    					}
    				},
    				"default" : {},
    				
    				"parser" : function (instance, self, arg) {
    					function parseProperty(property) {
    						var type = property.getType();
    						if (type === "string" || type === "array") {
    							return property.getValue();
    						} else if (type === "object") {
    							return property.getEnvironment().createSchema(property, self.getEnvironment().findSchema(self.resolveURI("#")));
    						}
    					}
    					
    					if (instance.getType() === "object") {
    						if (arg) {
    							return parseProperty(instance.getProperty(arg));
    						} else {
    							return JSV.mapObject(instance.getProperties(), parseProperty);
    						}
    					}
    					//else
    					return {};
    				},
    				
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var dependencies, key, dependency, type, x, xl;
    					if (instance.getType() === "object") {
    						dependencies = schema.getAttribute("dependencies");
    						for (key in dependencies) {
    							if (dependencies[key] !== O[key] && instance.getProperty(key).getType() !== "undefined") {
    								dependency = dependencies[key];
    								type = JSV.typeOf(dependency);
    								if (type === "string") {
    									if (instance.getProperty(dependency).getType() === "undefined") {
    										report.addError(instance, schema, "dependencies", 'Property "' + key + '" requires sibling property "' + dependency + '"', dependencies);
    									}
    								} else if (type === "array") {
    									for (x = 0, xl = dependency.length; x < xl; ++x) {
    										if (instance.getProperty(dependency[x]).getType() === "undefined") {
    											report.addError(instance, schema, "dependencies", 'Property "' + key + '" requires sibling property "' + dependency[x] + '"', dependencies);
    										}
    									}
    								} else if (JSV.isJSONSchema(dependency)) {
    									dependency.validate(instance, report);
    								}
    							}
    						}
    					}
    				}
    			},
    			
    			"minimumCanEqual" : {
    				"deprecated" : true
    			},
    			
    			"maximumCanEqual" : {
    				"deprecated" : true
    			},
    			
    			"exclusiveMinimum" : {
    				"type" : "boolean",
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				}
    			},
    			
    			"exclusiveMaximum" : {
    				"type" : "boolean",
    				"default" : false,
    				
    				"parser" : function (instance, self) {
    					return !!instance.getValue();
    				}
    			},
    			
    			"minimum" : {
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var minimum, exclusiveMinimum;
    					if (instance.getType() === "number") {
    						minimum = schema.getAttribute("minimum");
    						exclusiveMinimum = schema.getAttribute("exclusiveMinimum") || (!instance.getEnvironment().getOption("strict") && !schema.getAttribute("minimumCanEqual"));
    						if (typeof minimum === "number" && (instance.getValue() < minimum || (exclusiveMinimum === true && instance.getValue() === minimum))) {
    							report.addError(instance, schema, "minimum", "Number is less than the required minimum value", minimum);
    						}
    					}
    				}
    			},
    			
    			"maximum" : {
    				"validator" : function (instance, schema, self, report, parent, parentSchema, name) {
    					var maximum, exclusiveMaximum;
    					if (instance.getType() === "number") {
    						maximum = schema.getAttribute("maximum");
    						exclusiveMaximum = schema.getAttribute("exclusiveMaximum") || (!instance.getEnvironment().getOption("strict") && !schema.getAttribute("maximumCanEqual"));
    						if (typeof maximum === "number" && (instance.getValue() > maximum || (exclusiveMaximum === true && instance.getValue() === maximum))) {
    							report.addError(instance, schema, "maximum", "Number is greater than the required maximum value", maximum);
    						}
    					}
    				}
    			},
    			
    			"contentEncoding" : {
    				"deprecated" : true
    			},
    			
    			"divisibleBy" : {
    				"exclusiveMinimum" : true
    			},
    			
    			"disallow" : {
    				"items" : {
    					"type" : ["string", {"$ref" : "#"}]
    				},
    				
    				"parser" : SCHEMA_02_JSON["properties"]["type"]["parser"]
    			},
    			
    			"id" : {
    				"type" : "string",
    				"format" : "uri"
    			},
    			
    			"$ref" : {
    				"type" : "string",
    				"format" : "uri"
    			},
    			
    			"$schema" : {
    				"type" : "string",
    				"format" : "uri"
    			}
    		},
    		
    		"dependencies" : {
    			"exclusiveMinimum" : "minimum",
    			"exclusiveMaximum" : "maximum"
    		},
    		
    		"initializer" : function (instance) {
    			var link, extension, extended,
    				schemaLink = instance.getValueOfProperty("$schema"),
    				refLink = instance.getValueOfProperty("$ref"),
    				idLink = instance.getValueOfProperty("id");
    			
    			//if there is a link to a different schema, set reference
    			if (schemaLink) {
    				link = instance.resolveURI(schemaLink);
    				instance.setReference("describedby", link);
    			}
    			
    			//if instance has a URI link to itself, update it's own URI
    			if (idLink) {
    				link = instance.resolveURI(idLink);
    				if (JSV.typeOf(link) === "string") {
    					instance._uri = JSV.formatURI(link);
    				}
    			}
    			
    			//if there is a link to the full representation, set reference
    			if (refLink) {
    				link = instance.resolveURI(refLink);
    				instance.setReference("full", link);
    			}
    			
    			//extend schema
    			extension = instance.getAttribute("extends");
    			if (JSV.isJSONSchema(extension)) {
    				extended = JSV.inherits(extension, instance, true);
    				instance = instance._env.createSchema(extended, instance._schema, instance._uri);
    			}
    			
    			return instance;
    		}
    	});
    	
    	HYPERSCHEMA_03_JSON = JSV.inherits(HYPERSCHEMA_02_JSON, {
    		"$schema" : "http://json-schema.org/draft-03/hyper-schema#",
    		"id" : "http://json-schema.org/draft-03/hyper-schema#",
    		
    		"properties" : {
    			"links" : {
    				"selfReferenceVariable" : "@"
    			},
    			
    			"root" : {
    				"deprecated" : true
    			},
    			
    			"contentEncoding" : {
    				"deprecated" : false  //moved from core to hyper
    			},
    			
    			"alternate" : {
    				"deprecated" : true
    			}
    		}
    	});
    	
    	LINKS_03_JSON = JSV.inherits(LINKS_02_JSON, {
    		"$schema" : "http://json-schema.org/draft-03/hyper-schema#",
    		"id" : "http://json-schema.org/draft-03/links#",
    		
    		"properties" : {
    			"href" : {
    				"required" : true,
    				"format" : "link-description-object-template"
    			},
    			
    			"rel" : {
    				"required" : true
    			},
    			
    			"properties" : {
    				"deprecated" : true
    			},
    			
    			"schema" : {"$ref" : "http://json-schema.org/draft-03/hyper-schema#"}
    		}
    	});
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-03/schema#");  //update later
    	
    	SCHEMA_03 = ENVIRONMENT.createSchema(SCHEMA_03_JSON, true, "http://json-schema.org/draft-03/schema#");
    	HYPERSCHEMA_03 = ENVIRONMENT.createSchema(JSV.inherits(SCHEMA_03, ENVIRONMENT.createSchema(HYPERSCHEMA_03_JSON, true, "http://json-schema.org/draft-03/hyper-schema#"), true), true, "http://json-schema.org/draft-03/hyper-schema#");
    	
    	ENVIRONMENT.setOption("defaultSchemaURI", "http://json-schema.org/draft-03/hyper-schema#");
    	
    	LINKS_03 = ENVIRONMENT.createSchema(LINKS_03_JSON, true, "http://json-schema.org/draft-03/links#");
    	
    	ENVIRONMENT.setOption("latestJSONSchemaSchemaURI", "http://json-schema.org/draft-03/schema#");
    	ENVIRONMENT.setOption("latestJSONSchemaHyperSchemaURI", "http://json-schema.org/draft-03/hyper-schema#");
    	ENVIRONMENT.setOption("latestJSONSchemaLinksURI", "http://json-schema.org/draft-03/links#");
    	
    	//
    	//Latest JSON Schema
    	//
    	
    	//Hack, but WAY faster than instantiating a new schema
    	ENVIRONMENT._schemas["http://json-schema.org/schema#"] = SCHEMA_03;
    	ENVIRONMENT._schemas["http://json-schema.org/hyper-schema#"] = HYPERSCHEMA_03;
    	ENVIRONMENT._schemas["http://json-schema.org/links#"] = LINKS_03;
    	
    	//
    	//register environment
    	//
    	
    	JSV.registerEnvironment("json-schema-draft-03", ENVIRONMENT);
    	if (!JSV.getDefaultEnvironmentID() || JSV.getDefaultEnvironmentID() === "json-schema-draft-01" || JSV.getDefaultEnvironmentID() === "json-schema-draft-02") {
    		JSV.setDefaultEnvironmentID("json-schema-draft-03");
    	}
    	
    }());
  provide("JSV/lib/json-schema-draft-03", module.exports);
}(global));

// pakmanager:JSV/lib/environments
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
   require('JSV/lib/json-schema-draft-01');
     require('JSV/lib/json-schema-draft-02');
     require('JSV/lib/json-schema-draft-03');
  provide("JSV/lib/environments", module.exports);
}(global));

// pakmanager:JSV
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * JSV: JSON Schema Validator
     * 
     * @fileOverview A JavaScript implementation of a extendable, fully compliant JSON Schema validator.
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @version 4.0.2
     * @see http://github.com/garycourt/JSV
     */
    
    /*
     * Copyright 2010 Gary Court. All rights reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification, are
     * permitted provided that the following conditions are met:
     * 
     *    1. Redistributions of source code must retain the above copyright notice, this list of
     *       conditions and the following disclaimer.
     * 
     *    2. Redistributions in binary form must reproduce the above copyright notice, this list
     *       of conditions and the following disclaimer in the documentation and/or other materials
     *       provided with the distribution.
     * 
     * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * The views and conclusions contained in the software and documentation are those of the
     * authors and should not be interpreted as representing official policies, either expressed
     * or implied, of Gary Court or the JSON Schema specification.
     */
    
    /*jslint white: true, sub: true, onevar: true, undef: true, eqeqeq: true, newcap: true, immed: true, indent: 4 */
    
    var exports = exports || this,
    	require = require || function () {
    		return exports;
    	};
    
    (function () {
    	
    	var URI =  require('JSV/lib/uri/uri').URI,
    		O = {},
    		I2H = "0123456789abcdef".split(""),
    		mapArray, filterArray, searchArray,
    		
    		JSV;
    	
    	//
    	// Utility functions
    	//
    	
    	function typeOf(o) {
    		return o === undefined ? "undefined" : (o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase());
    	}
    	
    	/** @inner */
    	function F() {}
    	
    	function createObject(proto) {
    		F.prototype = proto || {};
    		return new F();
    	}
    	
    	function mapObject(obj, func, scope) {
    		var newObj = {}, key;
    		for (key in obj) {
    			if (obj[key] !== O[key]) {
    				newObj[key] = func.call(scope, obj[key], key, obj);
    			}
    		}
    		return newObj;
    	}
    	
    	/** @ignore */
    	mapArray = function (arr, func, scope) {
    		var x = 0, xl = arr.length, newArr = new Array(xl);
    		for (; x < xl; ++x) {
    			newArr[x] = func.call(scope, arr[x], x, arr);
    		}
    		return newArr;
    	};
    		
    	if (Array.prototype.map) {
    		/** @ignore */
    		mapArray = function (arr, func, scope) {
    			return Array.prototype.map.call(arr, func, scope);
    		};
    	}
    	
    	/** @ignore */
    	filterArray = function (arr, func, scope) {
    		var x = 0, xl = arr.length, newArr = [];
    		for (; x < xl; ++x) {
    			if (func.call(scope, arr[x], x, arr)) {
    				newArr[newArr.length] = arr[x];
    			}
    		}
    		return newArr;
    	};
    	
    	if (Array.prototype.filter) {
    		/** @ignore */
    		filterArray = function (arr, func, scope) {
    			return Array.prototype.filter.call(arr, func, scope);
    		};
    	}
    	
    	/** @ignore */
    	searchArray = function (arr, o) {
    		var x = 0, xl = arr.length;
    		for (; x < xl; ++x) {
    			if (arr[x] === o) {
    				return x;
    			}
    		}
    		return -1;
    	};
    	
    	if (Array.prototype.indexOf) {
    		/** @ignore */
    		searchArray = function (arr, o) {
    			return Array.prototype.indexOf.call(arr, o);
    		};
    	}
    	
    	function toArray(o) {
    		return o !== undefined && o !== null ? (o instanceof Array && !o.callee ? o : (typeof o.length !== "number" || o.split || o.setInterval || o.call ? [ o ] : Array.prototype.slice.call(o))) : [];
    	}
    	
    	function keys(o) {
    		var result = [], key;
    		
    		switch (typeOf(o)) {
    		case "object":
    			for (key in o) {
    				if (o[key] !== O[key]) {
    					result[result.length] = key;
    				}
    			}
    			break;
    		case "array":
    			for (key = o.length - 1; key >= 0; --key) {
    				result[key] = key;
    			}
    			break;
    		}
    		
    		return result;
    	}
    	
    	function pushUnique(arr, o) {
    		if (searchArray(arr, o) === -1) {
    			arr.push(o);
    		}
    		return arr;
    	}
    	
    	function popFirst(arr, o) {
    		var index = searchArray(arr, o);
    		if (index > -1) {
    			arr.splice(index, 1);
    		}
    		return arr;
    	}
    	
    	function randomUUID() {
    		return [
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-",
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-4",  //set 4 high bits of time_high field to version
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-",
    			I2H[(Math.floor(Math.random() * 0x10) & 0x3) | 0x8],  //specify 2 high bits of clock sequence
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			"-",
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)],
    			I2H[Math.floor(Math.random() * 0x10)]
    		].join("");
    	}
    	
    	function escapeURIComponent(str) {
    		return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
    	}
    	
    	function formatURI(uri) {
    		if (typeof uri === "string" && uri.indexOf("#") === -1) {
    			uri += "#";
    		}
    		return uri;
    	}
    	
    	function stripInstances(o) {
    		if (o instanceof JSONInstance) {
    			return o.getURI();
    		}
    		
    		switch (typeOf(o)) {
    		case "undefined":
    		case "null":
    		case "boolean":
    		case "number":
    		case "string":
    			return o;  //do nothing
    		
    		case "object":
    			return mapObject(o, stripInstances);
    		
    		case "array":
    			return mapArray(o, stripInstances);
    		
    		default:
    			return o.toString();
    		}
    	}
    	
    	/**
    	 * The exception that is thrown when a schema fails to be created.
    	 * 
    	 * @name InitializationError
    	 * @class
    	 * @param {JSONInstance|String} instance The instance (or instance URI) that is invalid
    	 * @param {JSONSchema|String} schema The schema (or schema URI) that was validating the instance
    	 * @param {String} attr The attribute that failed to validated
    	 * @param {String} message A user-friendly message on why the schema attribute failed to validate the instance
    	 * @param {Any} details The value of the schema attribute
    	 */
    	
    	function InitializationError(instance, schema, attr, message, details) {
    		Error.call(this, message);
    		
    		this.uri = instance instanceof JSONInstance ? instance.getURI() : instance;
    		this.schemaUri = schema instanceof JSONInstance ? schema.getURI() : schema;
    		this.attribute = attr;
    		this.message = message;
    		this.description = message;  //IE
    		this.details = details;
    	}
    	
    	InitializationError.prototype = new Error();
    	InitializationError.prototype.constructor = InitializationError;
    	InitializationError.prototype.name = "InitializationError";
    	
    	/**
    	 * Defines an error, found by a schema, with an instance.
    	 * This class can only be instantiated by {@link Report#addError}. 
    	 * 
    	 * @name ValidationError
    	 * @class
    	 * @see Report#addError
    	 */
    	
    	/**
    	 * The URI of the instance that has the error.
    	 * 
    	 * @name ValidationError.prototype.uri
    	 * @type String
    	 */
    	
    	/**
    	 * The URI of the schema that generated the error.
    	 * 
    	 * @name ValidationError.prototype.schemaUri
    	 * @type String
    	 */
    	
    	/**
    	 * The name of the schema attribute that generated the error.
    	 * 
    	 * @name ValidationError.prototype.attribute
    	 * @type String
    	 */
    	
    	/**
    	 * An user-friendly (English) message about what failed to validate.
    	 * 
    	 * @name ValidationError.prototype.message
    	 * @type String
    	 */
    	
    	/**
    	 * The value of the schema attribute that generated the error.
    	 * 
    	 * @name ValidationError.prototype.details
    	 * @type Any
    	 */
    	
    	/**
    	 * Reports are returned from validation methods to describe the result of a validation.
    	 * 
    	 * @name Report
    	 * @class
    	 * @see JSONSchema#validate
    	 * @see Environment#validate
    	 */
    	
    	function Report() {
    		/**
    		 * An array of {@link ValidationError} objects that define all the errors generated by the schema against the instance.
    		 * 
    		 * @name Report.prototype.errors
    		 * @type Array
    		 * @see Report#addError
    		 */
    		this.errors = [];
    		
    		/**
    		 * A hash table of every instance and what schemas were validated against it.
    		 * <p>
    		 * The key of each item in the table is the URI of the instance that was validated.
    		 * The value of this key is an array of strings of URIs of the schema that validated it.
    		 * </p>
    		 * 
    		 * @name Report.prototype.validated
    		 * @type Object
    		 * @see Report#registerValidation
    		 * @see Report#isValidatedBy
    		 */
    		this.validated = {};
    		
    		/**
    		 * If the report is generated by {@link Environment#validate}, this field is the generated instance.
    		 * 
    		 * @name Report.prototype.instance
    		 * @type JSONInstance
    		 * @see Environment#validate
    		 */
    		
    		/**
    		 * If the report is generated by {@link Environment#validate}, this field is the generated schema.
    		 * 
    		 * @name Report.prototype.schema
    		 * @type JSONSchema
    		 * @see Environment#validate
    		 */
    		 
    		/**
    		 * If the report is generated by {@link Environment#validate}, this field is the schema's schema.
    		 * This value is the same as calling <code>schema.getSchema()</code>.
    		 * 
    		 * @name Report.prototype.schemaSchema
    		 * @type JSONSchema
    		 * @see Environment#validate
    		 * @see JSONSchema#getSchema
    		 */
    	}
    	
    	/**
    	 * Adds a {@link ValidationError} object to the <a href="#errors"><code>errors</code></a> field.
    	 * 
    	 * @param {JSONInstance|String} instance The instance (or instance URI) that is invalid
    	 * @param {JSONSchema|String} schema The schema (or schema URI) that was validating the instance
    	 * @param {String} attr The attribute that failed to validated
    	 * @param {String} message A user-friendly message on why the schema attribute failed to validate the instance
    	 * @param {Any} details The value of the schema attribute
    	 */
    	
    	Report.prototype.addError = function (instance, schema, attr, message, details) {
    		this.errors.push({
    			uri : instance instanceof JSONInstance ? instance.getURI() : instance,
    			schemaUri : schema instanceof JSONInstance ? schema.getURI() : schema,
    			attribute : attr,
    			message : message,
    			details : stripInstances(details)
    		});
    	};
    	
    	/**
    	 * Registers that the provided instance URI has been validated by the provided schema URI. 
    	 * This is recorded in the <a href="#validated"><code>validated</code></a> field.
    	 * 
    	 * @param {String} uri The URI of the instance that was validated
    	 * @param {String} schemaUri The URI of the schema that validated the instance
    	 */
    	
    	Report.prototype.registerValidation = function (uri, schemaUri) {
    		if (!this.validated[uri]) {
    			this.validated[uri] = [ schemaUri ];
    		} else {
    			this.validated[uri].push(schemaUri);
    		}
    	};
    	
    	/**
    	 * Returns if an instance with the provided URI has been validated by the schema with the provided URI. 
    	 * 
    	 * @param {String} uri The URI of the instance
    	 * @param {String} schemaUri The URI of a schema
    	 * @returns {Boolean} If the instance has been validated by the schema.
    	 */
    	
    	Report.prototype.isValidatedBy = function (uri, schemaUri) {
    		return !!this.validated[uri] && searchArray(this.validated[uri], schemaUri) !== -1;
    	};
    	
    	/**
    	 * A wrapper class for binding an Environment, URI and helper methods to an instance. 
    	 * This class is most commonly instantiated with {@link Environment#createInstance}.
    	 * 
    	 * @name JSONInstance
    	 * @class
    	 * @param {Environment} env The environment this instance belongs to
    	 * @param {JSONInstance|Any} json The value of the instance
    	 * @param {String} [uri] The URI of the instance. If undefined, the URI will be a randomly generated UUID. 
    	 * @param {String} [fd] The fragment delimiter for properties. If undefined, uses the environment default.
    	 */
    	
    	function JSONInstance(env, json, uri, fd) {
    		if (json instanceof JSONInstance) {
    			if (typeof fd !== "string") {
    				fd = json._fd;
    			}
    			if (typeof uri !== "string") {
    				uri = json._uri;
    			}
    			json = json._value;
    		}
    		
    		if (typeof uri !== "string") {
    			uri = "urn:uuid:" + randomUUID() + "#";
    		} else if (uri.indexOf(":") === -1) {
    			uri = formatURI(URI.resolve("urn:uuid:" + randomUUID() + "#", uri));
    		}
    		
    		this._env = env;
    		this._value = json;
    		this._uri = uri;
    		this._fd = fd || this._env._options["defaultFragmentDelimiter"];
    	}
    	
    	/**
    	 * Returns the environment the instance is bound to.
    	 * 
    	 * @returns {Environment} The environment of the instance
    	 */
    	
    	JSONInstance.prototype.getEnvironment = function () {
    		return this._env;
    	};
    	
    	/**
    	 * Returns the name of the type of the instance.
    	 * 
    	 * @returns {String} The name of the type of the instance
    	 */
    	
    	JSONInstance.prototype.getType = function () {
    		return typeOf(this._value);
    	};
    	
    	/**
    	 * Returns the JSON value of the instance.
    	 * 
    	 * @returns {Any} The actual JavaScript value of the instance
    	 */
    	
    	JSONInstance.prototype.getValue = function () {
    		return this._value;
    	};
    	
    	/**
    	 * Returns the URI of the instance.
    	 * 
    	 * @returns {String} The URI of the instance
    	 */
    	
    	JSONInstance.prototype.getURI = function () {
    		return this._uri;
    	};
    	
    	/**
    	 * Returns a resolved URI of a provided relative URI against the URI of the instance.
    	 * 
    	 * @param {String} uri The relative URI to resolve
    	 * @returns {String} The resolved URI
    	 */
    	
    	JSONInstance.prototype.resolveURI = function (uri) {
    		return formatURI(URI.resolve(this._uri, uri));
    	};
    	
    	/**
    	 * Returns an array of the names of all the properties.
    	 * 
    	 * @returns {Array} An array of strings which are the names of all the properties
    	 */
    	
    	JSONInstance.prototype.getPropertyNames = function () {
    		return keys(this._value);
    	};
    	
    	/**
    	 * Returns a {@link JSONInstance} of the value of the provided property name. 
    	 * 
    	 * @param {String} key The name of the property to fetch
    	 * @returns {JSONInstance} The instance of the property value
    	 */
    	
    	JSONInstance.prototype.getProperty = function (key) {
    		var value = this._value ? this._value[key] : undefined;
    		if (value instanceof JSONInstance) {
    			return value;
    		}
    		//else
    		return new JSONInstance(this._env, value, this._uri + this._fd + escapeURIComponent(key), this._fd);
    	};
    	
    	/**
    	 * Returns all the property instances of the target instance.
    	 * <p>
    	 * If the target instance is an Object, then the method will return a hash table of {@link JSONInstance}s of all the properties. 
    	 * If the target instance is an Array, then the method will return an array of {@link JSONInstance}s of all the items.
    	 * </p> 
    	 * 
    	 * @returns {Object|Array|undefined} The list of instances for all the properties
    	 */
    	
    	JSONInstance.prototype.getProperties = function () {
    		var type = typeOf(this._value),
    			self = this;
    		
    		if (type === "object") {
    			return mapObject(this._value, function (value, key) {
    				if (value instanceof JSONInstance) {
    					return value;
    				}
    				return new JSONInstance(self._env, value, self._uri + self._fd + escapeURIComponent(key), self._fd);
    			});
    		} else if (type === "array") {
    			return mapArray(this._value, function (value, key) {
    				if (value instanceof JSONInstance) {
    					return value;
    				}
    				return new JSONInstance(self._env, value, self._uri + self._fd + escapeURIComponent(key), self._fd);
    			});
    		}
    	};
    	
    	/**
    	 * Returns the JSON value of the provided property name. 
    	 * This method is a faster version of calling <code>instance.getProperty(key).getValue()</code>.
    	 * 
    	 * @param {String} key The name of the property
    	 * @returns {Any} The JavaScript value of the instance
    	 * @see JSONInstance#getProperty
    	 * @see JSONInstance#getValue
    	 */
    	
    	JSONInstance.prototype.getValueOfProperty = function (key) {
    		if (this._value) {
    			if (this._value[key] instanceof JSONInstance) {
    				return this._value[key]._value;
    			}
    			return this._value[key];
    		}
    	};
    	
    	/**
    	 * Return if the provided value is the same as the value of the instance.
    	 * 
    	 * @param {JSONInstance|Any} instance The value to compare
    	 * @returns {Boolean} If both the instance and the value match
    	 */
    	
    	JSONInstance.prototype.equals = function (instance) {
    		if (instance instanceof JSONInstance) {
    			return this._value === instance._value;
    		}
    		//else
    		return this._value === instance;
    	};
    	
    	/**
    	 * Warning: Not a generic clone function
    	 * Produces a JSV acceptable clone
    	 */
    	
    	function clone(obj, deep) {
    		var newObj, x;
    		
    		if (obj instanceof JSONInstance) {
    			obj = obj.getValue();
    		}
    		
    		switch (typeOf(obj)) {
    		case "object":
    			if (deep) {
    				newObj = {};
    				for (x in obj) {
    					if (obj[x] !== O[x]) {
    						newObj[x] = clone(obj[x], deep);
    					}
    				}
    				return newObj;
    			} else {
    				return createObject(obj);
    			}
    			break;
    		case "array":
    			if (deep) {
    				newObj = new Array(obj.length);
    				x = obj.length;
    				while (--x >= 0) {
    					newObj[x] = clone(obj[x], deep);
    				}
    				return newObj;
    			} else {
    				return Array.prototype.slice.call(obj);
    			}
    			break;
    		default:
    			return obj;
    		}
    	}
    	
    	/**
    	 * This class binds a {@link JSONInstance} with a {@link JSONSchema} to provided context aware methods. 
    	 * 
    	 * @name JSONSchema
    	 * @class
    	 * @param {Environment} env The environment this schema belongs to
    	 * @param {JSONInstance|Any} json The value of the schema
    	 * @param {String} [uri] The URI of the schema. If undefined, the URI will be a randomly generated UUID. 
    	 * @param {JSONSchema|Boolean} [schema] The schema to bind to the instance. If <code>undefined</code>, the environment's default schema will be used. If <code>true</code>, the instance's schema will be itself.
    	 * @extends JSONInstance
    	 */
    	
    	function JSONSchema(env, json, uri, schema) {
    		var fr;
    		JSONInstance.call(this, env, json, uri);
    		
    		if (schema === true) {
    			this._schema = this;
    		} else if (json instanceof JSONSchema && !(schema instanceof JSONSchema)) {
    			this._schema = json._schema;  //TODO: Make sure cross environments don't mess everything up
    		} else {
    			this._schema = schema instanceof JSONSchema ? schema : this._env.getDefaultSchema() || this._env.createEmptySchema();
    		}
    		
    		//determine fragment delimiter from schema
    		fr = this._schema.getValueOfProperty("fragmentResolution");
    		if (fr === "dot-delimited") {
    			this._fd = ".";
    		} else if (fr === "slash-delimited") {
    			this._fd = "/";
    		}
    		
    		return this.rebuild();  //this works even when called with "new"
    	}
    	
    	JSONSchema.prototype = createObject(JSONInstance.prototype);
    	
    	/**
    	 * Returns the schema of the schema.
    	 * 
    	 * @returns {JSONSchema} The schema of the schema
    	 */
    	
    	JSONSchema.prototype.getSchema = function () {
    		var uri = this._refs && this._refs["describedby"],
    			newSchema;
    		
    		if (uri) {
    			newSchema = uri && this._env.findSchema(uri);
    			
    			if (newSchema) {
    				if (!newSchema.equals(this._schema)) {
    					this._schema = newSchema;
    					this.rebuild();  //if the schema has changed, the context has changed - so everything must be rebuilt
    				}
    			} else if (this._env._options["enforceReferences"]) {
    				throw new InitializationError(this, this._schema, "{describedby}", "Unknown schema reference", uri);
    			}
    		}
    		
    		return this._schema;
    	};
    	
    	/**
    	 * Returns the value of the provided attribute name.
    	 * <p>
    	 * This method is different from {@link JSONInstance#getProperty} as the named property 
    	 * is converted using a parser defined by the schema's schema before being returned. This
    	 * makes the return value of this method attribute dependent.
    	 * </p>
    	 * 
    	 * @param {String} key The name of the attribute
    	 * @param {Any} [arg] Some attribute parsers accept special arguments for returning resolved values. This is attribute dependent.
    	 * @returns {JSONSchema|Any} The value of the attribute
    	 */
    	
    	JSONSchema.prototype.getAttribute = function (key, arg) {
    		var schemaProperty, parser, property, result,
    			schema = this.getSchema();  //we do this here to make sure the "describedby" reference has not changed, and that the attribute cache is up-to-date
    		
    		if (!arg && this._attributes && this._attributes.hasOwnProperty(key)) {
    			return this._attributes[key];
    		}
    		
    		schemaProperty = schema.getProperty("properties").getProperty(key);
    		parser = schemaProperty.getValueOfProperty("parser");
    		property = this.getProperty(key);
    		if (typeof parser === "function") {
    			result = parser(property, schemaProperty, arg);
    			if (!arg && this._attributes) {
    				this._attributes[key] = result;
    			}
    			return result;
    		}
    		//else
    		return property.getValue();
    	};
    	
    	/**
    	 * Returns all the attributes of the schema.
    	 * 
    	 * @returns {Object} A map of all parsed attribute values
    	 */
    	
    	JSONSchema.prototype.getAttributes = function () {
    		var properties, schemaProperties, key, schemaProperty, parser,
    			schema = this.getSchema();  //we do this here to make sure the "describedby" reference has not changed, and that the attribute cache is up-to-date
    		
    		if (!this._attributes && this.getType() === "object") {
    			properties = this.getProperties();
    			schemaProperties = schema.getProperty("properties");
    			this._attributes = {};
    			for (key in properties) {
    				if (properties[key] !== O[key]) {
    					schemaProperty = schemaProperties && schemaProperties.getProperty(key);
    					parser = schemaProperty && schemaProperty.getValueOfProperty("parser");
    					if (typeof parser === "function") {
    						this._attributes[key] = parser(properties[key], schemaProperty);
    					} else {
    						this._attributes[key] = properties[key].getValue();
    					}
    				}
    			}
    		}
    		
    		return clone(this._attributes, false);
    	};
    	
    	/**
    	 * Convenience method for retrieving a link or link object from a schema. 
    	 * This method is the same as calling <code>schema.getAttribute("links", [rel, instance])[0];</code>.
    	 * 
    	 * @param {String} rel The link relationship
    	 * @param {JSONInstance} [instance] The instance to resolve any URIs from
    	 * @returns {String|Object|undefined} If <code>instance</code> is provided, a string containing the resolve URI of the link is returned.
    	 *   If <code>instance</code> is not provided, a link object is returned with details of the link.
    	 *   If no link with the provided relationship exists, <code>undefined</code> is returned.
    	 * @see JSONSchema#getAttribute
    	 */
    	
    	JSONSchema.prototype.getLink = function (rel, instance) {
    		var schemaLinks = this.getAttribute("links", [rel, instance]);
    		if (schemaLinks && schemaLinks.length && schemaLinks[schemaLinks.length - 1]) {
    			return schemaLinks[schemaLinks.length - 1];
    		}
    	};
    	
    	/**
    	 * Validates the provided instance against the target schema and returns a {@link Report}.
    	 * 
    	 * @param {JSONInstance|Any} instance The instance to validate; may be a {@link JSONInstance} or any JavaScript value
    	 * @param {Report} [report] A {@link Report} to concatenate the result of the validation to. If <code>undefined</code>, a new {@link Report} is created. 
    	 * @param {JSONInstance} [parent] The parent/containing instance of the provided instance
    	 * @param {JSONSchema} [parentSchema] The schema of the parent/containing instance
    	 * @param {String} [name] The name of the parent object's property that references the instance
    	 * @returns {Report} The result of the validation
    	 */
    	
    	JSONSchema.prototype.validate = function (instance, report, parent, parentSchema, name) {
    		var schemaSchema = this.getSchema(),
    			validator = schemaSchema.getValueOfProperty("validator");
    		
    		if (!(instance instanceof JSONInstance)) {
    			instance = this.getEnvironment().createInstance(instance);
    		}
    		
    		if (!(report instanceof Report)) {
    			report = new Report();
    		}
    		
    		if (this._env._options["validateReferences"] && this._refs) {
    			if (this._refs["describedby"] && !this._env.findSchema(this._refs["describedby"])) {
    				report.addError(this, this._schema, "{describedby}", "Unknown schema reference", this._refs["describedby"]);
    			}
    			if (this._refs["full"] && !this._env.findSchema(this._refs["full"])) {
    				report.addError(this, this._schema, "{full}", "Unknown schema reference", this._refs["full"]);
    			}
    		}
    		
    		if (typeof validator === "function" && !report.isValidatedBy(instance.getURI(), this.getURI())) {
    			report.registerValidation(instance.getURI(), this.getURI());
    			validator(instance, this, schemaSchema, report, parent, parentSchema, name);
    		}
    		
    		return report;
    	};
    	
    	/** @inner */
    	function createFullLookupWrapper(func) {
    		return /** @inner */ function fullLookupWrapper() {
    			var scope = this,
    				stack = [],
    				uri = scope._refs && scope._refs["full"],
    				schema;
    			
    			while (uri) {
    				schema = scope._env.findSchema(uri);
    				if (schema) {
    					if (schema._value === scope._value) {
    						break;
    					}
    					scope = schema;
    					stack.push(uri);
    					uri = scope._refs && scope._refs["full"];
    					if (stack.indexOf(uri) > -1) {
    						break;  //stop infinite loop
    					}
    				} else if (scope._env._options["enforceReferences"]) {
    					throw new InitializationError(scope, scope._schema, "{full}", "Unknown schema reference", uri);
    				} else {
    					uri = null;
    				}
    			}
    			return func.apply(scope, arguments);
    		};
    	}
    	
    	/**
    	 * Wraps all JSONInstance methods with a function that resolves the "full" reference.
    	 * 
    	 * @inner
    	 */
    	
    	(function () {
    		var key;
    		for (key in JSONSchema.prototype) {
    			if (JSONSchema.prototype[key] !== O[key] && typeOf(JSONSchema.prototype[key]) === "function") {
    				JSONSchema.prototype[key] = createFullLookupWrapper(JSONSchema.prototype[key]);
    			}
    		}
    	}());
    	
    	/**
    	 * Reinitializes/re-registers/rebuilds the schema.
    	 * <br/>
    	 * This is used internally, and should only be called when a schema's private variables are modified directly.
    	 * 
    	 * @private
    	 * @return {JSONSchema} The newly rebuilt schema
    	 */
    	
    	JSONSchema.prototype.rebuild = function () {
    		var instance = this,
    			initializer = instance.getSchema().getValueOfProperty("initializer");
    		
    		//clear previous built values
    		instance._refs = null;
    		instance._attributes = null;
    		
    		if (typeof initializer === "function") {
    			instance = initializer(instance);
    		}
    		
    		//register schema
    		instance._env._schemas[instance._uri] = instance;
    		
    		//build & cache the rest of the schema
    		instance.getAttributes();
    		
    		return instance;
    	};
    	
    	/**
    	 * Set the provided reference to the given value.
    	 * <br/>
    	 * References are used for establishing soft-links to other {@link JSONSchema}s.
    	 * Currently, the following references are natively supported:
    	 * <dl>
    	 *   <dt><code>full</code></dt>
    	 *   <dd>The value is the URI to the full instance of this instance.</dd>
    	 *   <dt><code>describedby</code></dt>
    	 *   <dd>The value is the URI to the schema of this instance.</dd>
    	 * </dl>
    	 * 
    	 * @param {String} name The name of the reference
    	 * @param {String} uri The URI of the schema to refer to
    	 */
    	
    	JSONSchema.prototype.setReference = function (name, uri) {
    		if (!this._refs) {
    			this._refs = {};
    		}
    		this._refs[name] = this.resolveURI(uri);
    	};
    	
    	/**
    	 * Returns the value of the provided reference name.
    	 * 
    	 * @param {String} name The name of the reference
    	 * @return {String} The value of the provided reference name
    	 */
    	
    	JSONSchema.prototype.getReference = function (name) {
    		return this._refs && this._refs[name];
    	};
    	
    	/**
    	 * Merges two schemas/instances together.
    	 */
    	
    	function inherits(base, extra, extension) {
    		var baseType = typeOf(base),
    			extraType = typeOf(extra),
    			child, x;
    		
    		if (extraType === "undefined") {
    			return clone(base, true);
    		} else if (baseType === "undefined" || extraType !== baseType) {
    			return clone(extra, true);
    		} else if (extraType === "object") {
    			if (base instanceof JSONSchema) {
    				base = base.getAttributes();
    			}
    			if (extra instanceof JSONSchema) {
    				extra = extra.getAttributes();
    				if (extra["extends"] && extension && extra["extends"] instanceof JSONSchema) {
    					extra["extends"] = [ extra["extends"] ];
    				}
    			}
    			child = clone(base, true);  //this could be optimized as some properties get overwritten
    			for (x in extra) {
    				if (extra[x] !== O[x]) {
    					child[x] = inherits(base[x], extra[x], extension);
    				}
    			}
    			return child;
    		} else {
    			return clone(extra, true);
    		}
    	}
    	
    	/**
    	 * An Environment is a sandbox of schemas thats behavior is different from other environments.
    	 * 
    	 * @name Environment
    	 * @class
    	 */
    	
    	function Environment() {
    		this._id = randomUUID();
    		this._schemas = {};
    		this._options = {};
    		
    		this.createSchema({}, true, "urn:jsv:empty-schema#");
    	}
    	
    	/**
    	 * Returns a clone of the target environment.
    	 * 
    	 * @returns {Environment} A new {@link Environment} that is a exact copy of the target environment 
    	 */
    	
    	Environment.prototype.clone = function () {
    		var env = new Environment();
    		env._schemas = createObject(this._schemas);
    		env._options = createObject(this._options);
    		
    		return env;
    	};
    	
    	/**
    	 * Returns a new {@link JSONInstance} of the provided data.
    	 * 
    	 * @param {JSONInstance|Any} data The value of the instance
    	 * @param {String} [uri] The URI of the instance. If undefined, the URI will be a randomly generated UUID. 
    	 * @returns {JSONInstance} A new {@link JSONInstance} from the provided data
    	 */
    	
    	Environment.prototype.createInstance = function (data, uri) {
    		uri = formatURI(uri);
    		
    		if (data instanceof JSONInstance && (!uri || data.getURI() === uri)) {
    			return data;
    		}
    
    		return new JSONInstance(this, data, uri);
    	};
    	
    	/**
    	 * Creates a new {@link JSONSchema} from the provided data, and registers it with the environment. 
    	 * 
    	 * @param {JSONInstance|Any} data The value of the schema
    	 * @param {JSONSchema|Boolean} [schema] The schema to bind to the instance. If <code>undefined</code>, the environment's default schema will be used. If <code>true</code>, the instance's schema will be itself.
    	 * @param {String} [uri] The URI of the schema. If undefined, the URI will be a randomly generated UUID. 
    	 * @returns {JSONSchema} A new {@link JSONSchema} from the provided data
    	 * @throws {InitializationError} If a schema that is not registered with the environment is referenced 
    	 */
    	
    	Environment.prototype.createSchema = function (data, schema, uri) {
    		uri = formatURI(uri);
    		
    		if (data instanceof JSONSchema && (!uri || data._uri === uri) && (!schema || data.getSchema().equals(schema))) {
    			return data;
    		}
    		
    		return new JSONSchema(this, data, uri, schema);
    	};
    	
    	/**
    	 * Creates an empty schema.
    	 * 
    	 * @returns {JSONSchema} The empty schema, who's schema is itself.
    	 */
    	
    	Environment.prototype.createEmptySchema = function () {
    		return this._schemas["urn:jsv:empty-schema#"];
    	};
    	
    	/**
    	 * Returns the schema registered with the provided URI.
    	 * 
    	 * @param {String} uri The absolute URI of the required schema
    	 * @returns {JSONSchema|undefined} The request schema, or <code>undefined</code> if not found
    	 */
    	
    	Environment.prototype.findSchema = function (uri) {
    		return this._schemas[formatURI(uri)];
    	};
    	
    	/**
    	 * Sets the specified environment option to the specified value.
    	 * 
    	 * @param {String} name The name of the environment option to set
    	 * @param {Any} value The new value of the environment option
    	 */
    	
    	Environment.prototype.setOption = function (name, value) {
    		this._options[name] = value;
    	};
    	
    	/**
    	 * Returns the specified environment option.
    	 * 
    	 * @param {String} name The name of the environment option to set
    	 * @returns {Any} The value of the environment option
    	 */
    	
    	Environment.prototype.getOption = function (name) {
    		return this._options[name];
    	};
    	
    	/**
    	 * Sets the default fragment delimiter of the environment.
    	 * 
    	 * @deprecated Use {@link Environment#setOption} with option "defaultFragmentDelimiter"
    	 * @param {String} fd The fragment delimiter character
    	 */
    	
    	Environment.prototype.setDefaultFragmentDelimiter = function (fd) {
    		if (typeof fd === "string" && fd.length > 0) {
    			this._options["defaultFragmentDelimiter"] = fd;
    		}
    	};
    	
    	/**
    	 * Returns the default fragment delimiter of the environment.
    	 * 
    	 * @deprecated Use {@link Environment#getOption} with option "defaultFragmentDelimiter"
    	 * @returns {String} The fragment delimiter character
    	 */
    	
    	Environment.prototype.getDefaultFragmentDelimiter = function () {
    		return this._options["defaultFragmentDelimiter"];
    	};
    	
    	/**
    	 * Sets the URI of the default schema for the environment.
    	 * 
    	 * @deprecated Use {@link Environment#setOption} with option "defaultSchemaURI"
    	 * @param {String} uri The default schema URI
    	 */
    	
    	Environment.prototype.setDefaultSchemaURI = function (uri) {
    		if (typeof uri === "string") {
    			this._options["defaultSchemaURI"] = formatURI(uri);
    		}
    	};
    	
    	/**
    	 * Returns the default schema of the environment.
    	 * 
    	 * @returns {JSONSchema} The default schema
    	 */
    	
    	Environment.prototype.getDefaultSchema = function () {
    		return this.findSchema(this._options["defaultSchemaURI"]);
    	};
    	
    	/**
    	 * Validates both the provided schema and the provided instance, and returns a {@link Report}. 
    	 * If the schema fails to validate, the instance will not be validated.
    	 * 
    	 * @param {JSONInstance|Any} instanceJSON The {@link JSONInstance} or JavaScript value to validate.
    	 * @param {JSONSchema|Any} schemaJSON The {@link JSONSchema} or JavaScript value to use in the validation. This will also be validated againt the schema's schema.
    	 * @returns {Report} The result of the validation
    	 */
    	
    	Environment.prototype.validate = function (instanceJSON, schemaJSON) {
    		var instance,
    			schema,
    			schemaSchema,
    			report = new Report();
    		
    		try {
    			instance = this.createInstance(instanceJSON);
    			report.instance = instance;
    		} catch (e) {
    			report.addError(e.uri, e.schemaUri, e.attribute, e.message, e.details);
    		}
    		
    		try {
    			schema = this.createSchema(schemaJSON);
    			report.schema = schema;
    			
    			schemaSchema = schema.getSchema();
    			report.schemaSchema = schemaSchema;
    		} catch (f) {
    			report.addError(f.uri, f.schemaUri, f.attribute, f.message, f.details);
    		}
    		
    		if (schemaSchema) {
    			schemaSchema.validate(schema, report);
    		}
    			
    		if (report.errors.length) {
    			return report;
    		}
    		
    		return schema.validate(instance, report);
    	};
    	
    	/**
    	 * @private
    	 */
    	
    	Environment.prototype._checkForInvalidInstances = function (stackSize, schemaURI) {
    		var result = [],
    			stack = [
    				[schemaURI, this._schemas[schemaURI]]
    			], 
    			counter = 0,
    			item, uri, instance, properties, key;
    		
    		while (counter++ < stackSize && stack.length) {
    			item = stack.shift();
    			uri = item[0];
    			instance = item[1];
    			
    			if (instance instanceof JSONSchema) {
    				if (this._schemas[instance._uri] !== instance) {
    					result.push("Instance " + uri + " does not match " + instance._uri);
    				} else {
    					//schema = instance.getSchema();
    					//stack.push([uri + "/{schema}", schema]);
    					
    					properties = instance.getAttributes();
    					for (key in properties) {
    						if (properties[key] !== O[key]) {
    							stack.push([uri + "/" + escapeURIComponent(key), properties[key]]);
    						}
    					}
    				}
    			} else if (typeOf(instance) === "object") {
    				properties = instance;
    				for (key in properties) {
    					if (properties.hasOwnProperty(key)) {
    						stack.push([uri + "/" + escapeURIComponent(key), properties[key]]);
    					}
    				}
    			} else if (typeOf(instance) === "array") {
    				properties = instance;
    				for (key = 0; key < properties.length; ++key) {
    					stack.push([uri + "/" + escapeURIComponent(key), properties[key]]);
    				}
    			}
    		}
    		
    		return result.length ? result : counter;
    	};
    	
    	/**
    	 * A globaly accessible object that provides the ability to create and manage {@link Environments},
    	 * as well as providing utility methods.
    	 * 
    	 * @namespace
    	 */
    	
    	JSV = {
    		_environments : {},
    		_defaultEnvironmentID : "",
    		
    		/**
    		 * Returns if the provide value is an instance of {@link JSONInstance}.
    		 * 
    		 * @param o The value to test
    		 * @returns {Boolean} If the provide value is an instance of {@link JSONInstance}
    		 */
    		
    		isJSONInstance : function (o) {
    			return o instanceof JSONInstance;
    		},
    		
    		/**
    		 * Returns if the provide value is an instance of {@link JSONSchema}.
    		 * 
    		 * @param o The value to test
    		 * @returns {Boolean} If the provide value is an instance of {@link JSONSchema}
    		 */
    		
    		isJSONSchema : function (o) {
    			return o instanceof JSONSchema;
    		},
    		
    		/**
    		 * Creates and returns a new {@link Environment} that is a clone of the environment registered with the provided ID.
    		 * If no environment ID is provided, the default environment is cloned.
    		 * 
    		 * @param {String} [id] The ID of the environment to clone. If <code>undefined</code>, the default environment ID is used.
    		 * @returns {Environment} A newly cloned {@link Environment}
    		 * @throws {Error} If there is no environment registered with the provided ID
    		 */
    		
    		createEnvironment : function (id) {
    			id = id || this._defaultEnvironmentID;
    			
    			if (!this._environments[id]) {
    				throw new Error("Unknown Environment ID");
    			}
    			//else
    			return this._environments[id].clone();
    		},
    		
    		Environment : Environment,
    		
    		/**
    		 * Registers the provided {@link Environment} with the provided ID.
    		 * 
    		 * @param {String} id The ID of the environment
    		 * @param {Environment} env The environment to register
    		 */
    		
    		registerEnvironment : function (id, env) {
    			id = id || (env || 0)._id;
    			if (id && !this._environments[id] && env instanceof Environment) {
    				env._id = id;
    				this._environments[id] = env;
    			}
    		},
    		
    		/**
    		 * Sets which registered ID is the default environment.
    		 * 
    		 * @param {String} id The ID of the registered environment that is default
    		 * @throws {Error} If there is no registered environment with the provided ID
    		 */
    		
    		setDefaultEnvironmentID : function (id) {
    			if (typeof id === "string") {
    				if (!this._environments[id]) {
    					throw new Error("Unknown Environment ID");
    				}
    				
    				this._defaultEnvironmentID = id;
    			}
    		},
    		
    		/**
    		 * Returns the ID of the default environment.
    		 * 
    		 * @returns {String} The ID of the default environment
    		 */
    		
    		getDefaultEnvironmentID : function () {
    			return this._defaultEnvironmentID;
    		},
    		
    		//
    		// Utility Functions
    		//
    		
    		/**
    		 * Returns the name of the type of the provided value.
    		 *
    		 * @event //utility
    		 * @param {Any} o The value to determine the type of
    		 * @returns {String} The name of the type of the value
    		 */
    		typeOf : typeOf,
    		
    		/**
    		 * Return a new object that inherits all of the properties of the provided object.
    		 *
    		 * @event //utility
    		 * @param {Object} proto The prototype of the new object
    		 * @returns {Object} A new object that inherits all of the properties of the provided object
    		 */
    		createObject : createObject,
    		
    		/**
    		 * Returns a new object with each property transformed by the iterator.
    		 *
    		 * @event //utility
    		 * @param {Object} obj The object to transform
    		 * @param {Function} iterator A function that returns the new value of the provided property
    		 * @param {Object} [scope] The value of <code>this</code> in the iterator
    		 * @returns {Object} A new object with each property transformed
    		 */
    		mapObject : mapObject,
    		
    		/**
    		 * Returns a new array with each item transformed by the iterator.
    		 * 
    		 * @event //utility
    		 * @param {Array} arr The array to transform
    		 * @param {Function} iterator A function that returns the new value of the provided item
    		 * @param {Object} scope The value of <code>this</code> in the iterator
    		 * @returns {Array} A new array with each item transformed
    		 */
    		mapArray : mapArray,
    		
    		/**
    		 * Returns a new array that only contains the items allowed by the iterator.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to filter
    		 * @param {Function} iterator The function that returns true if the provided property should be added to the array
    		 * @param {Object} scope The value of <code>this</code> within the iterator
    		 * @returns {Array} A new array that contains the items allowed by the iterator
    		 */
    		filterArray : filterArray,
    		
    		/**
    		 * Returns the first index in the array that the provided item is located at.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to search
    		 * @param {Any} o The item being searched for
    		 * @returns {Number} The index of the item in the array, or <code>-1</code> if not found
    		 */
    		searchArray : searchArray,
    			
    		/**
    		 * Returns an array representation of a value.
    		 * <ul>
    		 * <li>For array-like objects, the value will be casted as an Array type.</li>
    		 * <li>If an array is provided, the function will simply return the same array.</li>
    		 * <li>For a null or undefined value, the result will be an empty Array.</li>
    		 * <li>For all other values, the value will be the first element in a new Array. </li>
    		 * </ul>
    		 *
    		 * @event //utility
    		 * @param {Any} o The value to convert into an array
    		 * @returns {Array} The value as an array
    		 */
    		toArray : toArray,
    		
    		/**
    		 * Returns an array of the names of all properties of an object.
    		 * 
    		 * @event //utility
    		 * @param {Object|Array} o The object in question
    		 * @returns {Array} The names of all properties
    		 */
    		keys : keys,
    		
    		/**
    		 * Mutates the array by pushing the provided value onto the array only if it is not already there.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to modify
    		 * @param {Any} o The object to add to the array if it is not already there
    		 * @returns {Array} The provided array for chaining
    		 */
    		pushUnique : pushUnique,
    		
    		/**
    		 * Mutates the array by removing the first item that matches the provided value in the array.
    		 *
    		 * @event //utility
    		 * @param {Array} arr The array to modify
    		 * @param {Any} o The object to remove from the array
    		 * @returns {Array} The provided array for chaining
    		 */
    		popFirst : popFirst,
    		
    		/**
    		 * Creates a copy of the target object.
    		 * <p>
    		 * This method will create a new instance of the target, and then mixin the properties of the target.
    		 * If <code>deep</code> is <code>true</code>, then each property will be cloned before mixin.
    		 * </p>
    		 * <p><b>Warning</b>: This is not a generic clone function, as it will only properly clone objects and arrays.</p>
    		 * 
    		 * @event //utility
    		 * @param {Any} o The value to clone 
    		 * @param {Boolean} [deep=false] If each property should be recursively cloned
    		 * @returns A cloned copy of the provided value
    		 */
    		clone : clone,
    		
    		/**
    		 * Generates a pseudo-random UUID.
    		 * 
    		 * @event //utility
    		 * @returns {String} A new universally unique ID
    		 */
    		randomUUID : randomUUID,
    		
    		/**
    		 * Properly escapes a URI component for embedding into a URI string.
    		 * 
    		 * @event //utility
    		 * @param {String} str The URI component to escape
    		 * @returns {String} The escaped URI component
    		 */
    		escapeURIComponent : escapeURIComponent,
    		
    		/**
    		 * Returns a URI that is formated for JSV. Currently, this only ensures that the URI ends with a hash tag (<code>#</code>).
    		 * 
    		 * @event //utility
    		 * @param {String} uri The URI to format
    		 * @returns {String} The URI formatted for JSV
    		 */
    		formatURI : formatURI,
    		
    		/**
    		 * Merges two schemas/instance together.
    		 * 
    		 * @event //utility
    		 * @param {JSONSchema|Any} base The old value to merge
    		 * @param {JSONSchema|Any} extra The new value to merge
    		 * @param {Boolean} extension If the merge is a JSON Schema extension
    		 * @return {Any} The modified base value
    		 */
    		 
    		inherits : inherits,
    		
    		/**
    		 * @private
    		 * @event //utility
    		 */
    		
    		InitializationError : InitializationError
    	};
    	
    	this.JSV = JSV;  //set global object
    	exports.JSV = JSV;  //export to CommonJS
    	
    	 require('JSV/lib/environments');  //load default environments
    	
    }());
  provide("JSV", module.exports);
}(global));

// pakmanager:ms
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options.long
        ? long(val)
        : short(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      str = '' + str;
      if (str.length > 10000) return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function long(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
  provide("ms", module.exports);
}(global));

// pakmanager:optimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var minimist = require('minimist');
    var wordwrap = require('wordwrap');
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
             require('optimist')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
             require('optimist').argv
        to get a parsed version of process.argv.
    */
    
    var inst = Argv(process.argv.slice(2));
    Object.keys(inst).forEach(function (key) {
        Argv[key] = typeof inst[key] == 'function'
            ? inst[key].bind(inst)
            : inst[key];
    });
    
    var exports = module.exports = Argv;
    function Argv (processArgs, cwd) {
        var self = {};
        if (!cwd) cwd = process.cwd();
        
        self.$0 = process.argv
            .slice(0,2)
            .map(function (x) {
                var b = rebase(cwd, x);
                return x.match(/^\//) && b.length < x.length
                    ? b : x
            })
            .join(' ')
        ;
        
        if (process.env._ != undefined && process.argv[1] == process.env._) {
            self.$0 = process.env._.replace(
                path.dirname(process.execPath) + '/', ''
            );
        }
        
        var options = {
            boolean: [],
            string: [],
            alias: {},
            default: []
        };
        
        self.boolean = function (bools) {
            options.boolean.push.apply(options.boolean, [].concat(bools));
            return self;
        };
        
        self.string = function (strings) {
            options.string.push.apply(options.string, [].concat(strings));
            return self;
        };
        
        self.default = function (key, value) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.default(k, key[k]);
                });
            }
            else {
                options.default[key] = value;
            }
            return self;
        };
        
        self.alias = function (x, y) {
            if (typeof x === 'object') {
                Object.keys(x).forEach(function (key) {
                    self.alias(key, x[key]);
                });
            }
            else {
                options.alias[x] = (options.alias[x] || []).concat(y);
            }
            return self;
        };
        
        var demanded = {};
        self.demand = function (keys) {
            if (typeof keys == 'number') {
                if (!demanded._) demanded._ = 0;
                demanded._ += keys;
            }
            else if (Array.isArray(keys)) {
                keys.forEach(function (key) {
                    self.demand(key);
                });
            }
            else {
                demanded[keys] = true;
            }
            
            return self;
        };
        
        var usage;
        self.usage = function (msg, opts) {
            if (!opts && typeof msg === 'object') {
                opts = msg;
                msg = null;
            }
            
            usage = msg;
            
            if (opts) self.options(opts);
            
            return self;
        };
        
        function fail (msg) {
            self.showHelp();
            if (msg) console.error(msg);
            process.exit(1);
        }
        
        var checks = [];
        self.check = function (f) {
            checks.push(f);
            return self;
        };
        
        var descriptions = {};
        self.describe = function (key, desc) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.describe(k, key[k]);
                });
            }
            else {
                descriptions[key] = desc;
            }
            return self;
        };
        
        self.parse = function (args) {
            return parseArgs(args);
        };
        
        self.option = self.options = function (key, opt) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.options(k, key[k]);
                });
            }
            else {
                if (opt.alias) self.alias(key, opt.alias);
                if (opt.demand) self.demand(key);
                if (typeof opt.default !== 'undefined') {
                    self.default(key, opt.default);
                }
                
                if (opt.boolean || opt.type === 'boolean') {
                    self.boolean(key);
                }
                if (opt.string || opt.type === 'string') {
                    self.string(key);
                }
                
                var desc = opt.describe || opt.description || opt.desc;
                if (desc) {
                    self.describe(key, desc);
                }
            }
            
            return self;
        };
        
        var wrap = null;
        self.wrap = function (cols) {
            wrap = cols;
            return self;
        };
        
        self.showHelp = function (fn) {
            if (!fn) fn = console.error;
            fn(self.help());
        };
        
        self.help = function () {
            var keys = Object.keys(
                Object.keys(descriptions)
                .concat(Object.keys(demanded))
                .concat(Object.keys(options.default))
                .reduce(function (acc, key) {
                    if (key !== '_') acc[key] = true;
                    return acc;
                }, {})
            );
            
            var help = keys.length ? [ 'Options:' ] : [];
            
            if (usage) {
                help.unshift(usage.replace(/\$0/g, self.$0), '');
            }
            
            var switches = keys.reduce(function (acc, key) {
                acc[key] = [ key ].concat(options.alias[key] || [])
                    .map(function (sw) {
                        return (sw.length > 1 ? '--' : '-') + sw
                    })
                    .join(', ')
                ;
                return acc;
            }, {});
            
            var switchlen = longest(Object.keys(switches).map(function (s) {
                return switches[s] || '';
            }));
            
            var desclen = longest(Object.keys(descriptions).map(function (d) { 
                return descriptions[d] || '';
            }));
            
            keys.forEach(function (key) {
                var kswitch = switches[key];
                var desc = descriptions[key] || '';
                
                if (wrap) {
                    desc = wordwrap(switchlen + 4, wrap)(desc)
                        .slice(switchlen + 4)
                    ;
                }
                
                var spadding = new Array(
                    Math.max(switchlen - kswitch.length + 3, 0)
                ).join(' ');
                
                var dpadding = new Array(
                    Math.max(desclen - desc.length + 1, 0)
                ).join(' ');
                
                var type = null;
                
                if (options.boolean[key]) type = '[boolean]';
                if (options.string[key]) type = '[string]';
                
                if (!wrap && dpadding.length > 0) {
                    desc += dpadding;
                }
                
                var prelude = '  ' + kswitch + spadding;
                var extra = [
                    type,
                    demanded[key]
                        ? '[required]'
                        : null
                    ,
                    options.default[key] !== undefined
                        ? '[default: ' + JSON.stringify(options.default[key]) + ']'
                        : null
                    ,
                ].filter(Boolean).join('  ');
                
                var body = [ desc, extra ].filter(Boolean).join('  ');
                
                if (wrap) {
                    var dlines = desc.split('\n');
                    var dlen = dlines.slice(-1)[0].length
                        + (dlines.length === 1 ? prelude.length : 0)
                    
                    body = desc + (dlen + extra.length > wrap - 2
                        ? '\n'
                            + new Array(wrap - extra.length + 1).join(' ')
                            + extra
                        : new Array(wrap - extra.length - dlen + 1).join(' ')
                            + extra
                    );
                }
                
                help.push(prelude + body);
            });
            
            help.push('');
            return help.join('\n');
        };
        
        Object.defineProperty(self, 'argv', {
            get : function () { return parseArgs(processArgs) },
            enumerable : true,
        });
        
        function parseArgs (args) {
            var argv = minimist(args, options);
            argv.$0 = self.$0;
            
            if (demanded._ && argv._.length < demanded._) {
                fail('Not enough non-option arguments: got '
                    + argv._.length + ', need at least ' + demanded._
                );
            }
            
            var missing = [];
            Object.keys(demanded).forEach(function (key) {
                if (!argv[key]) missing.push(key);
            });
            
            if (missing.length) {
                fail('Missing required arguments: ' + missing.join(', '));
            }
            
            checks.forEach(function (f) {
                try {
                    if (f(argv) === false) {
                        fail('Argument check failed: ' + f.toString());
                    }
                }
                catch (err) {
                    fail(err)
                }
            });
            
            return argv;
        }
        
        function longest (xs) {
            return Math.max.apply(
                null,
                xs.map(function (x) { return x.length })
            );
        }
        
        return self;
    };
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase;
    function rebase (base, dir) {
        var ds = path.normalize(dir).split('/').slice(1);
        var bs = path.normalize(base).split('/').slice(1);
        
        for (var i = 0; ds[i] && ds[i] == bs[i]; i++);
        ds.splice(0, i); bs.splice(0, i);
        
        var p = path.normalize(
            bs.map(function () { return '..' }).concat(ds).join('/')
        ).replace(/\/$/,'').replace(/^$/, '.');
        return p.match(/^[.\/]/) ? p : './' + p;
    };
    
  provide("optimist", module.exports);
}(global));

// pakmanager:uglify-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require("path");
    var fs = require("fs");
    var vm = require("vm");
    
    var UglifyJS = vm.createContext({
        console       : console,
        process       : process,
        Buffer        : Buffer,
        MOZ_SourceMap : require("source-map")
    });
    
    function load_global(file) {
        file = path.resolve(path.dirname(module.filename), file);
        try {
            var code = fs.readFileSync(file, "utf8");
            return vm.runInContext(code, UglifyJS, file);
        } catch(ex) {
            // XXX: in case of a syntax error, the message is kinda
            // useless. (no location information).
            console.log("ERROR in file: " + file + " / " + ex);
            process.exit(1);
        }
    };
    
    var FILES = exports.FILES = [
        "../lib/utils.js",
        "../lib/ast.js",
        "../lib/parse.js",
        "../lib/transform.js",
        "../lib/scope.js",
        "../lib/output.js",
        "../lib/compress.js",
        "../lib/sourcemap.js",
        "../lib/mozilla-ast.js",
        "../lib/propmangle.js"
    ].map(function(file){
        return fs.realpathSync(path.join(path.dirname(__filename), file));
    });
    
    FILES.forEach(load_global);
    
    UglifyJS.AST_Node.warn_function = function(txt) {
        console.error("WARN: %s", txt);
    };
    
    // XXX: perhaps we shouldn't export everything but heck, I'm lazy.
    for (var i in UglifyJS) {
        if (UglifyJS.hasOwnProperty(i)) {
            exports[i] = UglifyJS[i];
        }
    }
    
    exports.minify = function(files, options) {
        options = UglifyJS.defaults(options, {
            spidermonkey : false,
            outSourceMap : null,
            sourceRoot   : null,
            inSourceMap  : null,
            fromString   : false,
            warnings     : false,
            mangle       : {},
            output       : null,
            compress     : {}
        });
        UglifyJS.base54.reset();
    
        // 1. parse
        var toplevel = null,
            sourcesContent = {};
    
        if (options.spidermonkey) {
            toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
        } else {
            if (typeof files == "string")
                files = [ files ];
            files.forEach(function(file){
                var code = options.fromString
                    ? file
                    : fs.readFileSync(file, "utf8");
                sourcesContent[file] = code;
                toplevel = UglifyJS.parse(code, {
                    filename: options.fromString ? "?" : file,
                    toplevel: toplevel
                });
            });
        }
    
        // 2. compress
        if (options.compress) {
            var compress = { warnings: options.warnings };
            UglifyJS.merge(compress, options.compress);
            toplevel.figure_out_scope();
            var sq = UglifyJS.Compressor(compress);
            toplevel = toplevel.transform(sq);
        }
    
        // 3. mangle
        if (options.mangle) {
            toplevel.figure_out_scope(options.mangle);
            toplevel.compute_char_frequency(options.mangle);
            toplevel.mangle_names(options.mangle);
        }
    
        // 4. output
        var inMap = options.inSourceMap;
        var output = {};
        if (typeof options.inSourceMap == "string") {
            inMap = fs.readFileSync(options.inSourceMap, "utf8");
        }
        if (options.outSourceMap) {
            output.source_map = UglifyJS.SourceMap({
                file: options.outSourceMap,
                orig: inMap,
                root: options.sourceRoot
            });
            if (options.sourceMapIncludeSources) {
                for (var file in sourcesContent) {
                    if (sourcesContent.hasOwnProperty(file)) {
                        output.source_map.get().setSourceContent(file, sourcesContent[file]);
                    }
                }
            }
    
        }
        if (options.output) {
            UglifyJS.merge(output, options.output);
        }
        var stream = UglifyJS.OutputStream(output);
        toplevel.print(stream);
    
        if(options.outSourceMap){
            stream += "\n//# sourceMappingURL=" + options.outSourceMap;
        }
    
        var source_map = output.source_map;
        if (source_map) {
            source_map = source_map + "";
        }
    
        return {
            code : stream + "",
            map  : source_map
        };
    };
    
    // exports.describe_ast = function() {
    //     function doitem(ctor) {
    //         var sub = {};
    //         ctor.SUBCLASSES.forEach(function(ctor){
    //             sub[ctor.TYPE] = doitem(ctor);
    //         });
    //         var ret = {};
    //         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
    //         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
    //         return ret;
    //     }
    //     return doitem(UglifyJS.AST_Node).sub;
    // }
    
    exports.describe_ast = function() {
        var out = UglifyJS.OutputStream({ beautify: true });
        function doitem(ctor) {
            out.print("AST_" + ctor.TYPE);
            var props = ctor.SELF_PROPS.filter(function(prop){
                return !/^\$/.test(prop);
            });
            if (props.length > 0) {
                out.space();
                out.with_parens(function(){
                    props.forEach(function(prop, i){
                        if (i) out.space();
                        out.print(prop);
                    });
                });
            }
            if (ctor.documentation) {
                out.space();
                out.print_string(ctor.documentation);
            }
            if (ctor.SUBCLASSES.length > 0) {
                out.space();
                out.with_block(function(){
                    ctor.SUBCLASSES.forEach(function(ctor, i){
                        out.indent();
                        doitem(ctor);
                        out.newline();
                    });
                });
            }
        };
        doitem(UglifyJS.AST_Node);
        return out + "";
    };
    
    function readReservedFile(filename, reserved) {
        if (!reserved) {
            reserved = { vars: [], props: [] };
        }
        var data = fs.readFileSync(filename, "utf8");
        data = JSON.parse(data);
        if (data.vars) {
            data.vars.forEach(function(name){
                UglifyJS.push_uniq(reserved.vars, name);
            });
        }
        if (data.props) {
            data.props.forEach(function(name){
                UglifyJS.push_uniq(reserved.props, name);
            });
        }
        return reserved;
    }
    
    exports.readReservedFile = readReservedFile;
    
    exports.readDefaultReservedFile = function(reserved) {
        return readReservedFile(path.join(__dirname, "domprops.json"), reserved);
    };
    
    exports.readNameCache = function(filename, key) {
        var cache = null;
        if (filename) {
            try {
                var cache = fs.readFileSync(filename, "utf8");
                cache = JSON.parse(cache)[key];
                if (!cache) throw "init";
                cache.props = UglifyJS.Dictionary.fromObject(cache.props);
            } catch(ex) {
                cache = {
                    cname: -1,
                    props: new UglifyJS.Dictionary()
                };
            }
        }
        return cache;
    };
    
    exports.writeNameCache = function(filename, key, cache) {
        if (filename) {
            var data;
            try {
                data = fs.readFileSync(filename, "utf8");
                data = JSON.parse(data);
            } catch(ex) {
                data = {};
            }
            data[key] = {
                cname: cache.cname,
                props: cache.props.toObject()
            };
            fs.writeFileSync(filename, JSON.stringify(data, null, 2), "utf8");
        }
    };
    
  provide("uglify-js", module.exports);
}(global));

// pakmanager:mute-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream')
    
    module.exports = MuteStream
    
    // var out = new MuteStream(process.stdout)
    // argument auto-pipes
    function MuteStream (opts) {
      Stream.apply(this)
      opts = opts || {}
      this.writable = this.readable = true
      this.muted = false
      this.on('pipe', this._onpipe)
      this.replace = opts.replace
    
      // For readline-type situations
      // This much at the start of a line being redrawn after a ctrl char
      // is seen (such as backspace) won't be redrawn as the replacement
      this._prompt = opts.prompt || null
      this._hadControl = false
    }
    
    MuteStream.prototype = Object.create(Stream.prototype)
    
    Object.defineProperty(MuteStream.prototype, 'constructor', {
      value: MuteStream,
      enumerable: false
    })
    
    MuteStream.prototype.mute = function () {
      this.muted = true
    }
    
    MuteStream.prototype.unmute = function () {
      this.muted = false
    }
    
    Object.defineProperty(MuteStream.prototype, '_onpipe', {
      value: onPipe,
      enumerable: false,
      writable: true,
      configurable: true
    })
    
    function onPipe (src) {
      this._src = src
    }
    
    Object.defineProperty(MuteStream.prototype, 'isTTY', {
      get: getIsTTY,
      set: setIsTTY,
      enumerable: true,
      configurable: true
    })
    
    function getIsTTY () {
      return( (this._dest) ? this._dest.isTTY
            : (this._src) ? this._src.isTTY
            : false
            )
    }
    
    // basically just get replace the getter/setter with a regular value
    function setIsTTY (isTTY) {
      Object.defineProperty(this, 'isTTY', {
        value: isTTY,
        enumerable: true,
        writable: true,
        configurable: true
      })
    }
    
    Object.defineProperty(MuteStream.prototype, 'rows', {
      get: function () {
        return( this._dest ? this._dest.rows
              : this._src ? this._src.rows
              : undefined )
      }, enumerable: true, configurable: true })
    
    Object.defineProperty(MuteStream.prototype, 'columns', {
      get: function () {
        return( this._dest ? this._dest.columns
              : this._src ? this._src.columns
              : undefined )
      }, enumerable: true, configurable: true })
    
    
    MuteStream.prototype.pipe = function (dest) {
      this._dest = dest
      return Stream.prototype.pipe.call(this, dest)
    }
    
    MuteStream.prototype.pause = function () {
      if (this._src) return this._src.pause()
    }
    
    MuteStream.prototype.resume = function () {
      if (this._src) return this._src.resume()
    }
    
    MuteStream.prototype.write = function (c) {
      if (this.muted) {
        if (!this.replace) return true
        if (c.match(/^\u001b/)) {
          this._hadControl = true
          return this.emit('data', c)
        } else {
          if (this._prompt && this._hadControl &&
              c.indexOf(this._prompt) === 0) {
            this._hadControl = false
            this.emit('data', this._prompt)
            c = c.substr(this._prompt.length)
          }
          c = c.toString().replace(/./g, this.replace)
        }
      }
      this.emit('data', c)
    }
    
    MuteStream.prototype.end = function (c) {
      if (this.muted) {
        if (c && this.replace) {
          c = c.toString().replace(/./g, this.replace)
        } else {
          c = null
        }
      }
      if (c) this.emit('data', c)
      this.emit('end')
    }
    
    function proxy (fn) { return function () {
      var d = this._dest
      var s = this._src
      if (d && d[fn]) d[fn].apply(d, arguments)
      if (s && s[fn]) s[fn].apply(s, arguments)
    }}
    
    MuteStream.prototype.destroy = proxy('destroy')
    MuteStream.prototype.destroySoon = proxy('destroySoon')
    MuteStream.prototype.close = proxy('close')
    
  provide("mute-stream", module.exports);
}(global));

// pakmanager:deep-equal/lib/keys.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports = module.exports = typeof Object.keys === 'function'
      ? Object.keys : shim;
    
    exports.shim = shim;
    function shim (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    
  provide("deep-equal/lib/keys.js", module.exports);
}(global));

// pakmanager:deep-equal/lib/is_arguments.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var supportsArgumentsClass = (function(){
      return Object.prototype.toString.call(arguments)
    })() == '[object Arguments]';
    
    exports = module.exports = supportsArgumentsClass ? supported : unsupported;
    
    exports.supported = supported;
    function supported(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    };
    
    exports.unsupported = unsupported;
    function unsupported(object){
      return object &&
        typeof object == 'object' &&
        typeof object.length == 'number' &&
        Object.prototype.hasOwnProperty.call(object, 'callee') &&
        !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
        false;
    };
    
  provide("deep-equal/lib/is_arguments.js", module.exports);
}(global));

// pakmanager:deep-equal
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var pSlice = Array.prototype.slice;
    var objectKeys =  require('deep-equal/lib/keys.js');
    var isArguments =  require('deep-equal/lib/is_arguments.js');
    
    var deepEqual = module.exports = function (actual, expected, opts) {
      if (!opts) opts = {};
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;
    
      } else if (actual instanceof Date && expected instanceof Date) {
        return actual.getTime() === expected.getTime();
    
      // 7.3. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (typeof actual != 'object' && typeof expected != 'object') {
        return opts.strict ? actual === expected : actual == expected;
    
      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected, opts);
      }
    }
    
    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }
    
    function isBuffer (x) {
      if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== 'number') return false;
      return true;
    }
    
    function objEquiv(a, b, opts) {
      var i, key;
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (isArguments(a)) {
        if (!isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return deepEqual(a, b, opts);
      }
      if (isBuffer(a)) {
        if (!isBuffer(b)) {
          return false;
        }
        if (a.length !== b.length) return false;
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }
      try {
        var ka = objectKeys(a),
            kb = objectKeys(b);
      } catch (e) {//happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) return false;
      }
      return typeof a === typeof b;
    }
    
  provide("deep-equal", module.exports);
}(global));

// pakmanager:i/lib/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Some utility functions in js
    
    var u = module.exports = {
      array: {
        // Returns a copy of the array with the value removed once
        //
        //     [1, 2, 3, 1].del 1 #=> [2, 3, 1]
        //     [1, 2, 3].del 4    #=> [1, 2, 3]
        del: function (arr, val) {
          var index = arr.indexOf(val);
          if (index != -1) {
            if (index == 0) {
             return arr.slice(1)
            } else {
              return arr.slice(0, index).concat(arr.slice(index+1));
            }
          } else {
            return arr;
          }
        },
    
        // Returns the first element of the array
        //
        //     [1, 2, 3].first() #=> 1
        first: function(arr) {
          return arr[0];
        },
    
        // Returns the last element of the array
        //
        //     [1, 2, 3].last()  #=> 3
        last: function(arr) {
          return arr[arr.length-1];
        }
      },
      string: {
        // Returns a copy of str with all occurrences of pattern replaced with either replacement or the return value of a function.
        // The pattern will typically be a Regexp; if it is a String then no regular expression metacharacters will be interpreted
        // (that is /\d/ will match a digit, but \d will match a backslash followed by a d).
        //
        // In the function form, the current match object is passed in as a parameter to the function, and variables such as
        // $[1], $[2], $[3] (where $ is the match object) will be set appropriately. The value returned by the function will be
        // substituted for the match on each call.
        //
        // The result inherits any tainting in the original string or any supplied replacement string.
        //
        //     "hello".gsub /[aeiou]/, '*'      #=> "h*ll*"
        //     "hello".gsub /[aeiou]/, '<$1>'   #=> "h<e>ll<o>"
        //     "hello".gsub /[aeiou]/, ($) {
        //       "<#{$[1]}>"                    #=> "h<e>ll<o>"
        //
        gsub: function (str, pattern, replacement) {
          var i, match, matchCmpr, matchCmprPrev, replacementStr, result, self;
          if (!((pattern != null) && (replacement != null))) return u.string.value(str);
          result = '';
          self = str;
          while (self.length > 0) {
            if ((match = self.match(pattern))) {
              result += self.slice(0, match.index);
              if (typeof replacement === 'function') {
                match[1] = match[1] || match[0];
                result += replacement(match);
              } else if (replacement.match(/\$[1-9]/)) {
                matchCmprPrev = match;
                matchCmpr = u.array.del(match, void 0);
                while (matchCmpr !== matchCmprPrev) {
                  matchCmprPrev = matchCmpr;
                  matchCmpr = u.array.del(matchCmpr, void 0);
                }
                match[1] = match[1] || match[0];
                replacementStr = replacement;
                for (i = 1; i <= 9; i++) {
                  if (matchCmpr[i]) {
                    replacementStr = u.string.gsub(replacementStr, new RegExp("\\\$" + i), matchCmpr[i]);
                  }
                }
                result += replacementStr;
              } else {
                result += replacement;
              }
              self = self.slice(match.index + match[0].length);
            } else {
              result += self;
              self = '';
            }
          }
          return result;
        },
    
        // Returns a copy of the String with the first letter being upper case
        //
        //     "hello".upcase #=> "Hello"
        upcase: function(str) {
          var self = u.string.gsub(str, /_([a-z])/, function ($) {
            return "_" + $[1].toUpperCase();
          });
          self = u.string.gsub(self, /\/([a-z])/, function ($) {
            return "/" + $[1].toUpperCase();
          });
          return self[0].toUpperCase() + self.substr(1);
        },
    
        // Returns a copy of capitalized string
        //
        //     "employee salary" #=> "Employee Salary"
        capitalize: function (str, spaces) {
          var self = str.toLowerCase();
          if(!spaces) {
            self = u.string.gsub(self, /\s([a-z])/, function ($) {
              return " " + $[1].toUpperCase();
            });
          }
          return self[0].toUpperCase() + self.substr(1);
        },
    
        // Returns a copy of the String with the first letter being lower case
        //
        //     "HELLO".downcase #=> "hELLO"
        downcase: function(str) {
          var self = u.string.gsub(str, /_([A-Z])/, function ($) {
            return "_" + $[1].toLowerCase();
          });
          self = u.string.gsub(self, /\/([A-Z])/, function ($) {
            return "/" + $[1].toLowerCase();
          });
          return self[0].toLowerCase() + self.substr(1);
        },
    
        // Returns a string value for the String object
        //
        //     "hello".value() #=> "hello"
        value: function (str) {
          return str.substr(0);
        }
      }
    }
    
  provide("i/lib/util", module.exports);
}(global));

// pakmanager:i/lib/defaults
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Default inflections
    module.exports = function (inflect) {
    
      inflect.plural(/$/, 's');
      inflect.plural(/s$/i, 's');
      inflect.plural(/(ax|test)is$/i, '$1es');
      inflect.plural(/(octop|vir)us$/i, '$1i');
      inflect.plural(/(octop|vir)i$/i, '$1i');
      inflect.plural(/(alias|status)$/i, '$1es');
      inflect.plural(/(bu)s$/i, '$1ses');
      inflect.plural(/(buffal|tomat)o$/i, '$1oes');
      inflect.plural(/([ti])um$/i, '$1a');
      inflect.plural(/([ti])a$/i, '$1a');
      inflect.plural(/sis$/i, 'ses');
      inflect.plural(/(?:([^f])fe|([lr])f)$/i, '$1ves');
      inflect.plural(/(hive)$/i, '$1s');
      inflect.plural(/([^aeiouy]|qu)y$/i, '$1ies');
      inflect.plural(/(x|ch|ss|sh)$/i, '$1es');
      inflect.plural(/(matr|vert|ind)(?:ix|ex)$/i, '$1ices');
      inflect.plural(/([m|l])ouse$/i, '$1ice');
      inflect.plural(/([m|l])ice$/i, '$1ice');
      inflect.plural(/^(ox)$/i, '$1en');
      inflect.plural(/^(oxen)$/i, '$1');
      inflect.plural(/(quiz)$/i, '$1zes');
    
    
      inflect.singular(/s$/i, '');
      inflect.singular(/(n)ews$/i, '$1ews');
      inflect.singular(/([ti])a$/i, '$1um');
      inflect.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1sis');
      inflect.singular(/(^analy)ses$/i, '$1sis');
      inflect.singular(/([^f])ves$/i, '$1fe');
      inflect.singular(/(hive)s$/i, '$1');
      inflect.singular(/(tive)s$/i, '$1');
      inflect.singular(/([lr])ves$/i, '$1f');
      inflect.singular(/([^aeiouy]|qu)ies$/i, '$1y');
      inflect.singular(/(s)eries$/i, '$1eries');
      inflect.singular(/(m)ovies$/i, '$1ovie');
      inflect.singular(/(x|ch|ss|sh)es$/i, '$1');
      inflect.singular(/([m|l])ice$/i, '$1ouse');
      inflect.singular(/(bus)es$/i, '$1');
      inflect.singular(/(o)es$/i, '$1');
      inflect.singular(/(shoe)s$/i, '$1');
      inflect.singular(/(cris|ax|test)es$/i, '$1is');
      inflect.singular(/(octop|vir)i$/i, '$1us');
      inflect.singular(/(alias|status)es$/i, '$1');
      inflect.singular(/^(ox)en/i, '$1');
      inflect.singular(/(vert|ind)ices$/i, '$1ex');
      inflect.singular(/(matr)ices$/i, '$1ix');
      inflect.singular(/(quiz)zes$/i, '$1');
      inflect.singular(/(database)s$/i, '$1');
    
      inflect.irregular('child', 'children');
      inflect.irregular('person', 'people');
      inflect.irregular('man', 'men');
      inflect.irregular('child', 'children');
      inflect.irregular('sex', 'sexes');
      inflect.irregular('move', 'moves');
      inflect.irregular('cow', 'kine');
      inflect.irregular('zombie', 'zombies');
    
      inflect.uncountable(['equipment', 'information', 'rice', 'money', 'species', 'series', 'fish', 'sheep', 'jeans']);
    }
    
  provide("i/lib/defaults", module.exports);
}(global));

// pakmanager:i/lib/inflections
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional
    // inflection rules. Examples:
    //
    //     BulletSupport.Inflector.inflect ($) ->
    //       $.plural /^(ox)$/i, '$1en'
    //       $.singular /^(ox)en/i, '$1'
    //
    //       $.irregular 'octopus', 'octopi'
    //
    //       $.uncountable "equipment"
    //
    // New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the
    // pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may
    // already have been loaded.
    
    var util =  require('i/lib/util');
    
    var Inflections = function () {
      this.plurals = [];
      this.singulars = [];
      this.uncountables = [];
      this.humans = [];
       require('i/lib/defaults')(this);
      return this;
    };
    
    // Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.
    // The replacement should always be a string that may include references to the matched data from the rule.
    Inflections.prototype.plural = function (rule, replacement) {
      if (typeof rule == 'string') {
        this.uncountables = util.array.del(this.uncountables, rule);
      }
      this.uncountables = util.array.del(this.uncountables, replacement);
      this.plurals.unshift([rule, replacement]);
    };
    
    // Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.
    // The replacement should always be a string that may include references to the matched data from the rule.
    Inflections.prototype.singular = function (rule, replacement) {
      if (typeof rule == 'string') {
        this.uncountables = util.array.del(this.uncountables, rule);
      }
      this.uncountables = util.array.del(this.uncountables, replacement);
      this.singulars.unshift([rule, replacement]);
    };
    
    // Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used
    // for strings, not regular expressions. You simply pass the irregular in singular and plural form.
    //
    //     irregular 'octopus', 'octopi'
    //     irregular 'person', 'people'
    Inflections.prototype.irregular =  function (singular, plural) {
      this.uncountables = util.array.del(this.uncountables, singular);
      this.uncountables = util.array.del(this.uncountables, plural);
      if (singular[0].toUpperCase() == plural[0].toUpperCase()) {
        this.plural(new RegExp("(" + singular[0] + ")" + singular.slice(1) + "$", "i"), '$1' + plural.slice(1));
        this.plural(new RegExp("(" + plural[0] + ")" + plural.slice(1) + "$", "i"), '$1' + plural.slice(1));
        this.singular(new RegExp("(" + plural[0] + ")" + plural.slice(1) + "$", "i"), '$1' + singular.slice(1));
      } else {
        this.plural(new RegExp("" + (singular[0].toUpperCase()) + singular.slice(1) + "$"), plural[0].toUpperCase() + plural.slice(1));
        this.plural(new RegExp("" + (singular[0].toLowerCase()) + singular.slice(1) + "$"), plural[0].toLowerCase() + plural.slice(1));
        this.plural(new RegExp("" + (plural[0].toUpperCase()) + plural.slice(1) + "$"), plural[0].toUpperCase() + plural.slice(1));
        this.plural(new RegExp("" + (plural[0].toLowerCase()) + plural.slice(1) + "$"), plural[0].toLowerCase() + plural.slice(1));
        this.singular(new RegExp("" + (plural[0].toUpperCase()) + plural.slice(1) + "$"), singular[0].toUpperCase() + singular.slice(1));
        this.singular(new RegExp("" + (plural[0].toLowerCase()) + plural.slice(1) + "$"), singular[0].toLowerCase() + singular.slice(1));
      }
    };
    
    // Specifies a humanized form of a string by a regular expression rule or by a string mapping.
    // When using a regular expression based replacement, the normal humanize formatting is called after the replacement.
    // When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name')
    //
    //     human /(.*)_cnt$/i, '$1_count'
    //     human "legacy_col_person_name", "Name"
    Inflections.prototype.human = function (rule, replacement) {
      this.humans.unshift([rule, replacement]);
    }
    
    // Add uncountable words that shouldn't be attempted inflected.
    //
    //     uncountable "money"
    //     uncountable ["money", "information"]
    Inflections.prototype.uncountable = function (words) {
      this.uncountables = this.uncountables.concat(words);
    }
    
    // Clears the loaded inflections within a given scope (default is _'all'_).
    // Give the scope as a symbol of the inflection type, the options are: _'plurals'_,
    // _'singulars'_, _'uncountables'_, _'humans'_.
    //
    //     clear 'all'
    //     clear 'plurals'
    Inflections.prototype.clear = function (scope) {
      if (scope == null) scope = 'all';
      switch (scope) {
        case 'all':
          this.plurals = [];
          this.singulars = [];
          this.uncountables = [];
          this.humans = [];
        default:
          this[scope] = [];
      }
    }
    
    // Clears the loaded inflections and initializes them to [default](../inflections.html)
    Inflections.prototype.default = function () {
      this.plurals = [];
      this.singulars = [];
      this.uncountables = [];
      this.humans = [];
       require('i/lib/defaults')(this);
      return this;
    };
    
    module.exports = new Inflections();
    
  provide("i/lib/inflections", module.exports);
}(global));

// pakmanager:i/lib/methods
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // The Inflector transforms words from singular to plural, class names to table names, modularized class names to ones without,
    // and class names to foreign keys. The default inflections for pluralization, singularization, and uncountable words are kept
    // in inflections.coffee
    //
    // If you discover an incorrect inflection and require it for your application, you'll need
    // to correct it yourself (explained below).
    
    var util =  require('i/lib/util');
    
    var inflect = module.exports;
    
    // Import [inflections](inflections.html) instance
    inflect.inflections =  require('i/lib/inflections')
    
    // Gives easy access to add inflections to this class
    inflect.inflect = function (inflections_function) {
      inflections_function(inflect.inflections);
    };
    
    // By default, _camelize_ converts strings to UpperCamelCase. If the argument to _camelize_
    // is set to _false_ then _camelize_ produces lowerCamelCase.
    //
    // _camelize_ will also convert '/' to '.' which is useful for converting paths to namespaces.
    //
    //     "bullet_record".camelize()             // => "BulletRecord"
    //     "bullet_record".camelize(false)        // => "bulletRecord"
    //     "bullet_record/errors".camelize()      // => "BulletRecord.Errors"
    //     "bullet_record/errors".camelize(false) // => "bulletRecord.Errors"
    //
    // As a rule of thumb you can think of _camelize_ as the inverse of _underscore_,
    // though there are cases where that does not hold:
    //
    //     "SSLError".underscore.camelize // => "SslError"
    inflect.camelize = function(lower_case_and_underscored_word, first_letter_in_uppercase) {
      var result;
      if (first_letter_in_uppercase == null) first_letter_in_uppercase = true;
      result = util.string.gsub(lower_case_and_underscored_word, /\/(.?)/, function($) {
        return "." + (util.string.upcase($[1]));
      });
      result = util.string.gsub(result, /(?:_)(.)/, function($) {
        return util.string.upcase($[1]);
      });
      if (first_letter_in_uppercase) {
        return util.string.upcase(result);
      } else {
        return util.string.downcase(result);
      }
    };
    
    // Makes an underscored, lowercase form from the expression in the string.
    //
    // Changes '.' to '/' to convert namespaces to paths.
    //
    //     "BulletRecord".underscore()         // => "bullet_record"
    //     "BulletRecord.Errors".underscore()  // => "bullet_record/errors"
    //
    // As a rule of thumb you can think of +underscore+ as the inverse of +camelize+,
    // though there are cases where that does not hold:
    //
    //     "SSLError".underscore().camelize() // => "SslError"
    inflect.underscore = function (camel_cased_word) {
      var self;
      self = util.string.gsub(camel_cased_word, /\./, '/');
      self = util.string.gsub(self, /([A-Z]+)([A-Z][a-z])/, "$1_$2");
      self = util.string.gsub(self, /([a-z\d])([A-Z])/, "$1_$2");
      self = util.string.gsub(self, /-/, '_');
      return self.toLowerCase();
    };
    
    // Replaces underscores with dashes in the string.
    //
    //     "puni_puni".dasherize()   // => "puni-puni"
    inflect.dasherize = function (underscored_word) {
      return util.string.gsub(underscored_word, /_/, '-');
    };
    
    // Removes the module part from the expression in the string.
    //
    //     "BulletRecord.String.Inflections".demodulize() // => "Inflections"
    //     "Inflections".demodulize()                     // => "Inflections"
    inflect.demodulize = function (class_name_in_module) {
      return util.string.gsub(class_name_in_module, /^.*\./, '');
    };
    
    // Creates a foreign key name from a class name.
    // _separate_class_name_and_id_with_underscore_ sets whether
    // the method should put '_' between the name and 'id'.
    //
    //     "Message".foreign_key()      // => "message_id"
    //     "Message".foreign_key(false) // => "messageid"
    //     "Admin::Post".foreign_key()  // => "post_id"
    inflect.foreign_key = function (class_name, separate_class_name_and_id_with_underscore) {
      if (separate_class_name_and_id_with_underscore == null) {
        separate_class_name_and_id_with_underscore = true;
      }
      return inflect.underscore(inflect.demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? "_id" : "id");
    };
    
    // Turns a number into an ordinal string used to denote the position in an
    // ordered sequence such as 1st, 2nd, 3rd, 4th.
    //
    //     ordinalize(1)     // => "1st"
    //     ordinalize(2)     // => "2nd"
    //     ordinalize(1002)  // => "1002nd"
    //     ordinalize(1003)  // => "1003rd"
    //     ordinalize(-11)   // => "-11th"
    //     ordinalize(-1021) // => "-1021st"
    inflect.ordinalize = function (number) {
      var _ref;
      number = parseInt(number);
      if ((_ref = Math.abs(number) % 100) === 11 || _ref === 12 || _ref === 13) {
        return "" + number + "th";
      } else {
        switch (Math.abs(number) % 10) {
          case 1:
            return "" + number + "st";
          case 2:
            return "" + number + "nd";
          case 3:
            return "" + number + "rd";
          default:
            return "" + number + "th";
        }
      }
    };
    
    // Checks a given word for uncountability
    //
    //     "money".uncountability()     // => true
    //     "my money".uncountability()  // => true
    inflect.uncountability = function (word) {
      return inflect.inflections.uncountables.some(function(ele, ind, arr) {
        return word.match(new RegExp("(\\b|_)" + ele + "$", 'i')) != null;
      });
    };
    
    // Returns the plural form of the word in the string.
    //
    //     "post".pluralize()             // => "posts"
    //     "octopus".pluralize()          // => "octopi"
    //     "sheep".pluralize()            // => "sheep"
    //     "words".pluralize()            // => "words"
    //     "CamelOctopus".pluralize()     // => "CamelOctopi"
    inflect.pluralize = function (word) {
      var plural, result;
      result = word;
      if (word === '' || inflect.uncountability(word)) {
        return result;
      } else {
        for (var i = 0; i < inflect.inflections.plurals.length; i++) {
          plural = inflect.inflections.plurals[i];
          result = util.string.gsub(result, plural[0], plural[1]);
          if (word.match(plural[0]) != null) break;
        }
        return result;
      }
    };
    
    // The reverse of _pluralize_, returns the singular form of a word in a string.
    //
    //     "posts".singularize()            // => "post"
    //     "octopi".singularize()           // => "octopus"
    //     "sheep".singularize()            // => "sheep"
    //     "word".singularize()             // => "word"
    //     "CamelOctopi".singularize()      // => "CamelOctopus"
    inflect.singularize = function (word) {
      var result, singular;
      result = word;
      if (word === '' || inflect.uncountability(word)) {
        return result;
      } else {
        for (var i = 0; i < inflect.inflections.singulars.length; i++) {
          singular = inflect.inflections.singulars[i];
          result = util.string.gsub(result, singular[0], singular[1]);
          if (word.match(singular[0])) break;
        }
        return result;
      }
    };
    
    // Capitalizes the first word and turns underscores into spaces and strips a
    // trailing "_id", if any. Like _titleize_, this is meant for creating pretty output.
    //
    //     "employee_salary".humanize()   // => "Employee salary"
    //     "author_id".humanize()         // => "Author"
    inflect.humanize = function (lower_case_and_underscored_word) {
      var human, result;
      result = lower_case_and_underscored_word;
      for (var i = 0; i < inflect.inflections.humans.length; i++) {
        human = inflect.inflections.humans[i];
        result = util.string.gsub(result, human[0], human[1]);
      }
      result = util.string.gsub(result, /_id$/, "");
      result = util.string.gsub(result, /_/, " ");
      return util.string.capitalize(result, true);
    };
    
    // Capitalizes all the words and replaces some characters in the string to create
    // a nicer looking title. _titleize_ is meant for creating pretty output. It is not
    // used in the Bullet internals.
    //
    //
    //     "man from the boondocks".titleize()   // => "Man From The Boondocks"
    //     "x-men: the last stand".titleize()    // => "X Men: The Last Stand"
    inflect.titleize = function (word) {
      var self;
      self = inflect.humanize(inflect.underscore(word));
      self = util.string.gsub(self, /[^a-zA-Z:']/, ' ');
      return util.string.capitalize(self);
    };
    
    // Create the name of a table like Bullet does for models to table names. This method
    // uses the _pluralize_ method on the last word in the string.
    //
    //     "RawScaledScorer".tableize()   // => "raw_scaled_scorers"
    //     "egg_and_ham".tableize()       // => "egg_and_hams"
    //     "fancyCategory".tableize()     // => "fancy_categories"
    inflect.tableize = function (class_name) {
      return inflect.pluralize(inflect.underscore(class_name));
    };
    
    // Create a class name from a plural table name like Bullet does for table names to models.
    // Note that this returns a string and not a Class.
    //
    //     "egg_and_hams".classify()   // => "EggAndHam"
    //     "posts".classify()          // => "Post"
    //
    // Singular names are not handled correctly:
    //
    //     "business".classify()       // => "Busines"
    inflect.classify = function (table_name) {
      return inflect.camelize(inflect.singularize(util.string.gsub(table_name, /.*\./, '')));
    }
    
  provide("i/lib/methods", module.exports);
}(global));

// pakmanager:i/lib/native
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (obj) {
    
      var addProperty = function (method, func) {
        String.prototype.__defineGetter__(method, func);
      }
    
      var stringPrototypeBlacklist = [
        '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
        'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
        'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
        'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight', 'gsub'
      ];
    
      Object.keys(obj).forEach(function (key) {
        if (key != 'inflect' && key != 'inflections') {
          if (stringPrototypeBlacklist.indexOf(key) !== -1) {
            console.log('warn: You should not override String.prototype.' + key);
          } else {
            addProperty(key, function () {
              return obj[key](this);
            });
          }
        }
      });
    
    }
    
  provide("i/lib/native", module.exports);
}(global));

// pakmanager:i
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Requiring modules
    
    module.exports = function (attach) {
      var methods =  require('i/lib/methods');
    
      if (attach) {
         require('i/lib/native')(methods);
      }
    
      return methods
    };
    
  provide("i", module.exports);
}(global));

// pakmanager:mkdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    var _0777 = parseInt('0777', 8);
    
    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    
    function mkdirP (p, opts, f, made) {
        if (typeof opts === 'function') {
            f = opts;
            opts = {};
        }
        else if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
        
        var cb = f || function () {};
        p = path.resolve(p);
        
        xfs.mkdir(p, mode, function (er) {
            if (!er) {
                made = made || p;
                return cb(null, made);
            }
            switch (er.code) {
                case 'ENOENT':
                    mkdirP(path.dirname(p), opts, function (er, made) {
                        if (er) cb(er, made);
                        else mkdirP(p, opts, cb, made);
                    });
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    xfs.stat(p, function (er2, stat) {
                        // if the stat fails, then that's super weird.
                        // let the original error be the failure reason.
                        if (er2 || !stat.isDirectory()) cb(er, made)
                        else cb(null, made);
                    });
                    break;
            }
        });
    }
    
    mkdirP.sync = function sync (p, opts, made) {
        if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
    
        p = path.resolve(p);
    
        try {
            xfs.mkdirSync(p, mode);
            made = made || p;
        }
        catch (err0) {
            switch (err0.code) {
                case 'ENOENT' :
                    made = sync(path.dirname(p), opts, made);
                    sync(p, opts, made);
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    var stat;
                    try {
                        stat = xfs.statSync(p);
                    }
                    catch (err1) {
                        throw err0;
                    }
                    if (!stat.isDirectory()) throw err0;
                    break;
            }
        }
    
        return made;
    };
    
  provide("mkdirp", module.exports);
}(global));

// pakmanager:ncp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs'),
        path = require('path');
    
    module.exports = ncp;
    ncp.ncp = ncp;
    
    function ncp (source, dest, options, callback) {
      var cback = callback;
    
      if (!callback) {
        cback = options;
        options = {};
      }
    
      var basePath = process.cwd(),
          currentPath = path.resolve(basePath, source),
          targetPath = path.resolve(basePath, dest),
          filter = options.filter,
          rename = options.rename,
          transform = options.transform,
          clobber = options.clobber !== false,
          modified = options.modified,
          dereference = options.dereference,
          errs = null,
          started = 0,
          finished = 0,
          running = 0,
          limit = options.limit || ncp.limit || 16;
    
      limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;
    
      startCopy(currentPath);
      
      function startCopy(source) {
        started++;
        if (filter) {
          if (filter instanceof RegExp) {
            if (!filter.test(source)) {
              return cb(true);
            }
          }
          else if (typeof filter === 'function') {
            if (!filter(source)) {
              return cb(true);
            }
          }
        }
        return getStats(source);
      }
    
      function getStats(source) {
        var stat = dereference ? fs.stat : fs.lstat;
        if (running >= limit) {
          return setImmediate(function () {
            getStats(source);
          });
        }
        running++;
        stat(source, function (err, stats) {
          var item = {};
          if (err) {
            return onError(err);
          }
    
          // We need to get the mode from the stats object and preserve it.
          item.name = source;
          item.mode = stats.mode;
          item.mtime = stats.mtime; //modified time
          item.atime = stats.atime; //access time
    
          if (stats.isDirectory()) {
            return onDir(item);
          }
          else if (stats.isFile()) {
            return onFile(item);
          }
          else if (stats.isSymbolicLink()) {
            // Symlinks don't really need to know about the mode.
            return onLink(source);
          }
        });
      }
    
      function onFile(file) {
        var target = file.name.replace(currentPath, targetPath);
        if(rename) {
          target =  rename(target);
        }
        isWritable(target, function (writable) {
          if (writable) {
            return copyFile(file, target);
          }
          if(clobber) {
            rmFile(target, function () {
              copyFile(file, target);
            });
          }
          if (modified) {
            var stat = dereference ? fs.stat : fs.lstat;
            stat(target, function(err, stats) {
                //if souce modified time greater to target modified time copy file
                if (file.mtime.getTime()>stats.mtime.getTime())
                    copyFile(file, target);
                else return cb();
            });
          }
          else {
            return cb();
          }
        });
      }
    
      function copyFile(file, target) {
        var readStream = fs.createReadStream(file.name),
            writeStream = fs.createWriteStream(target, { mode: file.mode });
        
        readStream.on('error', onError);
        writeStream.on('error', onError);
        
        if(transform) {
          transform(readStream, writeStream, file);
        } else {
          writeStream.on('open', function() {
            readStream.pipe(writeStream);
          });
        }
        writeStream.once('finish', function() {
            if (modified) {
                //target file modified date sync.
                fs.utimesSync(target, file.atime, file.mtime);
                cb();
            }
            else cb();
        });
      }
    
      function rmFile(file, done) {
        fs.unlink(file, function (err) {
          if (err) {
            return onError(err);
          }
          return done();
        });
      }
    
      function onDir(dir) {
        var target = dir.name.replace(currentPath, targetPath);
        isWritable(target, function (writable) {
          if (writable) {
            return mkDir(dir, target);
          }
          copyDir(dir.name);
        });
      }
    
      function mkDir(dir, target) {
        fs.mkdir(target, dir.mode, function (err) {
          if (err) {
            return onError(err);
          }
          copyDir(dir.name);
        });
      }
    
      function copyDir(dir) {
        fs.readdir(dir, function (err, items) {
          if (err) {
            return onError(err);
          }
          items.forEach(function (item) {
            startCopy(path.join(dir, item));
          });
          return cb();
        });
      }
    
      function onLink(link) {
        var target = link.replace(currentPath, targetPath);
        fs.readlink(link, function (err, resolvedPath) {
          if (err) {
            return onError(err);
          }
          checkLink(resolvedPath, target);
        });
      }
    
      function checkLink(resolvedPath, target) {
        if (dereference) {
          resolvedPath = path.resolve(basePath, resolvedPath);
        }
        isWritable(target, function (writable) {
          if (writable) {
            return makeLink(resolvedPath, target);
          }
          fs.readlink(target, function (err, targetDest) {
            if (err) {
              return onError(err);
            }
            if (dereference) {
              targetDest = path.resolve(basePath, targetDest);
            }
            if (targetDest === resolvedPath) {
              return cb();
            }
            return rmFile(target, function () {
              makeLink(resolvedPath, target);
            });
          });
        });
      }
    
      function makeLink(linkPath, target) {
        fs.symlink(linkPath, target, function (err) {
          if (err) {
            return onError(err);
          }
          return cb();
        });
      }
    
      function isWritable(path, done) {
        fs.lstat(path, function (err) {
          if (err) {
            if (err.code === 'ENOENT') return done(true);
            return done(false);
          }
          return done(false);
        });
      }
    
      function onError(err) {
        if (options.stopOnError) {
          return cback(err);
        }
        else if (!errs && options.errs) {
          errs = fs.createWriteStream(options.errs);
        }
        else if (!errs) {
          errs = [];
        }
        if (typeof errs.write === 'undefined') {
          errs.push(err);
        }
        else { 
          errs.write(err.stack + '\n\n');
        }
        return cb();
      }
    
      function cb(skipped) {
        if (!skipped) running--;
        finished++;
        if ((started === finished) && (running === 0)) {
          if (cback !== undefined ) {
            return errs ? cback(errs) : cback(null);
          }
        }
      }
    }
    
    
    
  provide("ncp", module.exports);
}(global));

// pakmanager:rimraf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = rimraf
    rimraf.sync = rimrafSync
    
    var assert = require("assert")
    var path = require("path")
    var fs = require("fs")
    var glob = require("glob")
    
    var globOpts = {
      nosort: true,
      nocomment: true,
      nonegate: true,
      silent: true
    }
    
    // for EMFILE handling
    var timeout = 0
    
    var isWindows = (process.platform === "win32")
    
    function defaults (options) {
      var methods = [
        'unlink',
        'chmod',
        'stat',
        'lstat',
        'rmdir',
        'readdir'
      ]
      methods.forEach(function(m) {
        options[m] = options[m] || fs[m]
        m = m + 'Sync'
        options[m] = options[m] || fs[m]
      })
    
      options.maxBusyTries = options.maxBusyTries || 3
      options.emfileWait = options.emfileWait || 1000
      options.disableGlob = options.disableGlob || false
    }
    
    function rimraf (p, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = {}
      }
    
      assert(p, 'rimraf: missing path')
      assert.equal(typeof p, 'string', 'rimraf: path should be a string')
      assert(options, 'rimraf: missing options')
      assert.equal(typeof options, 'object', 'rimraf: options should be object')
      assert.equal(typeof cb, 'function', 'rimraf: callback function required')
    
      defaults(options)
    
      var busyTries = 0
      var errState = null
      var n = 0
    
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p])
    
      fs.lstat(p, function (er, stat) {
        if (!er)
          return afterGlob(null, [p])
    
        glob(p, globOpts, afterGlob)
      })
    
      function next (er) {
        errState = errState || er
        if (--n === 0)
          cb(errState)
      }
    
      function afterGlob (er, results) {
        if (er)
          return cb(er)
    
        n = results.length
        if (n === 0)
          return cb()
    
        results.forEach(function (p) {
          rimraf_(p, options, function CB (er) {
            if (er) {
              if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY") &&
                  busyTries < options.maxBusyTries) {
                busyTries ++
                var time = busyTries * 100
                // try again, with the same exact callback as this one.
                return setTimeout(function () {
                  rimraf_(p, options, CB)
                }, time)
              }
    
              // this one won't happen if graceful-fs is used.
              if (er.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function () {
                  rimraf_(p, options, CB)
                }, timeout ++)
              }
    
              // already gone
              if (er.code === "ENOENT") er = null
            }
    
            timeout = 0
            next(er)
          })
        })
      }
    }
    
    // Two possible strategies.
    // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
    // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
    //
    // Both result in an extra syscall when you guess wrong.  However, there
    // are likely far more normal files in the world than directories.  This
    // is based on the assumption that a the average number of files per
    // directory is >= 1.
    //
    // If anyone ever complains about this, then I guess the strategy could
    // be made configurable somehow.  But until then, YAGNI.
    function rimraf_ (p, options, cb) {
      assert(p)
      assert(options)
      assert(typeof cb === 'function')
    
      // sunos lets the root user unlink directories, which is... weird.
      // so we have to lstat here and make sure it's not a dir.
      options.lstat(p, function (er, st) {
        if (er && er.code === "ENOENT")
          return cb(null)
    
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb)
    
        options.unlink(p, function (er) {
          if (er) {
            if (er.code === "ENOENT")
              return cb(null)
            if (er.code === "EPERM")
              return (isWindows)
                ? fixWinEPERM(p, options, er, cb)
                : rmdir(p, options, er, cb)
            if (er.code === "EISDIR")
              return rmdir(p, options, er, cb)
          }
          return cb(er)
        })
      })
    }
    
    function fixWinEPERM (p, options, er, cb) {
      assert(p)
      assert(options)
      assert(typeof cb === 'function')
      if (er)
        assert(er instanceof Error)
    
      options.chmod(p, 666, function (er2) {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er)
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er)
            else if (stats.isDirectory())
              rmdir(p, options, er, cb)
            else
              options.unlink(p, cb)
          })
      })
    }
    
    function fixWinEPERMSync (p, options, er) {
      assert(p)
      assert(options)
      if (er)
        assert(er instanceof Error)
    
      try {
        options.chmodSync(p, 666)
      } catch (er2) {
        if (er2.code === "ENOENT")
          return
        else
          throw er
      }
    
      try {
        var stats = options.statSync(p)
      } catch (er3) {
        if (er3.code === "ENOENT")
          return
        else
          throw er
      }
    
      if (stats.isDirectory())
        rmdirSync(p, options, er)
      else
        options.unlinkSync(p)
    }
    
    function rmdir (p, options, originalEr, cb) {
      assert(p)
      assert(options)
      if (originalEr)
        assert(originalEr instanceof Error)
      assert(typeof cb === 'function')
    
      // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
      // if we guessed wrong, and it's not a directory, then
      // raise the original error.
      options.rmdir(p, function (er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb)
        else if (er && er.code === "ENOTDIR")
          cb(originalEr)
        else
          cb(er)
      })
    }
    
    function rmkids(p, options, cb) {
      assert(p)
      assert(options)
      assert(typeof cb === 'function')
    
      options.readdir(p, function (er, files) {
        if (er)
          return cb(er)
        var n = files.length
        if (n === 0)
          return options.rmdir(p, cb)
        var errState
        files.forEach(function (f) {
          rimraf(path.join(p, f), options, function (er) {
            if (errState)
              return
            if (er)
              return cb(errState = er)
            if (--n === 0)
              options.rmdir(p, cb)
          })
        })
      })
    }
    
    // this looks simpler, and is strictly *faster*, but will
    // tie up the JavaScript thread and fail on excessively
    // deep directory trees.
    function rimrafSync (p, options) {
      options = options || {}
      defaults(options)
    
      assert(p, 'rimraf: missing path')
      assert.equal(typeof p, 'string', 'rimraf: path should be a string')
      assert(options, 'rimraf: missing options')
      assert.equal(typeof options, 'object', 'rimraf: options should be object')
    
      var results
    
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p]
      } else {
        try {
          fs.lstatSync(p)
          results = [p]
        } catch (er) {
          results = glob.sync(p, globOpts)
        }
      }
    
      if (!results.length)
        return
    
      for (var i = 0; i < results.length; i++) {
        var p = results[i]
    
        try {
          var st = options.lstatSync(p)
        } catch (er) {
          if (er.code === "ENOENT")
            return
        }
    
        try {
          // sunos lets the root user unlink directories, which is... weird.
          if (st && st.isDirectory())
            rmdirSync(p, options, null)
          else
            options.unlinkSync(p)
        } catch (er) {
          if (er.code === "ENOENT")
            return
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
          if (er.code !== "EISDIR")
            throw er
          rmdirSync(p, options, er)
        }
      }
    }
    
    function rmdirSync (p, options, originalEr) {
      assert(p)
      assert(options)
      if (originalEr)
        assert(originalEr instanceof Error)
    
      try {
        options.rmdirSync(p)
      } catch (er) {
        if (er.code === "ENOENT")
          return
        if (er.code === "ENOTDIR")
          throw originalEr
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options)
      }
    }
    
    function rmkidsSync (p, options) {
      assert(p)
      assert(options)
      options.readdirSync(p).forEach(function (f) {
        rimrafSync(path.join(p, f), options)
      })
      options.rmdirSync(p, options)
    }
    
  provide("rimraf", module.exports);
}(global));

// pakmanager:colors/lib/styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    The MIT License (MIT)
    
    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var styles = {};
    module['exports'] = styles;
    
    var codes = {
      reset: [0, 0],
    
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
    
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
    
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
    
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    
    };
    
    Object.keys(codes).forEach(function (key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = '\u001b[' + val[0] + 'm';
      style.close = '\u001b[' + val[1] + 'm';
    });
  provide("colors/lib/styles", module.exports);
}(global));

// pakmanager:colors/lib/system/supports-colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    The MIT License (MIT)
    
    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var argv = process.argv;
    
    module.exports = (function () {
      if (argv.indexOf('--no-color') !== -1 ||
        argv.indexOf('--color=false') !== -1) {
        return false;
      }
    
      if (argv.indexOf('--color') !== -1 ||
        argv.indexOf('--color=true') !== -1 ||
        argv.indexOf('--color=always') !== -1) {
        return true;
      }
    
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
    
      if (process.platform === 'win32') {
        return true;
      }
    
      if ('COLORTERM' in process.env) {
        return true;
      }
    
      if (process.env.TERM === 'dumb') {
        return false;
      }
    
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
    
      return false;
    })();
  provide("colors/lib/system/supports-colors", module.exports);
}(global));

// pakmanager:colors/lib/custom/trap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module['exports'] = function runTheTrap (text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split('');
      var trap = {
        a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
        b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
        c: ["\u00a9", "\u023b", "\u03fe"],
        d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
        e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
        f: ["\u04fa"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
        i: ["\u0f0f"],
        j: ["\u0134"],
        k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
        l: ["\u0139"],
        m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
        n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
        o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
        p: ["\u01f7", "\u048e"],
        q: ["\u09cd"],
        r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
        s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01b1", "\u054d"],
        v: ["\u05d8"],
        w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
        x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
        y: ["\u00a5", "\u04b0", "\u04cb"],
        z: ["\u01b5", "\u0240"]
      }
      text.forEach(function(c){
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    
    }
    
  provide("colors/lib/custom/trap", module.exports);
}(global));

// pakmanager:colors/lib/custom/zalgo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // please no
    module['exports'] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up" : [
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', ''
        ],
        "down" : [
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '', ''
        ],
        "mid" : [
          '', '', '', '',
          '', '', '', '',
          '', '', '', '',
          '', '', '',
          '', '', '', '',
          '', '', ' '
        ]
      },
      all = [].concat(soul.up, soul.down, soul.mid),
      zalgo = {};
    
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
    
      function is_char(character) {
        var bool = false;
        all.filter(function (i) {
          bool = (i === character);
        });
        return bool;
      }
      
    
      function heComes(text, options) {
        var result = '', counts, l;
        options = options || {};
        options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
        options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
        options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
        options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
        text = text.split('');
        for (l in text) {
          if (is_char(l)) {
            continue;
          }
          result = result + text[l];
          counts = {"up" : 0, "down" : 0, "mid" : 0};
          switch (options.size) {
          case 'mini':
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case 'maxi':
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
          }
    
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0 ; i <= counts[index]; i++) {
              if (options[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      // don't summon him
      return heComes(text, options);
    }
    
  provide("colors/lib/custom/zalgo", module.exports);
}(global));

// pakmanager:colors/lib/maps/america
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function() {
      return function (letter, i, exploded) {
        if(letter === " ") return letter;
        switch(i%3) {
          case 0: return colors.red(letter);
          case 1: return colors.white(letter)
          case 2: return colors.blue(letter)
        }
      }
    })();
  provide("colors/lib/maps/america", module.exports);
}(global));

// pakmanager:colors/lib/maps/zebra
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = function (letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  provide("colors/lib/maps/zebra", module.exports);
}(global));

// pakmanager:colors/lib/maps/rainbow
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function () {
      var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
      return function (letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    })();
    
    
  provide("colors/lib/maps/rainbow", module.exports);
}(global));

// pakmanager:colors/lib/maps/random
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function () {
      var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    })();
  provide("colors/lib/maps/random", module.exports);
}(global));

// pakmanager:colors/lib/colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    
    The MIT License (MIT)
    
    Original Library 
      - Copyright (c) Marak Squires
    
    Additional functionality
     - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var colors = {};
    module['exports'] = colors;
    
    colors.themes = {};
    
    var ansiStyles = colors.styles =  require('colors/lib/styles');
    var defineProps = Object.defineProperties;
    
    colors.supportsColor =  require('colors/lib/system/supports-colors');
    
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    
    colors.stripColors = colors.strip = function(str){
      return ("" + str).replace(/\x1B\[\d+m/g, '');
    };
    
    
    var stylize = colors.stylize = function stylize (str, style) {
      if (!colors.enabled) {
        return str+'';
      }
    
      return ansiStyles[style].open + str + ansiStyles[style].close;
    }
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function (str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
      }
      return str.replace(matchOperatorsRe,  '\\$&');
    }
    
    function build(_styles) {
      var builder = function builder() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      // __proto__ is used because we must return a function, but there is
      // no way to create a function with a different prototype.
      builder.__proto__ = proto;
      return builder;
    }
    
    var styles = (function () {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function (key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
        ret[key] = {
          get: function () {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    })();
    
    var proto = defineProps(function colors() {}, styles);
    
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }
    
      if (!colors.enabled || !str) {
        return str;
      }
    
      var nestedStyles = this._styles;
    
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
    
      return str;
    }
    
    function applyTheme (theme) {
      for (var style in theme) {
        (function(style){
          colors[style] = function(str){
            if (typeof theme[style] === 'object'){
              var out = str;
              for (var i in theme[style]){
                out = colors[theme[style][i]](out);
              }
              return out;
            }
            return colors[theme[style]](str);
          };
        })(style)
      }
    }
    
    colors.setTheme = function (theme) {
      if (typeof theme === 'string') {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function (name) {
        ret[name] = {
          get: function () {
            return build([name]);
          }
        };
      });
      return ret;
    }
    
    var sequencer = function sequencer (map, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map);
      return exploded.join("");
    };
    
    // custom formatter methods
    colors.trap =  require('colors/lib/custom/trap');
    colors.zalgo =  require('colors/lib/custom/zalgo');
    
    // maps
    colors.maps = {};
    colors.maps.america =  require('colors/lib/maps/america');
    colors.maps.zebra =  require('colors/lib/maps/zebra');
    colors.maps.rainbow =  require('colors/lib/maps/rainbow');
    colors.maps.random =  require('colors/lib/maps/random')
    
    for (var map in colors.maps) {
      (function(map){
        colors[map] = function (str) {
          return sequencer(colors.maps[map], str);
        }
      })(map)
    }
    
    defineProps(colors, init());
  provide("colors/lib/colors", module.exports);
}(global));

// pakmanager:colors/lib/extendStringPrototype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = function () {
    
      //
      // Extends prototype of native string object to allow for "foo".red syntax
      //
      var addProperty = function (color, func) {
        String.prototype.__defineGetter__(color, func);
      };
    
      var sequencer = function sequencer (map, str) {
          return function () {
            var exploded = this.split(""), i = 0;
            exploded = exploded.map(map);
            return exploded.join("");
          }
      };
    
      addProperty('strip', function () {
        return colors.strip(this);
      });
    
      addProperty('stripColors', function () {
        return colors.strip(this);
      });
    
      addProperty("trap", function(){
        return colors.trap(this);
      });
    
      addProperty("zalgo", function(){
        return colors.zalgo(this);
      });
    
      addProperty("zebra", function(){
        return colors.zebra(this);
      });
    
      addProperty("rainbow", function(){
        return colors.rainbow(this);
      });
    
      addProperty("random", function(){
        return colors.random(this);
      });
    
      addProperty("america", function(){
        return colors.america(this);
      });
    
      //
      // Iterate through all default styles and colors
      //
      var x = Object.keys(colors.styles);
      x.forEach(function (style) {
        addProperty(style, function () {
          return colors.stylize(this, style);
        });
      });
    
      function applyTheme(theme) {
        //
        // Remark: This is a list of methods that exist
        // on String that you should not overwrite.
        //
        var stringPrototypeBlacklist = [
          '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
          'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
          'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
          'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
        ];
    
        Object.keys(theme).forEach(function (prop) {
          if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
            console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
          }
          else {
            if (typeof(theme[prop]) === 'string') {
              colors[prop] = colors[theme[prop]];
              addProperty(prop, function () {
                return colors[theme[prop]](this);
              });
            }
            else {
              addProperty(prop, function () {
                var ret = this;
                for (var t = 0; t < theme[prop].length; t++) {
                  ret = colors[theme[prop][t]](ret);
                }
                return ret;
              });
            }
          }
        });
      }
    
      colors.setTheme = function (theme) {
        if (typeof theme === 'string') {
          try {
            colors.themes[theme] = require(theme);
            applyTheme(colors.themes[theme]);
            return colors.themes[theme];
          } catch (err) {
            console.log(err);
            return err;
          }
        } else {
          applyTheme(theme);
        }
      };
    
    };
  provide("colors/lib/extendStringPrototype", module.exports);
}(global));

// pakmanager:colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    module['exports'] = colors;
    
    // Remark: By default, colors will add style properties to String.prototype
    //
    // If you don't wish to extend String.prototype you can do this instead and native String will not be touched
    //
    //   var colors = require('colors/safe);
    //   colors.red("foo")
    //
    //
     require('colors/lib/extendStringPrototype')();
  provide("colors", module.exports);
}(global));

// pakmanager:cycle
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
        cycle.js
        2013-02-19
    
        Public Domain.
    
        NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
    
        This code should be minified before deployment.
        See http://javascript.crockford.com/jsmin.html
    
        USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
        NOT CONTROL.
    */
    
    /*jslint evil: true, regexp: true */
    
    /*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,
        retrocycle, stringify, test, toString
    */
    
    var cycle = exports;
    
    cycle.decycle = function decycle(object) {
        'use strict';
    
    // Make a deep copy of an object or array, assuring that there is at most
    // one instance of each object or array in the resulting structure. The
    // duplicate references (which might be forming cycles) are replaced with
    // an object of the form
    //      {$ref: PATH}
    // where the PATH is a JSONPath string that locates the first occurance.
    // So,
    //      var a = [];
    //      a[0] = a;
    //      return JSON.stringify(JSON.decycle(a));
    // produces the string '[{"$ref":"$"}]'.
    
    // JSONPath is used to locate the unique object. $ indicates the top level of
    // the object or array. [NUMBER] or [STRING] indicates a child member or
    // property.
    
        var objects = [],   // Keep a reference to each unique object or array
            paths = [];     // Keep the path to each unique object or array
    
        return (function derez(value, path) {
    
    // The derez recurses through the object, producing the deep copy.
    
            var i,          // The loop counter
                name,       // Property name
                nu;         // The new object or array
    
    // typeof null === 'object', so go on if this value is really an object but not
    // one of the weird builtin objects.
    
            if (typeof value === 'object' && value !== null &&
                    !(value instanceof Boolean) &&
                    !(value instanceof Date)    &&
                    !(value instanceof Number)  &&
                    !(value instanceof RegExp)  &&
                    !(value instanceof String)) {
    
    // If the value is an object or array, look to see if we have already
    // encountered it. If so, return a $ref/path object. This is a hard way,
    // linear search that will get slower as the number of unique objects grows.
    
                for (i = 0; i < objects.length; i += 1) {
                    if (objects[i] === value) {
                        return {$ref: paths[i]};
                    }
                }
    
    // Otherwise, accumulate the unique value and its path.
    
                objects.push(value);
                paths.push(path);
    
    // If it is an array, replicate the array.
    
                if (Object.prototype.toString.apply(value) === '[object Array]') {
                    nu = [];
                    for (i = 0; i < value.length; i += 1) {
                        nu[i] = derez(value[i], path + '[' + i + ']');
                    }
                } else {
    
    // If it is an object, replicate the object.
    
                    nu = {};
                    for (name in value) {
                        if (Object.prototype.hasOwnProperty.call(value, name)) {
                            nu[name] = derez(value[name],
                                path + '[' + JSON.stringify(name) + ']');
                        }
                    }
                }
                return nu;
            }
            return value;
        }(object, '$'));
    };
    
    
    cycle.retrocycle = function retrocycle($) {
        'use strict';
    
    // Restore an object that was reduced by decycle. Members whose values are
    // objects of the form
    //      {$ref: PATH}
    // are replaced with references to the value found by the PATH. This will
    // restore cycles. The object will be mutated.
    
    // The eval function is used to locate the values described by a PATH. The
    // root object is kept in a $ variable. A regular expression is used to
    // assure that the PATH is extremely well formed. The regexp contains nested
    // * quantifiers. That has been known to have extremely bad performance
    // problems on some browsers for very long strings. A PATH is expected to be
    // reasonably short. A PATH is allowed to belong to a very restricted subset of
    // Goessner's JSONPath.
    
    // So,
    //      var s = '[{"$ref":"$"}]';
    //      return JSON.retrocycle(JSON.parse(s));
    // produces an array containing a single element which is the array itself.
    
        var px =
            /^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;
    
        (function rez(value) {
    
    // The rez function walks recursively through the object looking for $ref
    // properties. When it finds one that has a value that is a path, then it
    // replaces the $ref object with a reference to the value that is found by
    // the path.
    
            var i, item, name, path;
    
            if (value && typeof value === 'object') {
                if (Object.prototype.toString.apply(value) === '[object Array]') {
                    for (i = 0; i < value.length; i += 1) {
                        item = value[i];
                        if (item && typeof item === 'object') {
                            path = item.$ref;
                            if (typeof path === 'string' && px.test(path)) {
                                value[i] = eval(path);
                            } else {
                                rez(item);
                            }
                        }
                    }
                } else {
                    for (name in value) {
                        if (typeof value[name] === 'object') {
                            item = value[name];
                            if (item) {
                                path = item.$ref;
                                if (typeof path === 'string' && px.test(path)) {
                                    value[name] = eval(path);
                                } else {
                                    rez(item);
                                }
                            }
                        }
                    }
                }
            }
        }($));
        return $;
    };
    
  provide("cycle", module.exports);
}(global));

// pakmanager:eyes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //
    // Eyes.js - a customizable value inspector for Node.js
    //
    //   usage:
    //
    //       var inspect =  require('eyes').inspector({styles: {all: 'magenta'}});
    //       inspect(something); // inspect with the settings passed to `inspector`
    //
    //     or
    //
    //       var eyes =  require('eyes');
    //       eyes.inspect(something); // inspect with the default settings
    //
    var eyes = exports,
        stack = [];
    
    eyes.defaults = {
        styles: {                 // Styles applied to stdout
            all:     'cyan',      // Overall style applied to everything
            label:   'underline', // Inspection labels, like 'array' in `array: [1, 2, 3]`
            other:   'inverted',  // Objects which don't have a literal representation, such as functions
            key:     'bold',      // The keys in object literals, like 'a' in `{a: 1}`
            special: 'grey',      // null, undefined...
            string:  'green',
            number:  'magenta',
            bool:    'blue',      // true false
            regexp:  'green',     // /\d+/
        },
        pretty: true,             // Indent object literals
        hideFunctions: false,
        showHidden: false,
        stream: process.stdout,
        maxLength: 2048           // Truncate output if longer
    };
    
    // Return a curried inspect() function, with the `options` argument filled in.
    eyes.inspector = function (options) {
        var that = this;
        return function (obj, label, opts) {
            return that.inspect.call(that, obj, label,
                merge(options || {}, opts || {}));
        };
    };
    
    // If we have a `stream` defined, use it to print a styled string,
    // if not, we just return the stringified object.
    eyes.inspect = function (obj, label, options) {
        options = merge(this.defaults, options || {});
    
        if (options.stream) {
            return this.print(stringify(obj, options), label, options);
        } else {
            return stringify(obj, options) + (options.styles ? '\033[39m' : '');
        }
    };
    
    // Output using the 'stream', and an optional label
    // Loop through `str`, and truncate it after `options.maxLength` has been reached.
    // Because escape sequences are, at this point embeded within
    // the output string, we can't measure the length of the string
    // in a useful way, without separating what is an escape sequence,
    // versus a printable character (`c`). So we resort to counting the
    // length manually.
    eyes.print = function (str, label, options) {
        for (var c = 0, i = 0; i < str.length; i++) {
            if (str.charAt(i) === '\033') { i += 4 } // `4` because '\033[25m'.length + 1 == 5
            else if (c === options.maxLength) {
               str = str.slice(0, i - 1) + '';
               break;
            } else { c++ }
        }
        return options.stream.write.call(options.stream, (label ?
            this.stylize(label, options.styles.label, options.styles) + ': ' : '') +
            this.stylize(str,   options.styles.all, options.styles) + '\033[0m' + "\n");
    };
    
    // Apply a style to a string, eventually,
    // I'd like this to support passing multiple
    // styles.
    eyes.stylize = function (str, style, styles) {
        var codes = {
            'bold'      : [1,  22],
            'underline' : [4,  24],
            'inverse'   : [7,  27],
            'cyan'      : [36, 39],
            'magenta'   : [35, 39],
            'blue'      : [34, 39],
            'yellow'    : [33, 39],
            'green'     : [32, 39],
            'red'       : [31, 39],
            'grey'      : [90, 39]
        }, endCode;
    
        if (style && codes[style]) {
            endCode = (codes[style][1] === 39 && styles.all) ? codes[styles.all][0]
                                                             : codes[style][1];
            return '\033[' + codes[style][0] + 'm' + str +
                   '\033[' + endCode + 'm';
        } else { return str }
    };
    
    // Convert any object to a string, ready for output.
    // When an 'array' or an 'object' are encountered, they are
    // passed to specialized functions, which can then recursively call
    // stringify().
    function stringify(obj, options) {
        var that = this, stylize = function (str, style) {
            return eyes.stylize(str, options.styles[style], options.styles)
        }, index, result;
    
        if ((index = stack.indexOf(obj)) !== -1) {
            return stylize(new(Array)(stack.length - index + 1).join('.'), 'special');
        }
        stack.push(obj);
    
        result = (function (obj) {
            switch (typeOf(obj)) {
                case "string"   : obj = stringifyString(obj.indexOf("'") === -1 ? "'" + obj + "'"
                                                                                : '"' + obj + '"');
                                  return stylize(obj, 'string');
                case "regexp"   : return stylize('/' + obj.source + '/', 'regexp');
                case "number"   : return stylize(obj + '',    'number');
                case "function" : return options.stream ? stylize("Function", 'other') : '[Function]';
                case "null"     : return stylize("null",      'special');
                case "undefined": return stylize("undefined", 'special');
                case "boolean"  : return stylize(obj + '',    'bool');
                case "date"     : return stylize(obj.toUTCString());
                case "array"    : return stringifyArray(obj,  options, stack.length);
                case "object"   : return stringifyObject(obj, options, stack.length);
            }
        })(obj);
    
        stack.pop();
        return result;
    };
    
    // Escape invisible characters in a string
    function stringifyString (str, options) {
        return str.replace(/\\/g, '\\\\')
                  .replace(/\n/g, '\\n')
                  .replace(/[\u0001-\u001F]/g, function (match) {
                      return '\\0' + match[0].charCodeAt(0).toString(8);
                  });
    }
    
    // Convert an array to a string, such as [1, 2, 3].
    // This function calls stringify() for each of the elements
    // in the array.
    function stringifyArray(ary, options, level) {
        var out = [];
        var pretty = options.pretty && (ary.length > 4 || ary.some(function (o) {
            return (o !== null && typeof(o) === 'object' && Object.keys(o).length > 0) ||
                   (Array.isArray(o) && o.length > 0);
        }));
        var ws = pretty ? '\n' + new(Array)(level * 4 + 1).join(' ') : ' ';
    
        for (var i = 0; i < ary.length; i++) {
            out.push(stringify(ary[i], options));
        }
    
        if (out.length === 0) {
            return '[]';
        } else {
            return '[' + ws
                       + out.join(',' + (pretty ? ws : ' '))
                       + (pretty ? ws.slice(0, -4) : ws) +
                   ']';
        }
    };
    
    // Convert an object to a string, such as {a: 1}.
    // This function calls stringify() for each of its values,
    // and does not output functions or prototype values.
    function stringifyObject(obj, options, level) {
        var out = [];
        var pretty = options.pretty && (Object.keys(obj).length > 2 ||
                                        Object.keys(obj).some(function (k) { return typeof(obj[k]) === 'object' }));
        var ws = pretty ? '\n' + new(Array)(level * 4 + 1).join(' ') : ' ';
    
        var keys = options.showHidden ? Object.keys(obj) : Object.getOwnPropertyNames(obj);
        keys.forEach(function (k) {
            if (Object.prototype.hasOwnProperty.call(obj, k) 
              && !(obj[k] instanceof Function && options.hideFunctions)) {
                out.push(eyes.stylize(k, options.styles.key, options.styles) + ': ' +
                         stringify(obj[k], options));
            }
        });
    
        if (out.length === 0) {
            return '{}';
        } else {
            return "{" + ws
                       + out.join(',' + (pretty ? ws : ' '))
                       + (pretty ? ws.slice(0, -4) : ws) +
                   "}";
       }
    };
    
    // A better `typeof`
    function typeOf(value) {
        var s = typeof(value),
            types = [Object, Array, String, RegExp, Number, Function, Boolean, Date];
    
        if (s === 'object' || s === 'function') {
            if (value) {
                types.forEach(function (t) {
                    if (value instanceof t) { s = t.name.toLowerCase() }
                });
            } else { s = 'null' }
        }
        return s;
    }
    
    function merge(/* variable args */) {
        var objs = Array.prototype.slice.call(arguments);
        var target = {};
    
        objs.forEach(function (o) {
            Object.keys(o).forEach(function (k) {
                if (k === 'styles') {
                    if (! o.styles) {
                        target.styles = false;
                    } else {
                        target.styles = {}
                        for (var s in o.styles) {
                            target.styles[s] = o.styles[s];
                        }
                    }
                } else {
                    target[k] = o[k];
                }
            });
        });
        return target;
    }
    
    
  provide("eyes", module.exports);
}(global));

// pakmanager:isstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stream = require('stream')
    
    
    function isStream (obj) {
      return obj instanceof stream.Stream
    }
    
    
    function isReadable (obj) {
      return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
    }
    
    
    function isWritable (obj) {
      return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
    }
    
    
    function isDuplex (obj) {
      return isReadable(obj) && isWritable(obj)
    }
    
    
    module.exports            = isStream
    module.exports.isReadable = isReadable
    module.exports.isWritable = isWritable
    module.exports.isDuplex   = isDuplex
    
  provide("isstream", module.exports);
}(global));

// pakmanager:pkginfo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * pkginfo.js: Top-level include for the pkginfo module
     *
     * (C) 2011, Charlie Robbins
     *
     */
     
    var fs = require('fs'),
        path = require('path');
    
    //
    // ### function pkginfo ([options, 'property', 'property' ..])
    // #### @pmodule {Module} Parent module to read from.
    // #### @options {Object|Array|string} **Optional** Options used when exposing properties.
    // #### @arguments {string...} **Optional** Specified properties to expose.
    // Exposes properties from the package.json file for the parent module on 
    // it's exports. Valid usage:
    //
    // ` require('pkginfo')()`
    //
    // ` require('pkginfo')('version', 'author');`
    //
    // ` require('pkginfo')(['version', 'author']);`
    //
    // ` require('pkginfo')({ include: ['version', 'author'] });`
    //
    var pkginfo = module.exports = function (pmodule, options) {
      var args = [].slice.call(arguments, 2).filter(function (arg) {
        return typeof arg === 'string';
      });
      
      //
      // **Parse variable arguments**
      //
      if (Array.isArray(options)) {
        //
        // If the options passed in is an Array assume that
        // it is the Array of properties to expose from the
        // on the package.json file on the parent module.
        //
        options = { include: options };
      }
      else if (typeof options === 'string') {
        //
        // Otherwise if the first argument is a string, then
        // assume that it is the first property to expose from
        // the package.json file on the parent module.
        //
        options = { include: [options] };
      }
      
      //
      // **Setup default options**
      //
      options = options || {};
      
      // ensure that includes have been defined
      options.include = options.include || [];
      
      if (args.length > 0) {
        //
        // If additional string arguments have been passed in
        // then add them to the properties to expose on the 
        // parent module. 
        //
        options.include = options.include.concat(args);
      }
      
      var pkg = pkginfo.read(pmodule, options.dir).package;
      Object.keys(pkg).forEach(function (key) {
        if (options.include.length > 0 && !~options.include.indexOf(key)) {
          return;
        }
        
        if (!pmodule.exports[key]) {
          pmodule.exports[key] = pkg[key];
        }
      });
      
      return pkginfo;
    };
    
    //
    // ### function find (dir)
    // #### @pmodule {Module} Parent module to read from.
    // #### @dir {string} **Optional** Directory to start search from.
    // Searches up the directory tree from `dir` until it finds a directory
    // which contains a `package.json` file. 
    //
    pkginfo.find = function (pmodule, dir) {
      if (! dir) {
        dir = path.dirname(pmodule.filename);
      }
      
      var files = fs.readdirSync(dir);
      
      if (~files.indexOf('package.json')) {
        return path.join(dir, 'package.json');
      }
      
      if (dir === '/') {
        throw new Error('Could not find package.json up from: ' + dir);
      }
      else if (!dir || dir === '.') {
        throw new Error('Cannot find package.json from unspecified directory');
      }
      
      return pkginfo.find(pmodule, path.dirname(dir));
    };
    
    //
    // ### function read (pmodule, dir)
    // #### @pmodule {Module} Parent module to read from.
    // #### @dir {string} **Optional** Directory to start search from.
    // Searches up the directory tree from `dir` until it finds a directory
    // which contains a `package.json` file and returns the package information.
    //
    pkginfo.read = function (pmodule, dir) { 
      dir = pkginfo.find(pmodule, dir);
      
      var data = fs.readFileSync(dir).toString();
          
      return {
        dir: dir, 
        package: JSON.parse(data)
      };
    };
    
    //
    // Call `pkginfo` on this module and expose version.
    //
    pkginfo(module, {
      dir: __dirname,
      include: ['version'],
      target: pkginfo
    });
  provide("pkginfo", module.exports);
}(global));

// pakmanager:stack-trace
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
    
      var dummyObject = {};
    
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject, v8StackTrace) {
        return v8StackTrace;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports.get);
    
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
    
      return v8StackTrace;
    };
    
    exports.parse = function(err) {
      if (!err.stack) {
        return [];
      }
    
      var self = this;
      var lines = err.stack.split('\n').slice(1);
    
      return lines
        .map(function(line) {
          if (line.match(/^\s*[-]{4,}$/)) {
            return self._createParsedCallSite({
              fileName: line,
              lineNumber: null,
              functionName: null,
              typeName: null,
              methodName: null,
              columnNumber: null,
              'native': null,
            });
          }
    
          var lineMatch = line.match(/at (?:(.+)\s+)?\(?(?:(.+?):(\d+):(\d+)|([^)]+))\)?/);
          if (!lineMatch) {
            return;
          }
    
          var object = null;
          var method = null;
          var functionName = null;
          var typeName = null;
          var methodName = null;
          var isNative = (lineMatch[5] === 'native');
    
          if (lineMatch[1]) {
            var methodMatch = lineMatch[1].match(/([^\.]+)(?:\.(.+))?/);
            object = methodMatch[1];
            method = methodMatch[2];
            functionName = lineMatch[1];
            typeName = 'Object';
          }
    
          if (method) {
            typeName = object;
            methodName = method;
          }
    
          if (method === '<anonymous>') {
            methodName = null;
            functionName = '';
          }
    
          var properties = {
            fileName: lineMatch[2] || null,
            lineNumber: parseInt(lineMatch[3], 10) || null,
            functionName: functionName,
            typeName: typeName,
            methodName: methodName,
            columnNumber: parseInt(lineMatch[4], 10) || null,
            'native': isNative,
          };
    
          return self._createParsedCallSite(properties);
        })
        .filter(function(callSite) {
          return !!callSite;
        });
    };
    
    exports._createParsedCallSite = function(properties) {
      var methods = {};
      for (var property in properties) {
        var prefix = 'get';
        if (property === 'native') {
          prefix = 'is';
        }
        var method = prefix + property.substr(0, 1).toUpperCase() + property.substr(1);
    
        (function(property) {
          methods[method] = function() {
            return properties[property];
          }
        })(property);
      }
    
      var callSite = Object.create(methods);
      for (var property in properties) {
        callSite[property] = properties[property];
      }
    
      return callSite;
    };
    
  provide("stack-trace", module.exports);
}(global));

// pakmanager:jsonlint
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* Jison generated parser */
    var jsonlint = (function(){
    var parser = {trace: function trace() { },
    yy: {},
    symbols_: {"error":2,"JSONString":3,"STRING":4,"JSONNumber":5,"NUMBER":6,"JSONNullLiteral":7,"NULL":8,"JSONBooleanLiteral":9,"TRUE":10,"FALSE":11,"JSONText":12,"JSONValue":13,"EOF":14,"JSONObject":15,"JSONArray":16,"{":17,"}":18,"JSONMemberList":19,"JSONMember":20,":":21,",":22,"[":23,"]":24,"JSONElementList":25,"$accept":0,"$end":1},
    terminals_: {2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},
    productions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],
    performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {
    
    var $0 = $$.length - 1;
    switch (yystate) {
    case 1: // replace escaped characters with actual character
              this.$ = yytext.replace(/\\(\\|")/g, "$"+"1")
                         .replace(/\\n/g,'\n')
                         .replace(/\\r/g,'\r')
                         .replace(/\\t/g,'\t')
                         .replace(/\\v/g,'\v')
                         .replace(/\\f/g,'\f')
                         .replace(/\\b/g,'\b');
            
    break;
    case 2:this.$ = Number(yytext);
    break;
    case 3:this.$ = null;
    break;
    case 4:this.$ = true;
    break;
    case 5:this.$ = false;
    break;
    case 6:return this.$ = $$[$0-1];
    break;
    case 13:this.$ = {};
    break;
    case 14:this.$ = $$[$0-1];
    break;
    case 15:this.$ = [$$[$0-2], $$[$0]];
    break;
    case 16:this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
    break;
    case 17:this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];
    break;
    case 18:this.$ = [];
    break;
    case 19:this.$ = $$[$0-1];
    break;
    case 20:this.$ = [$$[$0]];
    break;
    case 21:this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);
    break;
    }
    },
    table: [{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],
    defaultActions: {16:[2,6]},
    parseError: function parseError(str, hash) {
        throw new Error(str);
    },
    parse: function parse(input) {
        var self = this,
            stack = [0],
            vstack = [null], // semantic value stack
            lstack = [], // location stack
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            recovering = 0,
            TERROR = 2,
            EOF = 1;
    
        //this.reductionCount = this.shiftCount = 0;
    
        this.lexer.setInput(input);
        this.lexer.yy = this.yy;
        this.yy.lexer = this.lexer;
        if (typeof this.lexer.yylloc == 'undefined')
            this.lexer.yylloc = {};
        var yyloc = this.lexer.yylloc;
        lstack.push(yyloc);
    
        if (typeof this.yy.parseError === 'function')
            this.parseError = this.yy.parseError;
    
        function popStack (n) {
            stack.length = stack.length - 2*n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
        }
    
        function lex() {
            var token;
            token = self.lexer.lex() || 1; // $end = 1
            // if token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    
        var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;
        while (true) {
            // retreive state number from top of stack
            state = stack[stack.length-1];
    
            // use default actions if available
            if (this.defaultActions[state]) {
                action = this.defaultActions[state];
            } else {
                if (symbol == null)
                    symbol = lex();
                // read action for current state and first input
                action = table[state] && table[state][symbol];
            }
    
            // handle parse error
            _handle_error:
            if (typeof action === 'undefined' || !action.length || !action[0]) {
    
                if (!recovering) {
                    // Report error
                    expected = [];
                    for (p in table[state]) if (this.terminals_[p] && p > 2) {
                        expected.push("'"+this.terminals_[p]+"'");
                    }
                    var errStr = '';
                    if (this.lexer.showPosition) {
                        errStr = 'Parse error on line '+(yylineno+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + this.terminals_[symbol]+ "'";
                    } else {
                        errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                      (symbol == 1 /*EOF*/ ? "end of input" :
                                                  ("'"+(this.terminals_[symbol] || symbol)+"'"));
                    }
                    this.parseError(errStr,
                        {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
                }
    
                // just recovered from another error
                if (recovering == 3) {
                    if (symbol == EOF) {
                        throw new Error(errStr || 'Parsing halted.');
                    }
    
                    // discard current lookahead and grab another
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    symbol = lex();
                }
    
                // try to recover from error
                while (1) {
                    // check for error recovery rule in this state
                    if ((TERROR.toString()) in table[state]) {
                        break;
                    }
                    if (state == 0) {
                        throw new Error(errStr || 'Parsing halted.');
                    }
                    popStack(1);
                    state = stack[stack.length-1];
                }
    
                preErrorSymbol = symbol; // save the lookahead token
                symbol = TERROR;         // insert generic error symbol as new lookahead
                state = stack[stack.length-1];
                action = table[state] && table[state][TERROR];
                recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
            }
    
            // this shouldn't happen, unless resolve defaults are off
            if (action[0] instanceof Array && action.length > 1) {
                throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
            }
    
            switch (action[0]) {
    
                case 1: // shift
                    //this.shiftCount++;
    
                    stack.push(symbol);
                    vstack.push(this.lexer.yytext);
                    lstack.push(this.lexer.yylloc);
                    stack.push(action[1]); // push state
                    symbol = null;
                    if (!preErrorSymbol) { // normal execution/no error
                        yyleng = this.lexer.yyleng;
                        yytext = this.lexer.yytext;
                        yylineno = this.lexer.yylineno;
                        yyloc = this.lexer.yylloc;
                        if (recovering > 0)
                            recovering--;
                    } else { // error just occurred, resume old lookahead f/ before error
                        symbol = preErrorSymbol;
                        preErrorSymbol = null;
                    }
                    break;
    
                case 2: // reduce
                    //this.reductionCount++;
    
                    len = this.productions_[action[1]][1];
    
                    // perform semantic action
                    yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                    // default location, uses first token for firsts, last for lasts
                    yyval._$ = {
                        first_line: lstack[lstack.length-(len||1)].first_line,
                        last_line: lstack[lstack.length-1].last_line,
                        first_column: lstack[lstack.length-(len||1)].first_column,
                        last_column: lstack[lstack.length-1].last_column
                    };
                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
    
                    if (typeof r !== 'undefined') {
                        return r;
                    }
    
                    // pop off stack
                    if (len) {
                        stack = stack.slice(0,-1*len*2);
                        vstack = vstack.slice(0, -1*len);
                        lstack = lstack.slice(0, -1*len);
                    }
    
                    stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                    vstack.push(yyval.$);
                    lstack.push(yyval._$);
                    // goto new state = table[STATE][NONTERMINAL]
                    newState = table[stack[stack.length-2]][stack[stack.length-1]];
                    stack.push(newState);
                    break;
    
                case 3: // accept
                    return true;
            }
    
        }
    
        return true;
    }};
    /* Jison generated lexer */
    var lexer = (function(){
    var lexer = ({EOF:1,
    parseError:function parseError(str, hash) {
            if (this.yy.parseError) {
                this.yy.parseError(str, hash);
            } else {
                throw new Error(str);
            }
        },
    setInput:function (input) {
            this._input = input;
            this._more = this._less = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = '';
            this.conditionStack = ['INITIAL'];
            this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
            return this;
        },
    input:function () {
            var ch = this._input[0];
            this.yytext+=ch;
            this.yyleng++;
            this.match+=ch;
            this.matched+=ch;
            var lines = ch.match(/\n/);
            if (lines) this.yylineno++;
            this._input = this._input.slice(1);
            return ch;
        },
    unput:function (ch) {
            this._input = ch + this._input;
            return this;
        },
    more:function () {
            this._more = true;
            return this;
        },
    less:function (n) {
            this._input = this.match.slice(n) + this._input;
        },
    pastInput:function () {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
        },
    upcomingInput:function () {
            var next = this.match;
            if (next.length < 20) {
                next += this._input.substr(0, 20-next.length);
            }
            return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
        },
    showPosition:function () {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c+"^";
        },
    next:function () {
            if (this.done) {
                return this.EOF;
            }
            if (!this._input) this.done = true;
    
            var token,
                match,
                tempMatch,
                index,
                col,
                lines;
            if (!this._more) {
                this.yytext = '';
                this.match = '';
            }
            var rules = this._currentRules();
            for (var i=0;i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                    match = tempMatch;
                    index = i;
                    if (!this.options.flex) break;
                }
            }
            if (match) {
                lines = match[0].match(/\n.*/g);
                if (lines) this.yylineno += lines.length;
                this.yylloc = {first_line: this.yylloc.last_line,
                               last_line: this.yylineno+1,
                               first_column: this.yylloc.last_column,
                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}
                this.yytext += match[0];
                this.match += match[0];
                this.yyleng = this.yytext.length;
                this._more = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
                if (this.done && this._input) this.done = false;
                if (token) return token;
                else return;
            }
            if (this._input === "") {
                return this.EOF;
            } else {
                this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(), 
                        {text: "", token: null, line: this.yylineno});
            }
        },
    lex:function lex() {
            var r = this.next();
            if (typeof r !== 'undefined') {
                return r;
            } else {
                return this.lex();
            }
        },
    begin:function begin(condition) {
            this.conditionStack.push(condition);
        },
    popState:function popState() {
            return this.conditionStack.pop();
        },
    _currentRules:function _currentRules() {
            return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
        },
    topState:function () {
            return this.conditionStack[this.conditionStack.length-2];
        },
    pushState:function begin(condition) {
            this.begin(condition);
        }});
    lexer.options = {};
    lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
    
    var YYSTATE=YY_START
    switch($avoiding_name_collisions) {
    case 0:/* skip whitespace */
    break;
    case 1:return 6
    break;
    case 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4
    break;
    case 3:return 17
    break;
    case 4:return 18
    break;
    case 5:return 23
    break;
    case 6:return 24
    break;
    case 7:return 22
    break;
    case 8:return 21
    break;
    case 9:return 10
    break;
    case 10:return 11
    break;
    case 11:return 8
    break;
    case 12:return 14
    break;
    case 13:return 'INVALID'
    break;
    }
    };
    lexer.rules = [/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/];
    lexer.conditions = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}};
    
    
    ;
    return lexer;})()
    parser.lexer = lexer;
    return parser;
    })();
    if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
    exports.parser = jsonlint;
    exports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); }
    exports.main = function commonjsMain(args) {
        if (!args[1])
            throw new Error('Usage: '+args[0]+' FILE');
        if (typeof process !== 'undefined') {
            var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), "utf8");
        } else {
            var cwd = require("file").path(require("file").cwd());
            var source = cwd.join(args[1]).read({charset: "utf-8"});
        }
        return exports.parser.parse(source);
    }
    if (typeof module !== 'undefined' && require.main === module) {
      exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require("system").args);
    }
    }
  provide("jsonlint", module.exports);
}(global));

// pakmanager:ejs/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * EJS Embedded JavaScript templates
     * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
    */
    
    /**
     * Private utility functions
     * @module utils
     * @private
     */
    
    'use strict';
    
    var regExpChars = /[|\\{}()[\]^$+*?.]/g;
    
    /**
     * Escape characters reserved in regular expressions.
     *
     * If `string` is `undefined` or `null`, the empty string is returned.
     *
     * @param {String} string Input string
     * @return {String} Escaped string
     * @static
     * @private
     */
    exports.escapeRegExpChars = function (string) {
      // istanbul ignore if
      if (!string) {
        return '';
      }
      return String(string).replace(regExpChars, '\\$&');
    };
    
    var _ENCODE_HTML_RULES = {
          '&': '&amp;'
        , '<': '&lt;'
        , '>': '&gt;'
        , '"': '&#34;'
        , "'": '&#39;'
        }
      , _MATCH_HTML = /[&<>\'"]/g;
    
    function encode_char(c) {
      return _ENCODE_HTML_RULES[c] || c;
    };
    
    /**
     * Stringified version of constants used by {@link module:utils.escapeXML}.
     *
     * It is used in the process of generating {@link ClientFunction}s.
     *
     * @readonly
     * @type {String}
     */
    
    var escapeFuncStr =
      'var _ENCODE_HTML_RULES = {\n'
    + '      "&": "&amp;"\n'
    + '    , "<": "&lt;"\n'
    + '    , ">": "&gt;"\n'
    + '    , \'"\': "&#34;"\n'
    + '    , "\'": "&#39;"\n'
    + '    }\n'
    + '  , _MATCH_HTML = /[&<>\'"]/g;\n'
    + 'function encode_char(c) {\n'
    + '  return _ENCODE_HTML_RULES[c] || c;\n'
    + '};\n';
    
    /**
     * Escape characters reserved in XML.
     *
     * If `markup` is `undefined` or `null`, the empty string is returned.
     *
     * @implements {EscapeCallback}
     * @param {String} markup Input string
     * @return {String} Escaped string
     * @static
     * @private
     */
    
    exports.escapeXML = function (markup) {
      return markup == undefined
        ? ''
        : String(markup)
            .replace(_MATCH_HTML, encode_char);
    };
    exports.escapeXML.toString = function () {
      return Function.prototype.toString.call(this) + ';\n' + escapeFuncStr
    };
    
    /**
     * Copy all properties from one object to another, in a shallow fashion.
     *
     * @param  {Object} to   Destination object
     * @param  {Object} from Source object
     * @return {Object}      Destination object
     * @static
     * @private
     */
    exports.shallowCopy = function (to, from) {
      from = from || {};
      for (var p in from) {
        to[p] = from[p];
      }
      return to;
    };
    
    /**
     * Simple in-process cache implementation. Does not implement limits of any
     * sort.
     *
     * @implements Cache
     * @static
     * @private
     */
    exports.cache = {
      _data: {},
      set: function (key, val) {
        this._data[key] = val;
      },
      get: function (key) {
        return this._data[key];
      },
      reset: function () {
        this._data = {};
      }
    };
    
    
  provide("ejs/lib/utils", module.exports);
}(global));

// pakmanager:ejs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * EJS Embedded JavaScript templates
     * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
    */
    
    'use strict';
    
    /**
     * @file Embedded JavaScript templating engine.
     * @author Matthew Eernisse <mde@fleegix.org>
     * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
     * @project EJS
     * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
     */
    
    /**
     * EJS internal functions.
     *
     * Technically this "module" lies in the same file as {@link module:ejs}, for
     * the sake of organization all the private functions re grouped into this
     * module.
     *
     * @module ejs-internal
     * @private
     */
    
    /**
     * Embedded JavaScript templating engine.
     *
     * @module ejs
     * @public
     */
    
    var fs = require('fs')
      , utils =  require('ejs/lib/utils')
      , scopeOptionWarned = false
      , _VERSION_STRING = require('../package.json').version
      , _DEFAULT_DELIMITER = '%'
      , _DEFAULT_LOCALS_NAME = 'locals'
      , _REGEX_STRING = '(<%%|<%=|<%-|<%#|<%|%>|-%>)'
      , _OPTS = [ 'cache', 'filename', 'delimiter', 'scope', 'context'
                , 'debug', 'compileDebug', 'client', '_with'
                ]
      , _TRAILING_SEMCOL = /;\s*$/
      , _BOM = /^\uFEFF/;
    
    /**
     * EJS template function cache. This can be a LRU object from lru-cache NPM
     * module. By default, it is {@link module:utils.cache}, a simple in-process
     * cache that grows continuously.
     *
     * @type {Cache}
     */
    
    exports.cache = utils.cache;
    
    /**
     * Name of the object containing the locals.
     *
     * This variable is overriden by {@link Options}`.localsName` if it is not
     * `undefined`.
     *
     * @type {String}
     * @public
     */
    
    exports.localsName = _DEFAULT_LOCALS_NAME;
    
    /**
     * Get the path to the included file from the parent file path and the
     * specified path.
     *
     * @param {String} name     specified path
     * @param {String} filename parent file path
     * @return {String}
     */
    
    exports.resolveInclude = function(name, filename) {
      var path = require('path')
        , dirname = path.dirname
        , extname = path.extname
        , resolve = path.resolve
        , includePath = resolve(dirname(filename), name)
        , ext = extname(name);
      if (!ext) {
        includePath += '.ejs';
      }
      return includePath;
    };
    
    /**
     * Get the template from a string or a file, either compiled on-the-fly or
     * read from cache (if enabled), and cache the template if needed.
     *
     * If `template` is not set, the file specified in `options.filename` will be
     * read.
     *
     * If `options.cache` is true, this function reads the file from
     * `options.filename` so it must be set prior to calling this function.
     *
     * @memberof module:ejs-internal
     * @param {Options} options   compilation options
     * @param {String} [template] template source
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `options.client`, either type might be returned.
     * @static
     */
    
    function handleCache(options, template) {
      var fn
        , path = options.filename
        , hasTemplate = arguments.length > 1;
    
      if (options.cache) {
        if (!path) {
          throw new Error('cache option requires a filename');
        }
        fn = exports.cache.get(path);
        if (fn) {
          return fn;
        }
        if (!hasTemplate) {
          template = fs.readFileSync(path).toString().replace(_BOM, '');
        }
      }
      else if (!hasTemplate) {
        // istanbul ignore if: should not happen at all
        if (!path) {
          throw new Error('Internal EJS error: no file name or template '
                        + 'provided');
        }
        template = fs.readFileSync(path).toString().replace(_BOM, '');
      }
      fn = exports.compile(template, options);
      if (options.cache) {
        exports.cache.set(path, fn);
      }
      return fn;
    }
    
    /**
     * Get the template function.
     *
     * If `options.cache` is `true`, then the template is cached.
     *
     * @memberof module:ejs-internal
     * @param {String}  path    path for the specified file
     * @param {Options} options compilation options
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `options.client`, either type might be returned
     * @static
     */
    
    function includeFile(path, options) {
      var opts = utils.shallowCopy({}, options);
      if (!opts.filename) {
        throw new Error('`include` requires the \'filename\' option.');
      }
      opts.filename = exports.resolveInclude(path, opts.filename);
      return handleCache(opts);
    }
    
    /**
     * Get the JavaScript source of an included file.
     *
     * @memberof module:ejs-internal
     * @param {String}  path    path for the specified file
     * @param {Options} options compilation options
     * @return {String}
     * @static
     */
    
    function includeSource(path, options) {
      var opts = utils.shallowCopy({}, options)
        , includePath
        , template;
      if (!opts.filename) {
        throw new Error('`include` requires the \'filename\' option.');
      }
      includePath = exports.resolveInclude(path, opts.filename);
      template = fs.readFileSync(includePath).toString().replace(_BOM, '');
    
      opts.filename = includePath;
      var templ = new Template(template, opts);
      templ.generateSource();
      return templ.source;
    }
    
    /**
     * Re-throw the given `err` in context to the `str` of ejs, `filename`, and
     * `lineno`.
     *
     * @implements RethrowCallback
     * @memberof module:ejs-internal
     * @param {Error}  err      Error object
     * @param {String} str      EJS source
     * @param {String} filename file name of the EJS file
     * @param {String} lineno   line number of the error
     * @static
     */
    
    function rethrow(err, str, filename, lineno){
      var lines = str.split('\n')
        , start = Math.max(lineno - 3, 0)
        , end = Math.min(lines.length, lineno + 3);
    
      // Error context
      var context = lines.slice(start, end).map(function (line, i){
        var curr = i + start + 1;
        return (curr == lineno ? ' >> ' : '    ')
          + curr
          + '| '
          + line;
      }).join('\n');
    
      // Alter exception message
      err.path = filename;
      err.message = (filename || 'ejs') + ':'
        + lineno + '\n'
        + context + '\n\n'
        + err.message;
    
      throw err;
    }
    
    /**
     * Copy properties in data object that are recognized as options to an
     * options object.
     *
     * This is used for compatibility with earlier versions of EJS and Express.js.
     *
     * @memberof module:ejs-internal
     * @param {Object}  data data object
     * @param {Options} opts options object
     * @static
     */
    
    function cpOptsInData(data, opts) {
      _OPTS.forEach(function (p) {
        if (typeof data[p] != 'undefined') {
          opts[p] = data[p];
        }
      });
    }
    
    /**
     * Compile the given `str` of ejs into a template function.
     *
     * @param {String}  template EJS template
     *
     * @param {Options} opts     compilation options
     *
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `opts.client`, either type might be returned.
     * @public
     */
    
    exports.compile = function compile(template, opts) {
      var templ;
    
      // v1 compat
      // 'scope' is 'context'
      // FIXME: Remove this in a future version
      if (opts && opts.scope) {
        if (!scopeOptionWarned){
          console.warn('`scope` option is deprecated and will be removed in EJS 3');
          scopeOptionWarned = true;
        }
        if (!opts.context) {
          opts.context = opts.scope;
        }
        delete opts.scope;
      }
      templ = new Template(template, opts);
      return templ.compile();
    };
    
    /**
     * Render the given `template` of ejs.
     *
     * If you would like to include options but not data, you need to explicitly
     * call this function with `data` being an empty object or `null`.
     *
     * @param {String}   template EJS template
     * @param {Object}  [data={}] template data
     * @param {Options} [opts={}] compilation and rendering options
     * @return {String}
     * @public
     */
    
    exports.render = function (template, data, opts) {
      data = data || {};
      opts = opts || {};
      var fn;
    
      // No options object -- if there are optiony names
      // in the data, copy them to options
      if (arguments.length == 2) {
        cpOptsInData(data, opts);
      }
    
      return handleCache(opts, template)(data);
    };
    
    /**
     * Render an EJS file at the given `path` and callback `cb(err, str)`.
     *
     * If you would like to include options but not data, you need to explicitly
     * call this function with `data` being an empty object or `null`.
     *
     * @param {String}             path     path to the EJS file
     * @param {Object}            [data={}] template data
     * @param {Options}           [opts={}] compilation and rendering options
     * @param {RenderFileCallback} cb callback
     * @public
     */
    
    exports.renderFile = function () {
      var args = Array.prototype.slice.call(arguments)
        , path = args.shift()
        , cb = args.pop()
        , data = args.shift() || {}
        , opts = args.pop() || {}
        , result;
    
      // Don't pollute passed in opts obj with new vals
      opts = utils.shallowCopy({}, opts);
    
      // No options object -- if there are optiony names
      // in the data, copy them to options
      if (arguments.length == 3) {
        cpOptsInData(data, opts);
      }
      opts.filename = path;
    
      try {
        result = handleCache(opts)(data);
      }
      catch(err) {
        return cb(err);
      }
      return cb(null, result);
    };
    
    /**
     * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.
     * @public
     */
    
    exports.clearCache = function () {
      exports.cache.reset();
    };
    
    function Template(text, opts) {
      opts = opts || {};
      var options = {};
      this.templateText = text;
      this.mode = null;
      this.truncate = false;
      this.currentLine = 1;
      this.source = '';
      this.dependencies = [];
      options.client = opts.client || false;
      options.escapeFunction = opts.escape || utils.escapeXML;
      options.compileDebug = opts.compileDebug !== false;
      options.debug = !!opts.debug;
      options.filename = opts.filename;
      options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
      options._with = typeof opts._with != 'undefined' ? opts._with : true;
      options.context = opts.context;
      options.cache = opts.cache || false;
      options.rmWhitespace = opts.rmWhitespace;
      this.opts = options;
    
      this.regex = this.createRegex();
    }
    
    Template.modes = {
      EVAL: 'eval'
    , ESCAPED: 'escaped'
    , RAW: 'raw'
    , COMMENT: 'comment'
    , LITERAL: 'literal'
    };
    
    Template.prototype = {
      createRegex: function () {
        var str = _REGEX_STRING
          , delim = utils.escapeRegExpChars(this.opts.delimiter);
        str = str.replace(/%/g, delim);
        return new RegExp(str);
      }
    
    , compile: function () {
        var src
          , fn
          , opts = this.opts
          , prepended = ''
          , appended = ''
          , escape = opts.escapeFunction;
    
        if (opts.rmWhitespace) {
          // Have to use two separate replace here as `^` and `$` operators don't
          // work well with `\r`.
          this.templateText =
            this.templateText.replace(/\r/g, '').replace(/^\s+|\s+$/gm, '');
        }
    
        if (!this.source) {
          this.generateSource();
          prepended += '  var __output = [], __append = __output.push.bind(__output);' + '\n';
          if (opts._with !== false) {
            prepended +=  '  with (' + exports.localsName + ' || {}) {' + '\n';
            appended += '  }' + '\n';
          }
          appended += '  return __output.join("");' + '\n';
          this.source = prepended + this.source + appended;
        }
    
        if (opts.compileDebug) {
          src = 'var __line = 1' + '\n'
              + '  , __lines = ' + JSON.stringify(this.templateText) + '\n'
              + '  , __filename = ' + (opts.filename ?
                    JSON.stringify(opts.filename) : 'undefined') + ';' + '\n'
              + 'try {' + '\n'
              + this.source
              + '} catch (e) {' + '\n'
              + '  rethrow(e, __lines, __filename, __line);' + '\n'
              + '}' + '\n';
        }
        else {
          src = this.source;
        }
    
        if (opts.debug) {
          console.log(src);
        }
    
        if (opts.client) {
          src = 'escape = escape || ' + escape.toString() + ';' + '\n' + src;
          if (opts.compileDebug) {
            src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\n' + src;
          }
        }
    
        try {
          fn = new Function(exports.localsName + ', escape, include, rethrow', src);
        }
        catch(e) {
          // istanbul ignore else
          if (e instanceof SyntaxError) {
            if (opts.filename) {
              e.message += ' in ' + opts.filename;
            }
            e.message += ' while compiling ejs';
          }
          throw e;
        }
    
        if (opts.client) {
          fn.dependencies = this.dependencies;
          return fn;
        }
    
        // Return a callable function which will execute the function
        // created by the source-code, with the passed data as locals
        // Adds a local `include` function which allows full recursive include
        var returnedFn = function (data) {
          var include = function (path, includeData) {
            var d = utils.shallowCopy({}, data);
            if (includeData) {
              d = utils.shallowCopy(d, includeData);
            }
            return includeFile(path, opts)(d);
          };
          return fn.apply(opts.context, [data || {}, escape, include, rethrow]);
        };
        returnedFn.dependencies = this.dependencies;
        return returnedFn;
      }
    
    , generateSource: function () {
        var self = this
          , matches = this.parseTemplateText()
          , d = this.opts.delimiter;
    
        if (matches && matches.length) {
          matches.forEach(function (line, index) {
            var closing
              , include
              , includeOpts
              , includeSrc;
            // If this is an opening tag, check for closing tags
            // FIXME: May end up with some false positives here
            // Better to store modes as k/v with '<' + delimiter as key
            // Then this can simply check against the map
            if ( line.indexOf('<' + d) === 0        // If it is a tag
              && line.indexOf('<' + d + d) !== 0) { // and is not escaped
              closing = matches[index + 2];
              if (!(closing == d + '>' || closing == '-' + d + '>')) {
                throw new Error('Could not find matching close tag for "' + line + '".');
              }
            }
            // HACK: backward-compat `include` preprocessor directives
            if ((include = line.match(/^\s*include\s+(\S+)/))) {
              includeOpts = utils.shallowCopy({}, self.opts);
              includeSrc = includeSource(include[1], includeOpts);
              includeSrc = '    ; (function(){' + '\n' + includeSrc + '    ; })()' + '\n';
              self.source += includeSrc;
              self.dependencies.push(exports.resolveInclude(
                include[1], includeOpts.filename));
            }
            else {
              self.scanLine(line);
            }
          });
        }
    
      }
    
    , parseTemplateText: function () {
        var str = this.templateText
          , pat = this.regex
          , result = pat.exec(str)
          , arr = []
          , firstPos
          , lastPos;
    
        while (result) {
          firstPos = result.index;
          lastPos = pat.lastIndex;
    
          if (firstPos !== 0) {
            arr.push(str.substring(0, firstPos));
            str = str.slice(firstPos);
          }
    
          arr.push(result[0]);
          str = str.slice(result[0].length);
          result = pat.exec(str);
        }
    
        if (str) {
          arr.push(str);
        }
    
        return arr;
      }
    
    , scanLine: function (line) {
        var self = this
          , d = this.opts.delimiter
          , newLineCount = 0;
    
        function _addOutput() {
          if (self.truncate) {
            line = line.replace('\n', '');
            self.truncate = false;
          }
          else if (self.opts.rmWhitespace) {
            // Gotta me more careful here.
            // .replace(/^(\s*)\n/, '$1') might be more appropriate here but as
            // rmWhitespace already removes trailing spaces anyway so meh.
            line = line.replace(/^\n/, '');
          }
          if (!line) {
            return;
          }
    
          // Preserve literal slashes
          line = line.replace(/\\/g, '\\\\');
    
          // Convert linebreaks
          line = line.replace(/\n/g, '\\n');
          line = line.replace(/\r/g, '\\r');
    
          // Escape double-quotes
          // - this will be the delimiter during execution
          line = line.replace(/"/g, '\\"');
          self.source += '    ; __append("' + line + '")' + '\n';
        }
    
        newLineCount = (line.split('\n').length - 1);
    
        switch (line) {
          case '<' + d:
            this.mode = Template.modes.EVAL;
            break;
          case '<' + d + '=':
            this.mode = Template.modes.ESCAPED;
            break;
          case '<' + d + '-':
            this.mode = Template.modes.RAW;
            break;
          case '<' + d + '#':
            this.mode = Template.modes.COMMENT;
            break;
          case '<' + d + d:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace('<' + d + d, '<' + d) + '")' + '\n';
            break;
          case d + '>':
          case '-' + d + '>':
            if (this.mode == Template.modes.LITERAL) {
              _addOutput();
            }
    
            this.mode = null;
            this.truncate = line.indexOf('-') === 0;
            break;
          default:
            // In script mode, depends on type of tag
            if (this.mode) {
              // If '//' is found without a line break, add a line break.
              switch (this.mode) {
                case Template.modes.EVAL:
                case Template.modes.ESCAPED:
                case Template.modes.RAW:
                  if (line.lastIndexOf('//') > line.lastIndexOf('\n')) {
                    line += '\n';
                  }
              }
              switch (this.mode) {
                // Just executing code
                case Template.modes.EVAL:
                  this.source += '    ; ' + line + '\n';
                  break;
                // Exec, esc, and output
                case Template.modes.ESCAPED:
                  this.source += '    ; __append(escape(' +
                    line.replace(_TRAILING_SEMCOL, '').trim() + '))' + '\n';
                  break;
                // Exec and output
                case Template.modes.RAW:
                  this.source += '    ; __append(' +
                    line.replace(_TRAILING_SEMCOL, '').trim() + ')' + '\n';
                  break;
                case Template.modes.COMMENT:
                  // Do nothing
                  break;
                // Literal <%% mode, append as raw output
                case Template.modes.LITERAL:
                  _addOutput();
                  break;
              }
            }
            // In string mode, just add the output
            else {
              _addOutput();
            }
        }
    
        if (self.opts.compileDebug && newLineCount) {
          this.currentLine += newLineCount;
          this.source += '    ; __line = ' + this.currentLine + '\n';
        }
      }
    };
    
    /**
     * Express.js support.
     *
     * This is an alias for {@link module:ejs.renderFile}, in order to support
     * Express.js out-of-the-box.
     *
     * @func
     */
    
    exports.__express = exports.renderFile;
    
    // Add require support
    /* istanbul ignore else */
    if (require.extensions) {
      require.extensions['.ejs'] = function (module, filename) {
        filename = filename || /* istanbul ignore next */ module.filename;
        var options = {
              filename: filename
            , client: true
            }
          , template = fs.readFileSync(filename).toString()
          , fn = exports.compile(template, options);
        module._compile('module.exports = ' + fn.toString() + ';', filename);
      };
    }
    
    /**
     * Version of EJS.
     *
     * @readonly
     * @type {String}
     * @public
     */
    
    exports.VERSION = _VERSION_STRING;
    
    /* istanbul ignore if */
    if (typeof window != 'undefined') {
      window.ejs = exports;
    }
    
  provide("ejs", module.exports);
}(global));

// pakmanager:debug
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var tty = require('tty');
    var util = require('util');
    
    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports =   require('debug');
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    
    /**
     * Colors.
     */
    
    exports.colors = [6, 2, 3, 4, 5, 1];
    
    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */
    
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    var stream = 1 === fd ? process.stdout :
                 2 === fd ? process.stderr :
                 createWritableStdioStream(fd);
    
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */
    
    function useColors() {
      var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
      if (0 === debugColors.length) {
        return tty.isatty(fd);
      } else {
        return '0' !== debugColors
            && 'no' !== debugColors
            && 'false' !== debugColors
            && 'disabled' !== debugColors;
      }
    }
    
    /**
     * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
     */
    
    var inspect = (4 === util.inspect.length ?
      // node <= 0.8.x
      function (v, colors) {
        return util.inspect(v, void 0, void 0, colors);
      } :
      // node > 0.8.x
      function (v, colors) {
        return util.inspect(v, { colors: colors });
      }
    );
    
    exports.formatters.o = function(v) {
      return inspect(v, this.useColors)
        .replace(/\s*\n\s*/g, ' ');
    };
    
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */
    
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      var name = this.namespace;
    
      if (useColors) {
        var c = this.color;
    
        args[0] = '  \u001b[3' + c + ';1m' + name + ' '
          + '\u001b[0m'
          + args[0] + '\u001b[3' + c + 'm'
          + ' +' + exports.humanize(this.diff) + '\u001b[0m';
      } else {
        args[0] = new Date().toUTCString()
          + ' ' + name + ' ' + args[0];
      }
      return args;
    }
    
    /**
     * Invokes `console.error()` with the specified arguments.
     */
    
    function log() {
      return stream.write(util.format.apply(this, arguments) + '\n');
    }
    
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    
    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    
    function load() {
      return process.env.DEBUG;
    }
    
    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */
    
    function createWritableStdioStream (fd) {
      var stream;
      var tty_wrap = process.binding('tty_wrap');
    
      // Note stream._type is used for test-module-load-list.js
    
      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          stream = new tty.WriteStream(fd);
          stream._type = 'tty';
    
          // Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        case 'FILE':
          var fs = require('fs');
          stream = new fs.SyncWriteStream(fd, { autoClose: false });
          stream._type = 'fs';
          break;
    
        case 'PIPE':
        case 'TCP':
          var net = require('net');
          stream = new net.Socket({
            fd: fd,
            readable: false,
            writable: true
          });
    
          // FIXME Should probably have an option in net.Socket to create a
          // stream from an existing fd which is writable only. But for now
          // we'll just add this hack and set the `readable` member to false.
          // Test: ./node test/fixtures/echo.js < /etc/passwd
          stream.readable = false;
          stream.read = null;
          stream._type = 'pipe';
    
          // FIXME Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stream file type!');
      }
    
      // For supporting legacy API we put the FD here.
      stream.fd = fd;
    
      stream._isStdio = true;
    
      return stream;
    }
    
    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */
    
    exports.enable(load());
    
  provide("debug", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    exports.extend = extend;
    
    // Older IE versions do not directly support indexOf so we must implement our own, sadly.
    exports.indexOf = indexOf;
    exports.escapeExpression = escapeExpression;
    exports.isEmpty = isEmpty;
    exports.blockParams = blockParams;
    exports.appendContextPath = appendContextPath;
    var escape = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#x27;',
      '`': '&#x60;'
    };
    
    var badChars = /[&<>"'`]/g,
        possible = /[&<>"'`]/;
    
    function escapeChar(chr) {
      return escape[chr];
    }
    
    function extend(obj /* , ...source */) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
    
      return obj;
    }
    
    var toString = Object.prototype.toString;
    
    exports.toString = toString;
    // Sourced from lodash
    // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
    /*eslint-disable func-style, no-var */
    var isFunction = function isFunction(value) {
      return typeof value === 'function';
    };
    // fallback for older versions of Chrome and Safari
    /* istanbul ignore next */
    if (isFunction(/x/)) {
      exports.isFunction = isFunction = function (value) {
        return typeof value === 'function' && toString.call(value) === '[object Function]';
      };
    }
    var isFunction;
    exports.isFunction = isFunction;
    /*eslint-enable func-style, no-var */
    
    /* istanbul ignore next */
    var isArray = Array.isArray || function (value) {
      return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
    };exports.isArray = isArray;
    
    function indexOf(array, value) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    }
    
    function escapeExpression(string) {
      if (typeof string !== 'string') {
        // don't escape SafeStrings, since they're already safe
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return '';
        } else if (!string) {
          return string + '';
        }
    
        // Force a string conversion as this will be done by the append regardless and
        // the regex test will do this transparently behind the scenes, causing issues if
        // an object's to string has escaped characters in it.
        string = '' + string;
      }
    
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    }
    
    function isEmpty(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + '.' : '') + id;
    }
  provide("handlebars/dist/cjs/handlebars/utils", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/exception
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    
    var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
    
    function Exception(message, node) {
      var loc = node && node.loc,
          line = undefined,
          column = undefined;
      if (loc) {
        line = loc.start.line;
        column = loc.start.column;
    
        message += ' - ' + line + ':' + column;
      }
    
      var tmp = Error.prototype.constructor.call(this, message);
    
      // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
      for (var idx = 0; idx < errorProps.length; idx++) {
        this[errorProps[idx]] = tmp[errorProps[idx]];
      }
    
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Exception);
      }
    
      if (loc) {
        this.lineNumber = line;
        this.column = column;
      }
    }
    
    Exception.prototype = new Error();
    
    exports['default'] = Exception;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/exception", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/ast
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    var AST = {
      Program: function Program(statements, blockParams, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'Program';
        this.body = statements;
    
        this.blockParams = blockParams;
        this.strip = strip;
      },
    
      MustacheStatement: function MustacheStatement(path, params, hash, escaped, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'MustacheStatement';
    
        this.path = path;
        this.params = params || [];
        this.hash = hash;
        this.escaped = escaped;
    
        this.strip = strip;
      },
    
      BlockStatement: function BlockStatement(path, params, hash, program, inverse, openStrip, inverseStrip, closeStrip, locInfo) {
        this.loc = locInfo;
        this.type = 'BlockStatement';
    
        this.path = path;
        this.params = params || [];
        this.hash = hash;
        this.program = program;
        this.inverse = inverse;
    
        this.openStrip = openStrip;
        this.inverseStrip = inverseStrip;
        this.closeStrip = closeStrip;
      },
    
      PartialStatement: function PartialStatement(name, params, hash, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'PartialStatement';
    
        this.name = name;
        this.params = params || [];
        this.hash = hash;
    
        this.indent = '';
        this.strip = strip;
      },
    
      ContentStatement: function ContentStatement(string, locInfo) {
        this.loc = locInfo;
        this.type = 'ContentStatement';
        this.original = this.value = string;
      },
    
      CommentStatement: function CommentStatement(comment, strip, locInfo) {
        this.loc = locInfo;
        this.type = 'CommentStatement';
        this.value = comment;
    
        this.strip = strip;
      },
    
      SubExpression: function SubExpression(path, params, hash, locInfo) {
        this.loc = locInfo;
    
        this.type = 'SubExpression';
        this.path = path;
        this.params = params || [];
        this.hash = hash;
      },
    
      PathExpression: function PathExpression(data, depth, parts, original, locInfo) {
        this.loc = locInfo;
        this.type = 'PathExpression';
    
        this.data = data;
        this.original = original;
        this.parts = parts;
        this.depth = depth;
      },
    
      StringLiteral: function StringLiteral(string, locInfo) {
        this.loc = locInfo;
        this.type = 'StringLiteral';
        this.original = this.value = string;
      },
    
      NumberLiteral: function NumberLiteral(number, locInfo) {
        this.loc = locInfo;
        this.type = 'NumberLiteral';
        this.original = this.value = Number(number);
      },
    
      BooleanLiteral: function BooleanLiteral(bool, locInfo) {
        this.loc = locInfo;
        this.type = 'BooleanLiteral';
        this.original = this.value = bool === 'true';
      },
    
      UndefinedLiteral: function UndefinedLiteral(locInfo) {
        this.loc = locInfo;
        this.type = 'UndefinedLiteral';
        this.original = this.value = undefined;
      },
    
      NullLiteral: function NullLiteral(locInfo) {
        this.loc = locInfo;
        this.type = 'NullLiteral';
        this.original = this.value = null;
      },
    
      Hash: function Hash(pairs, locInfo) {
        this.loc = locInfo;
        this.type = 'Hash';
        this.pairs = pairs;
      },
      HashPair: function HashPair(key, value, locInfo) {
        this.loc = locInfo;
        this.type = 'HashPair';
        this.key = key;
        this.value = value;
      },
    
      // Public API used to evaluate derived attributes regarding AST nodes
      helpers: {
        // a mustache is definitely a helper if:
        // * it is an eligible helper, and
        // * it has at least one parameter or hash segment
        helperExpression: function helperExpression(node) {
          return !!(node.type === 'SubExpression' || node.params.length || node.hash);
        },
    
        scopedId: function scopedId(path) {
          return /^\.|this\b/.test(path.original);
        },
    
        // an ID is simple if it only has one part, and that part is not
        // `..` or `this`.
        simpleId: function simpleId(path) {
          return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
        }
      }
    };
    
    // Must be exported as an object rather than the root of the module as the jison lexer
    // must modify the object to operate properly.
    exports['default'] = AST;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/compiler/ast", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.HandlebarsEnvironment = HandlebarsEnvironment;
    exports.createFrame = createFrame;
    
    var _import =  require('handlebars/dist/cjs/handlebars/utils');
    
    var Utils = _interopRequireWildcard(_import);
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var VERSION = '3.0.1';
    exports.VERSION = VERSION;
    var COMPILER_REVISION = 6;
    
    exports.COMPILER_REVISION = COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
      2: '== 1.0.0-rc.3',
      3: '== 1.0.0-rc.4',
      4: '== 1.x.x',
      5: '== 2.0.0-alpha.x',
      6: '>= 2.0.0-beta.1'
    };
    
    exports.REVISION_CHANGES = REVISION_CHANGES;
    var isArray = Utils.isArray,
        isFunction = Utils.isFunction,
        toString = Utils.toString,
        objectType = '[object Object]';
    
    function HandlebarsEnvironment(helpers, partials) {
      this.helpers = helpers || {};
      this.partials = partials || {};
    
      registerDefaultHelpers(this);
    }
    
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
    
      logger: logger,
      log: log,
    
      registerHelper: function registerHelper(name, fn) {
        if (toString.call(name) === objectType) {
          if (fn) {
            throw new _Exception2['default']('Arg not supported with multiple helpers');
          }
          Utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
    
      registerPartial: function registerPartial(name, partial) {
        if (toString.call(name) === objectType) {
          Utils.extend(this.partials, name);
        } else {
          if (typeof partial === 'undefined') {
            throw new _Exception2['default']('Attempting to register a partial as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      }
    };
    
    function registerDefaultHelpers(instance) {
      instance.registerHelper('helperMissing', function () {
        if (arguments.length === 1) {
          // A missing field in a {{foo}} constuct.
          return undefined;
        } else {
          // Someone is actually trying to call something, blow up.
          throw new _Exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
        }
      });
    
      instance.registerHelper('blockHelperMissing', function (context, options) {
        var inverse = options.inverse,
            fn = options.fn;
    
        if (context === true) {
          return fn(this);
        } else if (context === false || context == null) {
          return inverse(this);
        } else if (isArray(context)) {
          if (context.length > 0) {
            if (options.ids) {
              options.ids = [options.name];
            }
    
            return instance.helpers.each(context, options);
          } else {
            return inverse(this);
          }
        } else {
          if (options.data && options.ids) {
            var data = createFrame(options.data);
            data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
            options = { data: data };
          }
    
          return fn(context, options);
        }
      });
    
      instance.registerHelper('each', function (context, options) {
        if (!options) {
          throw new _Exception2['default']('Must pass iterator to #each');
        }
    
        var fn = options.fn,
            inverse = options.inverse,
            i = 0,
            ret = '',
            data = undefined,
            contextPath = undefined;
    
        if (options.data && options.ids) {
          contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
        }
    
        if (isFunction(context)) {
          context = context.call(this);
        }
    
        if (options.data) {
          data = createFrame(options.data);
        }
    
        function execIteration(field, index, last) {
          if (data) {
            data.key = field;
            data.index = index;
            data.first = index === 0;
            data.last = !!last;
    
            if (contextPath) {
              data.contextPath = contextPath + field;
            }
          }
    
          ret = ret + fn(context[field], {
            data: data,
            blockParams: Utils.blockParams([context[field], field], [contextPath + field, null])
          });
        }
    
        if (context && typeof context === 'object') {
          if (isArray(context)) {
            for (var j = context.length; i < j; i++) {
              execIteration(i, i, i === context.length - 1);
            }
          } else {
            var priorKey = undefined;
    
            for (var key in context) {
              if (context.hasOwnProperty(key)) {
                // We're running the iterations one step out of sync so we can detect
                // the last iteration without have to scan the object twice and create
                // an itermediate keys array.
                if (priorKey) {
                  execIteration(priorKey, i - 1);
                }
                priorKey = key;
                i++;
              }
            }
            if (priorKey) {
              execIteration(priorKey, i - 1, true);
            }
          }
        }
    
        if (i === 0) {
          ret = inverse(this);
        }
    
        return ret;
      });
    
      instance.registerHelper('if', function (conditional, options) {
        if (isFunction(conditional)) {
          conditional = conditional.call(this);
        }
    
        // Default behavior is to render the positive path if the value is truthy and not empty.
        // The `includeZero` option may be set to treat the condtional as purely not empty based on the
        // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
        if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {
          return options.inverse(this);
        } else {
          return options.fn(this);
        }
      });
    
      instance.registerHelper('unless', function (conditional, options) {
        return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
      });
    
      instance.registerHelper('with', function (context, options) {
        if (isFunction(context)) {
          context = context.call(this);
        }
    
        var fn = options.fn;
    
        if (!Utils.isEmpty(context)) {
          if (options.data && options.ids) {
            var data = createFrame(options.data);
            data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
            options = { data: data };
          }
    
          return fn(context, options);
        } else {
          return options.inverse(this);
        }
      });
    
      instance.registerHelper('log', function (message, options) {
        var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
        instance.log(level, message);
      });
    
      instance.registerHelper('lookup', function (obj, field) {
        return obj && obj[field];
      });
    }
    
    var logger = {
      methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },
    
      // State enum
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      level: 1,
    
      // Can be overridden in the host environment
      log: function log(level, message) {
        if (typeof console !== 'undefined' && logger.level <= level) {
          var method = logger.methodMap[level];
          (console[method] || console.log).call(console, message); // eslint-disable-line no-console
        }
      }
    };
    
    exports.logger = logger;
    var log = logger.log;
    
    exports.log = log;
    
    function createFrame(object) {
      var frame = Utils.extend({}, object);
      frame._parent = object;
      return frame;
    }
    
    /* [args, ]options */
  provide("handlebars/dist/cjs/handlebars/base", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/visitor
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    function Visitor() {
      this.parents = [];
    }
    
    Visitor.prototype = {
      constructor: Visitor,
      mutating: false,
    
      // Visits a given value. If mutating, will replace the value if necessary.
      acceptKey: function acceptKey(node, name) {
        var value = this.accept(node[name]);
        if (this.mutating) {
          // Hacky sanity check:
          if (value && (!value.type || !_AST2['default'][value.type])) {
            throw new _Exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
          }
          node[name] = value;
        }
      },
    
      // Performs an accept operation with added sanity check to ensure
      // required keys are not removed.
      acceptRequired: function acceptRequired(node, name) {
        this.acceptKey(node, name);
    
        if (!node[name]) {
          throw new _Exception2['default'](node.type + ' requires ' + name);
        }
      },
    
      // Traverses a given array. If mutating, empty respnses will be removed
      // for child elements.
      acceptArray: function acceptArray(array) {
        for (var i = 0, l = array.length; i < l; i++) {
          this.acceptKey(array, i);
    
          if (!array[i]) {
            array.splice(i, 1);
            i--;
            l--;
          }
        }
      },
    
      accept: function accept(object) {
        if (!object) {
          return;
        }
    
        if (this.current) {
          this.parents.unshift(this.current);
        }
        this.current = object;
    
        var ret = this[object.type](object);
    
        this.current = this.parents.shift();
    
        if (!this.mutating || ret) {
          return ret;
        } else if (ret !== false) {
          return object;
        }
      },
    
      Program: function Program(program) {
        this.acceptArray(program.body);
      },
    
      MustacheStatement: function MustacheStatement(mustache) {
        this.acceptRequired(mustache, 'path');
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, 'hash');
      },
    
      BlockStatement: function BlockStatement(block) {
        this.acceptRequired(block, 'path');
        this.acceptArray(block.params);
        this.acceptKey(block, 'hash');
    
        this.acceptKey(block, 'program');
        this.acceptKey(block, 'inverse');
      },
    
      PartialStatement: function PartialStatement(partial) {
        this.acceptRequired(partial, 'name');
        this.acceptArray(partial.params);
        this.acceptKey(partial, 'hash');
      },
    
      ContentStatement: function ContentStatement() {},
      CommentStatement: function CommentStatement() {},
    
      SubExpression: function SubExpression(sexpr) {
        this.acceptRequired(sexpr, 'path');
        this.acceptArray(sexpr.params);
        this.acceptKey(sexpr, 'hash');
      },
    
      PathExpression: function PathExpression() {},
    
      StringLiteral: function StringLiteral() {},
      NumberLiteral: function NumberLiteral() {},
      BooleanLiteral: function BooleanLiteral() {},
      UndefinedLiteral: function UndefinedLiteral() {},
      NullLiteral: function NullLiteral() {},
    
      Hash: function Hash(hash) {
        this.acceptArray(hash.pairs);
      },
      HashPair: function HashPair(pair) {
        this.acceptRequired(pair, 'value');
      }
    };
    
    exports['default'] = Visitor;
    module.exports = exports['default'];
    /* content */ /* comment */ /* path */ /* string */ /* number */ /* bool */ /* literal */ /* literal */
  provide("handlebars/dist/cjs/handlebars/compiler/visitor", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/safe-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    // Build out our basic SafeString type
    function SafeString(string) {
      this.string = string;
    }
    
    SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
      return '' + this.string;
    };
    
    exports['default'] = SafeString;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/safe-string", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/runtime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.checkRevision = checkRevision;
    
    // TODO: Remove this line and break up compilePartial
    
    exports.template = template;
    exports.wrapProgram = wrapProgram;
    exports.resolvePartial = resolvePartial;
    exports.invokePartial = invokePartial;
    exports.noop = noop;
    
    var _import =  require('handlebars/dist/cjs/handlebars/utils');
    
    var Utils = _interopRequireWildcard(_import);
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _COMPILER_REVISION$REVISION_CHANGES$createFrame =  require('handlebars/dist/cjs/handlebars/base');
    
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1,
          currentRevision = _COMPILER_REVISION$REVISION_CHANGES$createFrame.COMPILER_REVISION;
    
      if (compilerRevision !== currentRevision) {
        if (compilerRevision < currentRevision) {
          var runtimeVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[currentRevision],
              compilerVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[compilerRevision];
          throw new _Exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
        } else {
          // Use the embedded version info since the runtime doesn't know about this revision yet
          throw new _Exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
        }
      }
    }
    
    function template(templateSpec, env) {
      /* istanbul ignore next */
      if (!env) {
        throw new _Exception2['default']('No environment passed to template');
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _Exception2['default']('Unknown template object: ' + typeof templateSpec);
      }
    
      // Note: Using env.VM references rather than local var references throughout this section to allow
      // for external users to override these as psuedo-supported APIs.
      env.VM.checkRevision(templateSpec.compiler);
    
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
        }
    
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var result = env.VM.invokePartial.call(this, partial, context, options);
    
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, options);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split('\n');
            for (var i = 0, l = lines.length; i < l; i++) {
              if (!lines[i] && i + 1 === l) {
                break;
              }
    
              lines[i] = options.indent + lines[i];
            }
            result = lines.join('\n');
          }
          return result;
        } else {
          throw new _Exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
        }
      }
    
      // Just add water
      var container = {
        strict: function strict(obj, name) {
          if (!(name in obj)) {
            throw new _Exception2['default']('"' + name + '" not defined in ' + obj);
          }
          return obj[name];
        },
        lookup: function lookup(depths, name) {
          var len = depths.length;
          for (var i = 0; i < len; i++) {
            if (depths[i] && depths[i][name] != null) {
              return depths[i][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === 'function' ? current.call(context) : current;
        },
    
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
    
        fn: function fn(i) {
          return templateSpec[i];
        },
    
        programs: [],
        program: function program(i, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i],
              fn = this.fn(i);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
          }
          return programWrapper;
        },
    
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        merge: function merge(param, common) {
          var obj = param || common;
    
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
    
          return obj;
        },
    
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
    
      function ret(context) {
        var options = arguments[1] === undefined ? {} : arguments[1];
    
        var data = options.data;
    
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = undefined,
            blockParams = templateSpec.useBlockParams ? [] : undefined;
        if (templateSpec.useDepths) {
          depths = options.depths ? [context].concat(options.depths) : [context];
        }
    
        return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);
      }
      ret.isTop = true;
    
      ret._setup = function (options) {
        if (!options.partial) {
          container.helpers = container.merge(options.helpers, env.helpers);
    
          if (templateSpec.usePartial) {
            container.partials = container.merge(options.partials, env.partials);
          }
        } else {
          container.helpers = options.helpers;
          container.partials = options.partials;
        }
      };
    
      ret._child = function (i, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _Exception2['default']('must pass block params');
        }
        if (templateSpec.useDepths && !depths) {
          throw new _Exception2['default']('must pass parent depths');
        }
    
        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
      };
      return ret;
    }
    
    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments[1] === undefined ? {} : arguments[1];
    
        return fn.call(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), depths && [context].concat(depths));
      }
      prog.program = i;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    
    function resolvePartial(partial, context, options) {
      if (!partial) {
        partial = options.partials[options.name];
      } else if (!partial.call && !options.name) {
        // This is a dynamic partial that returned a string
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    
    function invokePartial(partial, context, options) {
      options.partial = true;
    
      if (partial === undefined) {
        throw new _Exception2['default']('The partial ' + options.name + ' could not be found');
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    
    function noop() {
      return '';
    }
    
    function initData(context, data) {
      if (!data || !('root' in data)) {
        data = data ? _COMPILER_REVISION$REVISION_CHANGES$createFrame.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
  provide("handlebars/dist/cjs/handlebars/runtime", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/no-conflict
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    /*global window */
    
    exports['default'] = function (Handlebars) {
      /* istanbul ignore next */
      var root = typeof global !== 'undefined' ? global : window,
          $Handlebars = root.Handlebars;
      /* istanbul ignore next */
      Handlebars.noConflict = function () {
        if (root.Handlebars === Handlebars) {
          root.Handlebars = $Handlebars;
        }
      };
    };
    
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/no-conflict", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    exports.__esModule = true;
    /* istanbul ignore next */
    /* Jison generated parser */
    var handlebars = (function () {
        var parser = { trace: function trace() {},
            yy: {},
            symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, content: 12, COMMENT: 13, CONTENT: 14, openRawBlock: 15, END_RAW_BLOCK: 16, OPEN_RAW_BLOCK: 17, helperName: 18, openRawBlock_repetition0: 19, openRawBlock_option0: 20, CLOSE_RAW_BLOCK: 21, openBlock: 22, block_option0: 23, closeBlock: 24, openInverse: 25, block_option1: 26, OPEN_BLOCK: 27, openBlock_repetition0: 28, openBlock_option0: 29, openBlock_option1: 30, CLOSE: 31, OPEN_INVERSE: 32, openInverse_repetition0: 33, openInverse_option0: 34, openInverse_option1: 35, openInverseChain: 36, OPEN_INVERSE_CHAIN: 37, openInverseChain_repetition0: 38, openInverseChain_option0: 39, openInverseChain_option1: 40, inverseAndProgram: 41, INVERSE: 42, inverseChain: 43, inverseChain_option0: 44, OPEN_ENDBLOCK: 45, OPEN: 46, mustache_repetition0: 47, mustache_option0: 48, OPEN_UNESCAPED: 49, mustache_repetition1: 50, mustache_option1: 51, CLOSE_UNESCAPED: 52, OPEN_PARTIAL: 53, partialName: 54, partial_repetition0: 55, partial_option0: 56, param: 57, sexpr: 58, OPEN_SEXPR: 59, sexpr_repetition0: 60, sexpr_option0: 61, CLOSE_SEXPR: 62, hash: 63, hash_repetition_plus0: 64, hashSegment: 65, ID: 66, EQUALS: 67, blockParams: 68, OPEN_BLOCK_PARAMS: 69, blockParams_repetition_plus0: 70, CLOSE_BLOCK_PARAMS: 71, path: 72, dataName: 73, STRING: 74, NUMBER: 75, BOOLEAN: 76, UNDEFINED: 77, NULL: 78, DATA: 79, pathSegments: 80, SEP: 81, $accept: 0, $end: 1 },
            terminals_: { 2: "error", 5: "EOF", 13: "COMMENT", 14: "CONTENT", 16: "END_RAW_BLOCK", 17: "OPEN_RAW_BLOCK", 21: "CLOSE_RAW_BLOCK", 27: "OPEN_BLOCK", 31: "CLOSE", 32: "OPEN_INVERSE", 37: "OPEN_INVERSE_CHAIN", 42: "INVERSE", 45: "OPEN_ENDBLOCK", 46: "OPEN", 49: "OPEN_UNESCAPED", 52: "CLOSE_UNESCAPED", 53: "OPEN_PARTIAL", 59: "OPEN_SEXPR", 62: "CLOSE_SEXPR", 66: "ID", 67: "EQUALS", 69: "OPEN_BLOCK_PARAMS", 71: "CLOSE_BLOCK_PARAMS", 74: "STRING", 75: "NUMBER", 76: "BOOLEAN", 77: "UNDEFINED", 78: "NULL", 79: "DATA", 81: "SEP" },
            productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [12, 1], [10, 3], [15, 5], [9, 4], [9, 4], [22, 6], [25, 6], [36, 6], [41, 2], [43, 3], [43, 1], [24, 3], [8, 5], [8, 5], [11, 5], [57, 1], [57, 1], [58, 5], [63, 1], [65, 3], [68, 3], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [54, 1], [54, 1], [73, 2], [72, 1], [80, 3], [80, 1], [6, 0], [6, 2], [19, 0], [19, 2], [20, 0], [20, 1], [23, 0], [23, 1], [26, 0], [26, 1], [28, 0], [28, 2], [29, 0], [29, 1], [30, 0], [30, 1], [33, 0], [33, 2], [34, 0], [34, 1], [35, 0], [35, 1], [38, 0], [38, 2], [39, 0], [39, 1], [40, 0], [40, 1], [44, 0], [44, 1], [47, 0], [47, 2], [48, 0], [48, 1], [50, 0], [50, 2], [51, 0], [51, 1], [55, 0], [55, 2], [56, 0], [56, 1], [60, 0], [60, 2], [61, 0], [61, 1], [64, 1], [64, 2], [70, 1], [70, 2]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
    
                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        return $$[$0 - 1];
                        break;
                    case 2:
                        this.$ = new yy.Program($$[$0], null, {}, yy.locInfo(this._$));
                        break;
                    case 3:
                        this.$ = $$[$0];
                        break;
                    case 4:
                        this.$ = $$[$0];
                        break;
                    case 5:
                        this.$ = $$[$0];
                        break;
                    case 6:
                        this.$ = $$[$0];
                        break;
                    case 7:
                        this.$ = $$[$0];
                        break;
                    case 8:
                        this.$ = new yy.CommentStatement(yy.stripComment($$[$0]), yy.stripFlags($$[$0], $$[$0]), yy.locInfo(this._$));
                        break;
                    case 9:
                        this.$ = new yy.ContentStatement($$[$0], yy.locInfo(this._$));
                        break;
                    case 10:
                        this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                        break;
                    case 11:
                        this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                        break;
                    case 12:
                        this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                        break;
                    case 13:
                        this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                        break;
                    case 14:
                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                        break;
                    case 15:
                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                        break;
                    case 16:
                        this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                        break;
                    case 17:
                        this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                        break;
                    case 18:
                        var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                            program = new yy.Program([inverse], null, {}, yy.locInfo(this._$));
                        program.chained = true;
    
                        this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };
    
                        break;
                    case 19:
                        this.$ = $$[$0];
                        break;
                    case 20:
                        this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                        break;
                    case 21:
                        this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                        break;
                    case 22:
                        this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                        break;
                    case 23:
                        this.$ = new yy.PartialStatement($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.stripFlags($$[$0 - 4], $$[$0]), yy.locInfo(this._$));
                        break;
                    case 24:
                        this.$ = $$[$0];
                        break;
                    case 25:
                        this.$ = $$[$0];
                        break;
                    case 26:
                        this.$ = new yy.SubExpression($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.locInfo(this._$));
                        break;
                    case 27:
                        this.$ = new yy.Hash($$[$0], yy.locInfo(this._$));
                        break;
                    case 28:
                        this.$ = new yy.HashPair(yy.id($$[$0 - 2]), $$[$0], yy.locInfo(this._$));
                        break;
                    case 29:
                        this.$ = yy.id($$[$0 - 1]);
                        break;
                    case 30:
                        this.$ = $$[$0];
                        break;
                    case 31:
                        this.$ = $$[$0];
                        break;
                    case 32:
                        this.$ = new yy.StringLiteral($$[$0], yy.locInfo(this._$));
                        break;
                    case 33:
                        this.$ = new yy.NumberLiteral($$[$0], yy.locInfo(this._$));
                        break;
                    case 34:
                        this.$ = new yy.BooleanLiteral($$[$0], yy.locInfo(this._$));
                        break;
                    case 35:
                        this.$ = new yy.UndefinedLiteral(yy.locInfo(this._$));
                        break;
                    case 36:
                        this.$ = new yy.NullLiteral(yy.locInfo(this._$));
                        break;
                    case 37:
                        this.$ = $$[$0];
                        break;
                    case 38:
                        this.$ = $$[$0];
                        break;
                    case 39:
                        this.$ = yy.preparePath(true, $$[$0], this._$);
                        break;
                    case 40:
                        this.$ = yy.preparePath(false, $$[$0], this._$);
                        break;
                    case 41:
                        $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
                        break;
                    case 42:
                        this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                        break;
                    case 43:
                        this.$ = [];
                        break;
                    case 44:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 45:
                        this.$ = [];
                        break;
                    case 46:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 53:
                        this.$ = [];
                        break;
                    case 54:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 59:
                        this.$ = [];
                        break;
                    case 60:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 65:
                        this.$ = [];
                        break;
                    case 66:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 73:
                        this.$ = [];
                        break;
                    case 74:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 77:
                        this.$ = [];
                        break;
                    case 78:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 81:
                        this.$ = [];
                        break;
                    case 82:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 85:
                        this.$ = [];
                        break;
                    case 86:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 89:
                        this.$ = [$$[$0]];
                        break;
                    case 90:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    case 91:
                        this.$ = [$$[$0]];
                        break;
                    case 92:
                        $$[$0 - 1].push($$[$0]);
                        break;
                }
            },
            table: [{ 3: 1, 4: 2, 5: [2, 43], 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: [1, 11], 14: [1, 18], 15: 16, 17: [1, 21], 22: 14, 25: 15, 27: [1, 19], 32: [1, 20], 37: [2, 2], 42: [2, 2], 45: [2, 2], 46: [1, 12], 49: [1, 13], 53: [1, 17] }, { 1: [2, 1] }, { 5: [2, 44], 13: [2, 44], 14: [2, 44], 17: [2, 44], 27: [2, 44], 32: [2, 44], 37: [2, 44], 42: [2, 44], 45: [2, 44], 46: [2, 44], 49: [2, 44], 53: [2, 44] }, { 5: [2, 3], 13: [2, 3], 14: [2, 3], 17: [2, 3], 27: [2, 3], 32: [2, 3], 37: [2, 3], 42: [2, 3], 45: [2, 3], 46: [2, 3], 49: [2, 3], 53: [2, 3] }, { 5: [2, 4], 13: [2, 4], 14: [2, 4], 17: [2, 4], 27: [2, 4], 32: [2, 4], 37: [2, 4], 42: [2, 4], 45: [2, 4], 46: [2, 4], 49: [2, 4], 53: [2, 4] }, { 5: [2, 5], 13: [2, 5], 14: [2, 5], 17: [2, 5], 27: [2, 5], 32: [2, 5], 37: [2, 5], 42: [2, 5], 45: [2, 5], 46: [2, 5], 49: [2, 5], 53: [2, 5] }, { 5: [2, 6], 13: [2, 6], 14: [2, 6], 17: [2, 6], 27: [2, 6], 32: [2, 6], 37: [2, 6], 42: [2, 6], 45: [2, 6], 46: [2, 6], 49: [2, 6], 53: [2, 6] }, { 5: [2, 7], 13: [2, 7], 14: [2, 7], 17: [2, 7], 27: [2, 7], 32: [2, 7], 37: [2, 7], 42: [2, 7], 45: [2, 7], 46: [2, 7], 49: [2, 7], 53: [2, 7] }, { 5: [2, 8], 13: [2, 8], 14: [2, 8], 17: [2, 8], 27: [2, 8], 32: [2, 8], 37: [2, 8], 42: [2, 8], 45: [2, 8], 46: [2, 8], 49: [2, 8], 53: [2, 8] }, { 18: 22, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 33, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 34, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 4: 35, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 12: 36, 14: [1, 18] }, { 18: 38, 54: 37, 58: 39, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 9], 13: [2, 9], 14: [2, 9], 16: [2, 9], 17: [2, 9], 27: [2, 9], 32: [2, 9], 37: [2, 9], 42: [2, 9], 45: [2, 9], 46: [2, 9], 49: [2, 9], 53: [2, 9] }, { 18: 41, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 42, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 43, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [2, 73], 47: 44, 59: [2, 73], 66: [2, 73], 74: [2, 73], 75: [2, 73], 76: [2, 73], 77: [2, 73], 78: [2, 73], 79: [2, 73] }, { 21: [2, 30], 31: [2, 30], 52: [2, 30], 59: [2, 30], 62: [2, 30], 66: [2, 30], 69: [2, 30], 74: [2, 30], 75: [2, 30], 76: [2, 30], 77: [2, 30], 78: [2, 30], 79: [2, 30] }, { 21: [2, 31], 31: [2, 31], 52: [2, 31], 59: [2, 31], 62: [2, 31], 66: [2, 31], 69: [2, 31], 74: [2, 31], 75: [2, 31], 76: [2, 31], 77: [2, 31], 78: [2, 31], 79: [2, 31] }, { 21: [2, 32], 31: [2, 32], 52: [2, 32], 59: [2, 32], 62: [2, 32], 66: [2, 32], 69: [2, 32], 74: [2, 32], 75: [2, 32], 76: [2, 32], 77: [2, 32], 78: [2, 32], 79: [2, 32] }, { 21: [2, 33], 31: [2, 33], 52: [2, 33], 59: [2, 33], 62: [2, 33], 66: [2, 33], 69: [2, 33], 74: [2, 33], 75: [2, 33], 76: [2, 33], 77: [2, 33], 78: [2, 33], 79: [2, 33] }, { 21: [2, 34], 31: [2, 34], 52: [2, 34], 59: [2, 34], 62: [2, 34], 66: [2, 34], 69: [2, 34], 74: [2, 34], 75: [2, 34], 76: [2, 34], 77: [2, 34], 78: [2, 34], 79: [2, 34] }, { 21: [2, 35], 31: [2, 35], 52: [2, 35], 59: [2, 35], 62: [2, 35], 66: [2, 35], 69: [2, 35], 74: [2, 35], 75: [2, 35], 76: [2, 35], 77: [2, 35], 78: [2, 35], 79: [2, 35] }, { 21: [2, 36], 31: [2, 36], 52: [2, 36], 59: [2, 36], 62: [2, 36], 66: [2, 36], 69: [2, 36], 74: [2, 36], 75: [2, 36], 76: [2, 36], 77: [2, 36], 78: [2, 36], 79: [2, 36] }, { 21: [2, 40], 31: [2, 40], 52: [2, 40], 59: [2, 40], 62: [2, 40], 66: [2, 40], 69: [2, 40], 74: [2, 40], 75: [2, 40], 76: [2, 40], 77: [2, 40], 78: [2, 40], 79: [2, 40], 81: [1, 45] }, { 66: [1, 32], 80: 46 }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 50: 47, 52: [2, 77], 59: [2, 77], 66: [2, 77], 74: [2, 77], 75: [2, 77], 76: [2, 77], 77: [2, 77], 78: [2, 77], 79: [2, 77] }, { 23: 48, 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 49, 45: [2, 49] }, { 26: 54, 41: 55, 42: [1, 53], 45: [2, 51] }, { 16: [1, 56] }, { 31: [2, 81], 55: 57, 59: [2, 81], 66: [2, 81], 74: [2, 81], 75: [2, 81], 76: [2, 81], 77: [2, 81], 78: [2, 81], 79: [2, 81] }, { 31: [2, 37], 59: [2, 37], 66: [2, 37], 74: [2, 37], 75: [2, 37], 76: [2, 37], 77: [2, 37], 78: [2, 37], 79: [2, 37] }, { 31: [2, 38], 59: [2, 38], 66: [2, 38], 74: [2, 38], 75: [2, 38], 76: [2, 38], 77: [2, 38], 78: [2, 38], 79: [2, 38] }, { 18: 58, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 28: 59, 31: [2, 53], 59: [2, 53], 66: [2, 53], 69: [2, 53], 74: [2, 53], 75: [2, 53], 76: [2, 53], 77: [2, 53], 78: [2, 53], 79: [2, 53] }, { 31: [2, 59], 33: 60, 59: [2, 59], 66: [2, 59], 69: [2, 59], 74: [2, 59], 75: [2, 59], 76: [2, 59], 77: [2, 59], 78: [2, 59], 79: [2, 59] }, { 19: 61, 21: [2, 45], 59: [2, 45], 66: [2, 45], 74: [2, 45], 75: [2, 45], 76: [2, 45], 77: [2, 45], 78: [2, 45], 79: [2, 45] }, { 18: 65, 31: [2, 75], 48: 62, 57: 63, 58: 66, 59: [1, 40], 63: 64, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 66: [1, 70] }, { 21: [2, 39], 31: [2, 39], 52: [2, 39], 59: [2, 39], 62: [2, 39], 66: [2, 39], 69: [2, 39], 74: [2, 39], 75: [2, 39], 76: [2, 39], 77: [2, 39], 78: [2, 39], 79: [2, 39], 81: [1, 45] }, { 18: 65, 51: 71, 52: [2, 79], 57: 72, 58: 66, 59: [1, 40], 63: 73, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 24: 74, 45: [1, 75] }, { 45: [2, 50] }, { 4: 76, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 45: [2, 19] }, { 18: 77, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 78, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 24: 79, 45: [1, 75] }, { 45: [2, 52] }, { 5: [2, 10], 13: [2, 10], 14: [2, 10], 17: [2, 10], 27: [2, 10], 32: [2, 10], 37: [2, 10], 42: [2, 10], 45: [2, 10], 46: [2, 10], 49: [2, 10], 53: [2, 10] }, { 18: 65, 31: [2, 83], 56: 80, 57: 81, 58: 66, 59: [1, 40], 63: 82, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 59: [2, 85], 60: 83, 62: [2, 85], 66: [2, 85], 74: [2, 85], 75: [2, 85], 76: [2, 85], 77: [2, 85], 78: [2, 85], 79: [2, 85] }, { 18: 65, 29: 84, 31: [2, 55], 57: 85, 58: 66, 59: [1, 40], 63: 86, 64: 67, 65: 68, 66: [1, 69], 69: [2, 55], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 31: [2, 61], 34: 87, 57: 88, 58: 66, 59: [1, 40], 63: 89, 64: 67, 65: 68, 66: [1, 69], 69: [2, 61], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 20: 90, 21: [2, 47], 57: 91, 58: 66, 59: [1, 40], 63: 92, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [1, 93] }, { 31: [2, 74], 59: [2, 74], 66: [2, 74], 74: [2, 74], 75: [2, 74], 76: [2, 74], 77: [2, 74], 78: [2, 74], 79: [2, 74] }, { 31: [2, 76] }, { 21: [2, 24], 31: [2, 24], 52: [2, 24], 59: [2, 24], 62: [2, 24], 66: [2, 24], 69: [2, 24], 74: [2, 24], 75: [2, 24], 76: [2, 24], 77: [2, 24], 78: [2, 24], 79: [2, 24] }, { 21: [2, 25], 31: [2, 25], 52: [2, 25], 59: [2, 25], 62: [2, 25], 66: [2, 25], 69: [2, 25], 74: [2, 25], 75: [2, 25], 76: [2, 25], 77: [2, 25], 78: [2, 25], 79: [2, 25] }, { 21: [2, 27], 31: [2, 27], 52: [2, 27], 62: [2, 27], 65: 94, 66: [1, 95], 69: [2, 27] }, { 21: [2, 89], 31: [2, 89], 52: [2, 89], 62: [2, 89], 66: [2, 89], 69: [2, 89] }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 67: [1, 96], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 21: [2, 41], 31: [2, 41], 52: [2, 41], 59: [2, 41], 62: [2, 41], 66: [2, 41], 69: [2, 41], 74: [2, 41], 75: [2, 41], 76: [2, 41], 77: [2, 41], 78: [2, 41], 79: [2, 41], 81: [2, 41] }, { 52: [1, 97] }, { 52: [2, 78], 59: [2, 78], 66: [2, 78], 74: [2, 78], 75: [2, 78], 76: [2, 78], 77: [2, 78], 78: [2, 78], 79: [2, 78] }, { 52: [2, 80] }, { 5: [2, 12], 13: [2, 12], 14: [2, 12], 17: [2, 12], 27: [2, 12], 32: [2, 12], 37: [2, 12], 42: [2, 12], 45: [2, 12], 46: [2, 12], 49: [2, 12], 53: [2, 12] }, { 18: 98, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 100, 44: 99, 45: [2, 71] }, { 31: [2, 65], 38: 101, 59: [2, 65], 66: [2, 65], 69: [2, 65], 74: [2, 65], 75: [2, 65], 76: [2, 65], 77: [2, 65], 78: [2, 65], 79: [2, 65] }, { 45: [2, 17] }, { 5: [2, 13], 13: [2, 13], 14: [2, 13], 17: [2, 13], 27: [2, 13], 32: [2, 13], 37: [2, 13], 42: [2, 13], 45: [2, 13], 46: [2, 13], 49: [2, 13], 53: [2, 13] }, { 31: [1, 102] }, { 31: [2, 82], 59: [2, 82], 66: [2, 82], 74: [2, 82], 75: [2, 82], 76: [2, 82], 77: [2, 82], 78: [2, 82], 79: [2, 82] }, { 31: [2, 84] }, { 18: 65, 57: 104, 58: 66, 59: [1, 40], 61: 103, 62: [2, 87], 63: 105, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 30: 106, 31: [2, 57], 68: 107, 69: [1, 108] }, { 31: [2, 54], 59: [2, 54], 66: [2, 54], 69: [2, 54], 74: [2, 54], 75: [2, 54], 76: [2, 54], 77: [2, 54], 78: [2, 54], 79: [2, 54] }, { 31: [2, 56], 69: [2, 56] }, { 31: [2, 63], 35: 109, 68: 110, 69: [1, 108] }, { 31: [2, 60], 59: [2, 60], 66: [2, 60], 69: [2, 60], 74: [2, 60], 75: [2, 60], 76: [2, 60], 77: [2, 60], 78: [2, 60], 79: [2, 60] }, { 31: [2, 62], 69: [2, 62] }, { 21: [1, 111] }, { 21: [2, 46], 59: [2, 46], 66: [2, 46], 74: [2, 46], 75: [2, 46], 76: [2, 46], 77: [2, 46], 78: [2, 46], 79: [2, 46] }, { 21: [2, 48] }, { 5: [2, 21], 13: [2, 21], 14: [2, 21], 17: [2, 21], 27: [2, 21], 32: [2, 21], 37: [2, 21], 42: [2, 21], 45: [2, 21], 46: [2, 21], 49: [2, 21], 53: [2, 21] }, { 21: [2, 90], 31: [2, 90], 52: [2, 90], 62: [2, 90], 66: [2, 90], 69: [2, 90] }, { 67: [1, 96] }, { 18: 65, 57: 112, 58: 66, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 22], 13: [2, 22], 14: [2, 22], 17: [2, 22], 27: [2, 22], 32: [2, 22], 37: [2, 22], 42: [2, 22], 45: [2, 22], 46: [2, 22], 49: [2, 22], 53: [2, 22] }, { 31: [1, 113] }, { 45: [2, 18] }, { 45: [2, 72] }, { 18: 65, 31: [2, 67], 39: 114, 57: 115, 58: 66, 59: [1, 40], 63: 116, 64: 67, 65: 68, 66: [1, 69], 69: [2, 67], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 23], 13: [2, 23], 14: [2, 23], 17: [2, 23], 27: [2, 23], 32: [2, 23], 37: [2, 23], 42: [2, 23], 45: [2, 23], 46: [2, 23], 49: [2, 23], 53: [2, 23] }, { 62: [1, 117] }, { 59: [2, 86], 62: [2, 86], 66: [2, 86], 74: [2, 86], 75: [2, 86], 76: [2, 86], 77: [2, 86], 78: [2, 86], 79: [2, 86] }, { 62: [2, 88] }, { 31: [1, 118] }, { 31: [2, 58] }, { 66: [1, 120], 70: 119 }, { 31: [1, 121] }, { 31: [2, 64] }, { 14: [2, 11] }, { 21: [2, 28], 31: [2, 28], 52: [2, 28], 62: [2, 28], 66: [2, 28], 69: [2, 28] }, { 5: [2, 20], 13: [2, 20], 14: [2, 20], 17: [2, 20], 27: [2, 20], 32: [2, 20], 37: [2, 20], 42: [2, 20], 45: [2, 20], 46: [2, 20], 49: [2, 20], 53: [2, 20] }, { 31: [2, 69], 40: 122, 68: 123, 69: [1, 108] }, { 31: [2, 66], 59: [2, 66], 66: [2, 66], 69: [2, 66], 74: [2, 66], 75: [2, 66], 76: [2, 66], 77: [2, 66], 78: [2, 66], 79: [2, 66] }, { 31: [2, 68], 69: [2, 68] }, { 21: [2, 26], 31: [2, 26], 52: [2, 26], 59: [2, 26], 62: [2, 26], 66: [2, 26], 69: [2, 26], 74: [2, 26], 75: [2, 26], 76: [2, 26], 77: [2, 26], 78: [2, 26], 79: [2, 26] }, { 13: [2, 14], 14: [2, 14], 17: [2, 14], 27: [2, 14], 32: [2, 14], 37: [2, 14], 42: [2, 14], 45: [2, 14], 46: [2, 14], 49: [2, 14], 53: [2, 14] }, { 66: [1, 125], 71: [1, 124] }, { 66: [2, 91], 71: [2, 91] }, { 13: [2, 15], 14: [2, 15], 17: [2, 15], 27: [2, 15], 32: [2, 15], 42: [2, 15], 45: [2, 15], 46: [2, 15], 49: [2, 15], 53: [2, 15] }, { 31: [1, 126] }, { 31: [2, 70] }, { 31: [2, 29] }, { 66: [2, 92], 71: [2, 92] }, { 13: [2, 16], 14: [2, 16], 17: [2, 16], 27: [2, 16], 32: [2, 16], 37: [2, 16], 42: [2, 16], 45: [2, 16], 46: [2, 16], 49: [2, 16], 53: [2, 16] }],
            defaultActions: { 4: [2, 1], 49: [2, 50], 51: [2, 19], 55: [2, 52], 64: [2, 76], 73: [2, 80], 78: [2, 17], 82: [2, 84], 92: [2, 48], 99: [2, 18], 100: [2, 72], 105: [2, 88], 107: [2, 58], 110: [2, 64], 111: [2, 11], 123: [2, 70], 124: [2, 29] },
            parseError: function parseError(str, hash) {
                throw new Error(str);
            },
            parse: function parse(input) {
                var self = this,
                    stack = [0],
                    vstack = [null],
                    lstack = [],
                    table = this.table,
                    yytext = "",
                    yylineno = 0,
                    yyleng = 0,
                    recovering = 0,
                    TERROR = 2,
                    EOF = 1;
                this.lexer.setInput(input);
                this.lexer.yy = this.yy;
                this.yy.lexer = this.lexer;
                this.yy.parser = this;
                if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                var yyloc = this.lexer.yylloc;
                lstack.push(yyloc);
                var ranges = this.lexer.options && this.lexer.options.ranges;
                if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
                function popStack(n) {
                    stack.length = stack.length - 2 * n;
                    vstack.length = vstack.length - n;
                    lstack.length = lstack.length - n;
                }
                function lex() {
                    var token;
                    token = self.lexer.lex() || 1;
                    if (typeof token !== "number") {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol,
                    preErrorSymbol,
                    state,
                    action,
                    a,
                    r,
                    yyval = {},
                    p,
                    len,
                    newState,
                    expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == "undefined") {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === "undefined" || !action.length || !action[0]) {
                        var errStr = "";
                        if (!recovering) {
                            expected = [];
                            for (p in table[state]) if (this.terminals_[p] && p > 2) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                            if (this.lexer.showPosition) {
                                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                            } else {
                                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                            }
                            this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                        }
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0) recovering--;
                            } else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                            if (typeof r !== "undefined") {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            }
        };
        /* Jison generated lexer */
        var lexer = (function () {
            var lexer = { EOF: 1,
                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },
                setInput: function setInput(input) {
                    this._input = input;
                    this._more = this._less = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = "";
                    this.conditionStack = ["INITIAL"];
                    this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                    if (this.options.ranges) this.yylloc.range = [0, 0];
                    this.offset = 0;
                    return this;
                },
                input: function input() {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) this.yylloc.range[1]++;
    
                    this._input = this._input.slice(1);
                    return ch;
                },
                unput: function unput(ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);
    
                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);
    
                    if (lines.length - 1) this.yylineno -= lines.length - 1;
                    var r = this.yylloc.range;
    
                    this.yylloc = { first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                    };
    
                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    return this;
                },
                more: function more() {
                    this._more = true;
                    return this;
                },
                less: function less(n) {
                    this.unput(this.match.slice(n));
                },
                pastInput: function pastInput() {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
                },
                upcomingInput: function upcomingInput() {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                showPosition: function showPosition() {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },
                next: function next() {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) this.done = true;
    
                    var token, match, tempMatch, index, col, lines;
                    if (!this._more) {
                        this.yytext = "";
                        this.match = "";
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (!this.options.flex) break;
                        }
                    }
                    if (match) {
                        lines = match[0].match(/(?:\r\n?|\n).*/g);
                        if (lines) this.yylineno += lines.length;
                        this.yylloc = { first_line: this.yylloc.last_line,
                            last_line: this.yylineno + 1,
                            first_column: this.yylloc.last_column,
                            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                        this.yytext += match[0];
                        this.match += match[0];
                        this.matches = match;
                        this.yyleng = this.yytext.length;
                        if (this.options.ranges) {
                            this.yylloc.range = [this.offset, this.offset += this.yyleng];
                        }
                        this._more = false;
                        this._input = this._input.slice(match[0].length);
                        this.matched += match[0];
                        token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                        if (this.done && this._input) this.done = false;
                        if (token) {
                            return token;
                        } else {
                            return;
                        }
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
                    }
                },
                lex: function lex() {
                    var r = this.next();
                    if (typeof r !== "undefined") {
                        return r;
                    } else {
                        return this.lex();
                    }
                },
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },
                popState: function popState() {
                    return this.conditionStack.pop();
                },
                _currentRules: function _currentRules() {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                },
                topState: function topState() {
                    return this.conditionStack[this.conditionStack.length - 2];
                },
                pushState: function begin(condition) {
                    this.begin(condition);
                } };
            lexer.options = {};
            lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
    
                function strip(start, end) {
                    return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                }
    
                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                    case 0:
                        if (yy_.yytext.slice(-2) === "\\\\") {
                            strip(0, 1);
                            this.begin("mu");
                        } else if (yy_.yytext.slice(-1) === "\\") {
                            strip(0, 1);
                            this.begin("emu");
                        } else {
                            this.begin("mu");
                        }
                        if (yy_.yytext) {
                            return 14;
                        }break;
                    case 1:
                        return 14;
                        break;
                    case 2:
                        this.popState();
                        return 14;
    
                        break;
                    case 3:
                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                        this.popState();
                        return 16;
    
                        break;
                    case 4:
                        return 14;
                        break;
                    case 5:
                        this.popState();
                        return 13;
    
                        break;
                    case 6:
                        return 59;
                        break;
                    case 7:
                        return 62;
                        break;
                    case 8:
                        return 17;
                        break;
                    case 9:
                        this.popState();
                        this.begin("raw");
                        return 21;
    
                        break;
                    case 10:
                        return 53;
                        break;
                    case 11:
                        return 27;
                        break;
                    case 12:
                        return 45;
                        break;
                    case 13:
                        this.popState();return 42;
                        break;
                    case 14:
                        this.popState();return 42;
                        break;
                    case 15:
                        return 32;
                        break;
                    case 16:
                        return 37;
                        break;
                    case 17:
                        return 49;
                        break;
                    case 18:
                        return 46;
                        break;
                    case 19:
                        this.unput(yy_.yytext);
                        this.popState();
                        this.begin("com");
    
                        break;
                    case 20:
                        this.popState();
                        return 13;
    
                        break;
                    case 21:
                        return 46;
                        break;
                    case 22:
                        return 67;
                        break;
                    case 23:
                        return 66;
                        break;
                    case 24:
                        return 66;
                        break;
                    case 25:
                        return 81;
                        break;
                    case 26:
                        // ignore whitespace
                        break;
                    case 27:
                        this.popState();return 52;
                        break;
                    case 28:
                        this.popState();return 31;
                        break;
                    case 29:
                        yy_.yytext = strip(1, 2).replace(/\\"/g, "\"");return 74;
                        break;
                    case 30:
                        yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 74;
                        break;
                    case 31:
                        return 79;
                        break;
                    case 32:
                        return 76;
                        break;
                    case 33:
                        return 76;
                        break;
                    case 34:
                        return 77;
                        break;
                    case 35:
                        return 78;
                        break;
                    case 36:
                        return 75;
                        break;
                    case 37:
                        return 69;
                        break;
                    case 38:
                        return 71;
                        break;
                    case 39:
                        return 66;
                        break;
                    case 40:
                        return 66;
                        break;
                    case 41:
                        return "INVALID";
                        break;
                    case 42:
                        return 5;
                        break;
                }
            };
            lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{\/)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/];
            lexer.conditions = { mu: { rules: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: false }, emu: { rules: [2], inclusive: false }, com: { rules: [5], inclusive: false }, raw: { rules: [3, 4], inclusive: false }, INITIAL: { rules: [0, 1, 42], inclusive: true } };
            return lexer;
        })();
        parser.lexer = lexer;
        function Parser() {
            this.yy = {};
        }Parser.prototype = parser;parser.Parser = Parser;
        return new Parser();
    })();exports["default"] = handlebars;
    module.exports = exports["default"];
  provide("handlebars/dist/cjs/handlebars/compiler/parser", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/whitespace-control
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _Visitor =  require('handlebars/dist/cjs/handlebars/compiler/visitor');
    
    var _Visitor2 = _interopRequireWildcard(_Visitor);
    
    function WhitespaceControl() {}
    WhitespaceControl.prototype = new _Visitor2['default']();
    
    WhitespaceControl.prototype.Program = function (program) {
      var isRoot = !this.isRootSeen;
      this.isRootSeen = true;
    
      var body = program.body;
      for (var i = 0, l = body.length; i < l; i++) {
        var current = body[i],
            strip = this.accept(current);
    
        if (!strip) {
          continue;
        }
    
        var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
            _isNextWhitespace = isNextWhitespace(body, i, isRoot),
            openStandalone = strip.openStandalone && _isPrevWhitespace,
            closeStandalone = strip.closeStandalone && _isNextWhitespace,
            inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
    
        if (strip.close) {
          omitRight(body, i, true);
        }
        if (strip.open) {
          omitLeft(body, i, true);
        }
    
        if (inlineStandalone) {
          omitRight(body, i);
    
          if (omitLeft(body, i)) {
            // If we are on a standalone node, save the indent info for partials
            if (current.type === 'PartialStatement') {
              // Pull out the whitespace from the final line
              current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
            }
          }
        }
        if (openStandalone) {
          omitRight((current.program || current.inverse).body);
    
          // Strip out the previous content node if it's whitespace only
          omitLeft(body, i);
        }
        if (closeStandalone) {
          // Always strip the next node
          omitRight(body, i);
    
          omitLeft((current.inverse || current.program).body);
        }
      }
    
      return program;
    };
    WhitespaceControl.prototype.BlockStatement = function (block) {
      this.accept(block.program);
      this.accept(block.inverse);
    
      // Find the inverse program that is involed with whitespace stripping.
      var program = block.program || block.inverse,
          inverse = block.program && block.inverse,
          firstInverse = inverse,
          lastInverse = inverse;
    
      if (inverse && inverse.chained) {
        firstInverse = inverse.body[0].program;
    
        // Walk the inverse chain to find the last inverse that is actually in the chain.
        while (lastInverse.chained) {
          lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
        }
      }
    
      var strip = {
        open: block.openStrip.open,
        close: block.closeStrip.close,
    
        // Determine the standalone candiacy. Basically flag our content as being possibly standalone
        // so our parent can determine if we actually are standalone
        openStandalone: isNextWhitespace(program.body),
        closeStandalone: isPrevWhitespace((firstInverse || program).body)
      };
    
      if (block.openStrip.close) {
        omitRight(program.body, null, true);
      }
    
      if (inverse) {
        var inverseStrip = block.inverseStrip;
    
        if (inverseStrip.open) {
          omitLeft(program.body, null, true);
        }
    
        if (inverseStrip.close) {
          omitRight(firstInverse.body, null, true);
        }
        if (block.closeStrip.open) {
          omitLeft(lastInverse.body, null, true);
        }
    
        // Find standalone else statments
        if (isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
          omitLeft(program.body);
          omitRight(firstInverse.body);
        }
      } else if (block.closeStrip.open) {
        omitLeft(program.body, null, true);
      }
    
      return strip;
    };
    
    WhitespaceControl.prototype.MustacheStatement = function (mustache) {
      return mustache.strip;
    };
    
    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
      /* istanbul ignore next */
      var strip = node.strip || {};
      return {
        inlineStandalone: true,
        open: strip.open,
        close: strip.close
      };
    };
    
    function isPrevWhitespace(body, i, isRoot) {
      if (i === undefined) {
        i = body.length;
      }
    
      // Nodes that end with newlines are considered whitespace (but are special
      // cased for strip operations)
      var prev = body[i - 1],
          sibling = body[i - 2];
      if (!prev) {
        return isRoot;
      }
    
      if (prev.type === 'ContentStatement') {
        return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
      }
    }
    function isNextWhitespace(body, i, isRoot) {
      if (i === undefined) {
        i = -1;
      }
    
      var next = body[i + 1],
          sibling = body[i + 2];
      if (!next) {
        return isRoot;
      }
    
      if (next.type === 'ContentStatement') {
        return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
      }
    }
    
    // Marks the node to the right of the position as omitted.
    // I.e. {{foo}}' ' will mark the ' ' node as omitted.
    //
    // If i is undefined, then the first child will be marked as such.
    //
    // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
    // content is met.
    function omitRight(body, i, multiple) {
      var current = body[i == null ? 0 : i + 1];
      if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
        return;
      }
    
      var original = current.value;
      current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
      current.rightStripped = current.value !== original;
    }
    
    // Marks the node to the left of the position as omitted.
    // I.e. ' '{{foo}} will mark the ' ' node as omitted.
    //
    // If i is undefined then the last child will be marked as such.
    //
    // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
    // content is met.
    function omitLeft(body, i, multiple) {
      var current = body[i == null ? body.length - 1 : i - 1];
      if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
        return;
      }
    
      // We omit the last node if it's whitespace only and not preceeded by a non-content node.
      var original = current.value;
      current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
      current.leftStripped = current.value !== original;
      return current.leftStripped;
    }
    
    exports['default'] = WhitespaceControl;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/compiler/whitespace-control", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.SourceLocation = SourceLocation;
    exports.id = id;
    exports.stripFlags = stripFlags;
    exports.stripComment = stripComment;
    exports.preparePath = preparePath;
    exports.prepareMustache = prepareMustache;
    exports.prepareRawBlock = prepareRawBlock;
    exports.prepareBlock = prepareBlock;
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    
    function id(token) {
      if (/^\[.*\]$/.test(token)) {
        return token.substr(1, token.length - 2);
      } else {
        return token;
      }
    }
    
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === '~',
        close: close.charAt(close.length - 3) === '~'
      };
    }
    
    function stripComment(comment) {
      return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
    }
    
    function preparePath(data, parts, locInfo) {
      locInfo = this.locInfo(locInfo);
    
      var original = data ? '@' : '',
          dig = [],
          depth = 0,
          depthString = '';
    
      for (var i = 0, l = parts.length; i < l; i++) {
        var part = parts[i].part,
    
        // If we have [] syntax then we do not treat path references as operators,
        // i.e. foo.[this] resolves to approximately context.foo['this']
        isLiteral = parts[i].original !== part;
        original += (parts[i].separator || '') + part;
    
        if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
          if (dig.length > 0) {
            throw new _Exception2['default']('Invalid path: ' + original, { loc: locInfo });
          } else if (part === '..') {
            depth++;
            depthString += '../';
          }
        } else {
          dig.push(part);
        }
      }
    
      return new this.PathExpression(data, depth, dig, original, locInfo);
    }
    
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      // Must use charAt to support IE pre-10
      var escapeFlag = open.charAt(3) || open.charAt(2),
          escaped = escapeFlag !== '{' && escapeFlag !== '&';
    
      return new this.MustacheStatement(path, params, hash, escaped, strip, this.locInfo(locInfo));
    }
    
    function prepareRawBlock(openRawBlock, content, close, locInfo) {
      if (openRawBlock.path.original !== close) {
        var errorNode = { loc: openRawBlock.path.loc };
    
        throw new _Exception2['default'](openRawBlock.path.original + ' doesn\'t match ' + close, errorNode);
      }
    
      locInfo = this.locInfo(locInfo);
      var program = new this.Program([content], null, {}, locInfo);
    
      return new this.BlockStatement(openRawBlock.path, openRawBlock.params, openRawBlock.hash, program, undefined, {}, {}, {}, locInfo);
    }
    
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      // When we are chaining inverse calls, we will not have a close path
      if (close && close.path && openBlock.path.original !== close.path.original) {
        var errorNode = { loc: openBlock.path.loc };
    
        throw new _Exception2['default'](openBlock.path.original + ' doesn\'t match ' + close.path.original, errorNode);
      }
    
      program.blockParams = openBlock.blockParams;
    
      var inverse = undefined,
          inverseStrip = undefined;
    
      if (inverseAndProgram) {
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
    
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
    
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
    
      return new this.BlockStatement(openBlock.path, openBlock.params, openBlock.hash, program, inverse, openBlock.strip, inverseStrip, close && close.strip, this.locInfo(locInfo));
    }
  provide("handlebars/dist/cjs/handlebars/compiler/helpers", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/code-gen
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.__esModule = true;
    /*global define */
    
    var _isArray =  require('handlebars/dist/cjs/handlebars/utils');
    
    var SourceNode = undefined;
    
    try {
      /* istanbul ignore next */
      if (typeof define !== 'function' || !define.amd) {
        // We don't support this in AMD environments. For these environments, we asusme that
        // they are running on the browser and thus have no need for the source-map library.
        var SourceMap = require('source-map');
        SourceNode = SourceMap.SourceNode;
      }
    } catch (err) {}
    
    /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
    if (!SourceNode) {
      SourceNode = function (line, column, srcFile, chunks) {
        this.src = '';
        if (chunks) {
          this.add(chunks);
        }
      };
      /* istanbul ignore next */
      SourceNode.prototype = {
        add: function add(chunks) {
          if (_isArray.isArray(chunks)) {
            chunks = chunks.join('');
          }
          this.src += chunks;
        },
        prepend: function prepend(chunks) {
          if (_isArray.isArray(chunks)) {
            chunks = chunks.join('');
          }
          this.src = chunks + this.src;
        },
        toStringWithSourceMap: function toStringWithSourceMap() {
          return { code: this.toString() };
        },
        toString: function toString() {
          return this.src;
        }
      };
    }
    
    function castChunk(chunk, codeGen, loc) {
      if (_isArray.isArray(chunk)) {
        var ret = [];
    
        for (var i = 0, len = chunk.length; i < len; i++) {
          ret.push(codeGen.wrap(chunk[i], loc));
        }
        return ret;
      } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
        // Handle primitives that the SourceNode will throw up on
        return chunk + '';
      }
      return chunk;
    }
    
    function CodeGen(srcFile) {
      this.srcFile = srcFile;
      this.source = [];
    }
    
    CodeGen.prototype = {
      prepend: function prepend(source, loc) {
        this.source.unshift(this.wrap(source, loc));
      },
      push: function push(source, loc) {
        this.source.push(this.wrap(source, loc));
      },
    
      merge: function merge() {
        var source = this.empty();
        this.each(function (line) {
          source.add(['  ', line, '\n']);
        });
        return source;
      },
    
      each: function each(iter) {
        for (var i = 0, len = this.source.length; i < len; i++) {
          iter(this.source[i]);
        }
      },
    
      empty: function empty() {
        var loc = arguments[0] === undefined ? this.currentLocation || { start: {} } : arguments[0];
    
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
      },
      wrap: function wrap(chunk) {
        var loc = arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];
    
        if (chunk instanceof SourceNode) {
          return chunk;
        }
    
        chunk = castChunk(chunk, this, loc);
    
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
      },
    
      functionCall: function functionCall(fn, type, params) {
        params = this.generateList(params);
        return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
      },
    
      quotedString: function quotedString(str) {
        return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
        .replace(/\u2029/g, '\\u2029') + '"';
      },
    
      objectLiteral: function objectLiteral(obj) {
        var pairs = [];
    
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            var value = castChunk(obj[key], this);
            if (value !== 'undefined') {
              pairs.push([this.quotedString(key), ':', value]);
            }
          }
        }
    
        var ret = this.generateList(pairs);
        ret.prepend('{');
        ret.add('}');
        return ret;
      },
    
      generateList: function generateList(entries, loc) {
        var ret = this.empty(loc);
    
        for (var i = 0, len = entries.length; i < len; i++) {
          if (i) {
            ret.add(',');
          }
    
          ret.add(castChunk(entries[i], this, loc));
        }
    
        return ret;
      },
    
      generateArray: function generateArray(entries, loc) {
        var ret = this.generateList(entries, loc);
        ret.prepend('[');
        ret.add(']');
    
        return ret;
      }
    };
    
    exports['default'] = CodeGen;
    module.exports = exports['default'];
    
    /* NOP */
  provide("handlebars/dist/cjs/handlebars/compiler/code-gen", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars.runtime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _import =  require('handlebars/dist/cjs/handlebars/base');
    
    var base = _interopRequireWildcard(_import);
    
    // Each of these augment the Handlebars object. No need to setup here.
    // (This is done to easily share code between commonjs and browse envs)
    
    var _SafeString =  require('handlebars/dist/cjs/handlebars/safe-string');
    
    var _SafeString2 = _interopRequireWildcard(_SafeString);
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _import2 =  require('handlebars/dist/cjs/handlebars/utils');
    
    var Utils = _interopRequireWildcard(_import2);
    
    var _import3 =  require('handlebars/dist/cjs/handlebars/runtime');
    
    var runtime = _interopRequireWildcard(_import3);
    
    var _noConflict =  require('handlebars/dist/cjs/handlebars/no-conflict');
    
    var _noConflict2 = _interopRequireWildcard(_noConflict);
    
    // For compatibility and usage outside of module systems, make the Handlebars object a namespace
    function create() {
      var hb = new base.HandlebarsEnvironment();
    
      Utils.extend(hb, base);
      hb.SafeString = _SafeString2['default'];
      hb.Exception = _Exception2['default'];
      hb.Utils = Utils;
      hb.escapeExpression = Utils.escapeExpression;
    
      hb.VM = runtime;
      hb.template = function (spec) {
        return runtime.template(spec, hb);
      };
    
      return hb;
    }
    
    var inst = create();
    inst.create = create;
    
    _noConflict2['default'](inst);
    
    inst['default'] = inst;
    
    exports['default'] = inst;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars.runtime", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.parse = parse;
    
    var _parser =  require('handlebars/dist/cjs/handlebars/compiler/parser');
    
    var _parser2 = _interopRequireWildcard(_parser);
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    var _WhitespaceControl =  require('handlebars/dist/cjs/handlebars/compiler/whitespace-control');
    
    var _WhitespaceControl2 = _interopRequireWildcard(_WhitespaceControl);
    
    var _import =  require('handlebars/dist/cjs/handlebars/compiler/helpers');
    
    var Helpers = _interopRequireWildcard(_import);
    
    var _extend =  require('handlebars/dist/cjs/handlebars/utils');
    
    exports.parser = _parser2['default'];
    
    var yy = {};
    _extend.extend(yy, Helpers, _AST2['default']);
    
    function parse(input, options) {
      // Just return if an already-compiled AST was passed in.
      if (input.type === 'Program') {
        return input;
      }
    
      _parser2['default'].yy = yy;
    
      // Altering the shared object here, but this is ok as parser is a sync operation
      yy.locInfo = function (locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
    
      var strip = new _WhitespaceControl2['default']();
      return strip.accept(_parser2['default'].parse(input));
    }
  provide("handlebars/dist/cjs/handlebars/compiler/base", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.Compiler = Compiler;
    exports.precompile = precompile;
    exports.compile = compile;
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _isArray$indexOf =  require('handlebars/dist/cjs/handlebars/utils');
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    var slice = [].slice;
    
    function Compiler() {}
    
    // the foundHelper register will disambiguate helper lookup from finding a
    // function in a context. This is necessary for mustache compatibility, which
    // requires that context functions in blocks are evaluated by blockHelperMissing,
    // and then proceed as if the resulting value was provided to blockHelperMissing.
    
    Compiler.prototype = {
      compiler: Compiler,
    
      equals: function equals(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
    
        for (var i = 0; i < len; i++) {
          var opcode = this.opcodes[i],
              otherOpcode = other.opcodes[i];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
    
        // We know that length is the same between the two arrays because they are directly tied
        // to the opcode behavior above.
        len = this.children.length;
        for (var i = 0; i < len; i++) {
          if (!this.children[i].equals(other.children[i])) {
            return false;
          }
        }
    
        return true;
      },
    
      guid: 0,
    
      compile: function compile(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
    
        options.blockParams = options.blockParams || [];
    
        // These changes will propagate to the other compiler components
        var knownHelpers = options.knownHelpers;
        options.knownHelpers = {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          'if': true,
          unless: true,
          'with': true,
          log: true,
          lookup: true
        };
        if (knownHelpers) {
          for (var _name in knownHelpers) {
            if (_name in knownHelpers) {
              options.knownHelpers[_name] = knownHelpers[_name];
            }
          }
        }
    
        return this.accept(program);
      },
    
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(),
            // eslint-disable-line new-cap
        result = childCompiler.compile(program, this.options),
            guid = this.guid++;
    
        this.usePartial = this.usePartial || result.usePartial;
    
        this.children[guid] = result;
        this.useDepths = this.useDepths || result.useDepths;
    
        return guid;
      },
    
      accept: function accept(node) {
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
    
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
    
        var body = program.body,
            bodyLength = body.length;
        for (var i = 0; i < bodyLength; i++) {
          this.accept(body[i]);
        }
    
        this.options.blockParams.shift();
    
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
    
        return this;
      },
    
      BlockStatement: function BlockStatement(block) {
        transformLiteralToPath(block);
    
        var program = block.program,
            inverse = block.inverse;
    
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
    
        var type = this.classifySexpr(block);
    
        if (type === 'helper') {
          this.helperSexpr(block, program, inverse);
        } else if (type === 'simple') {
          this.simpleSexpr(block);
    
          // now that the simple mustache is resolved, we need to
          // evaluate it by executing `blockHelperMissing`
          this.opcode('pushProgram', program);
          this.opcode('pushProgram', inverse);
          this.opcode('emptyHash');
          this.opcode('blockValue', block.path.original);
        } else {
          this.ambiguousSexpr(block, program, inverse);
    
          // now that the simple mustache is resolved, we need to
          // evaluate it by executing `blockHelperMissing`
          this.opcode('pushProgram', program);
          this.opcode('pushProgram', inverse);
          this.opcode('emptyHash');
          this.opcode('ambiguousBlockValue');
        }
    
        this.opcode('append');
      },
    
      PartialStatement: function PartialStatement(partial) {
        this.usePartial = true;
    
        var params = partial.params;
        if (params.length > 1) {
          throw new _Exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
        } else if (!params.length) {
          params.push({ type: 'PathExpression', parts: [], depth: 0 });
        }
    
        var partialName = partial.name.original,
            isDynamic = partial.name.type === 'SubExpression';
        if (isDynamic) {
          this.accept(partial.name);
        }
    
        this.setupFullMustacheParams(partial, undefined, undefined, true);
    
        var indent = partial.indent || '';
        if (this.options.preventIndent && indent) {
          this.opcode('appendContent', indent);
          indent = '';
        }
    
        this.opcode('invokePartial', isDynamic, partialName, indent);
        this.opcode('append');
      },
    
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache); // eslint-disable-line new-cap
    
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode('appendEscaped');
        } else {
          this.opcode('append');
        }
      },
    
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode('appendContent', content.value);
        }
      },
    
      CommentStatement: function CommentStatement() {},
    
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
    
        if (type === 'simple') {
          this.simpleSexpr(sexpr);
        } else if (type === 'helper') {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path,
            name = path.parts[0],
            isBlock = program != null || inverse != null;
    
        this.opcode('getContext', path.depth);
    
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
    
        this.accept(path);
    
        this.opcode('invokeAmbiguous', name, isBlock);
      },
    
      simpleSexpr: function simpleSexpr(sexpr) {
        this.accept(sexpr.path);
        this.opcode('resolvePossibleLambda');
      },
    
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse),
            path = sexpr.path,
            name = path.parts[0];
    
        if (this.options.knownHelpers[name]) {
          this.opcode('invokeKnownHelper', params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _Exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
        } else {
          path.falsy = true;
    
          this.accept(path);
          this.opcode('invokeHelper', params.length, path.original, _AST2['default'].helpers.simpleId(path));
        }
      },
    
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode('getContext', path.depth);
    
        var name = path.parts[0],
            scoped = _AST2['default'].helpers.scopedId(path),
            blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
    
        if (blockParamId) {
          this.opcode('lookupBlockParam', blockParamId, path.parts);
        } else if (!name) {
          // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
          this.opcode('pushContext');
        } else if (path.data) {
          this.options.data = true;
          this.opcode('lookupData', path.depth, path.parts);
        } else {
          this.opcode('lookupOnContext', path.parts, path.falsy, scoped);
        }
      },
    
      StringLiteral: function StringLiteral(string) {
        this.opcode('pushString', string.value);
      },
    
      NumberLiteral: function NumberLiteral(number) {
        this.opcode('pushLiteral', number.value);
      },
    
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode('pushLiteral', bool.value);
      },
    
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode('pushLiteral', 'undefined');
      },
    
      NullLiteral: function NullLiteral() {
        this.opcode('pushLiteral', 'null');
      },
    
      Hash: function Hash(hash) {
        var pairs = hash.pairs,
            i = 0,
            l = pairs.length;
    
        this.opcode('pushHash');
    
        for (; i < l; i++) {
          this.pushParam(pairs[i].value);
        }
        while (i--) {
          this.opcode('assignToHash', pairs[i].key);
        }
        this.opcode('popHash');
      },
    
      // HELPERS
      opcode: function opcode(name) {
        this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
      },
    
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
    
        this.useDepths = true;
      },
    
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _AST2['default'].helpers.simpleId(sexpr.path);
    
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
    
        // a mustache is an eligible helper if:
        // * its id is simple (a single part, not `this` or `..`)
        var isHelper = !isBlockParam && _AST2['default'].helpers.helperExpression(sexpr);
    
        // if a mustache is an eligible helper but not a definite
        // helper, it is ambiguous, and will be resolved in a later
        // pass or at runtime.
        var isEligible = !isBlockParam && (isHelper || isSimple);
    
        // if ambiguous, we can possibly resolve the ambiguity now
        // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
        if (isEligible && !isHelper) {
          var _name2 = sexpr.path.parts[0],
              options = this.options;
    
          if (options.knownHelpers[_name2]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
    
        if (isHelper) {
          return 'helper';
        } else if (isEligible) {
          return 'ambiguous';
        } else {
          return 'simple';
        }
      },
    
      pushParams: function pushParams(params) {
        for (var i = 0, l = params.length; i < l; i++) {
          this.pushParam(params[i]);
        }
      },
    
      pushParam: function pushParam(val) {
        var value = val.value != null ? val.value : val.original || '';
    
        if (this.stringParams) {
          if (value.replace) {
            value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
          }
    
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode('getContext', val.depth || 0);
          this.opcode('pushStringParam', value, val.type);
    
          if (val.type === 'SubExpression') {
            // SubExpressions get evaluated and passed in
            // in string params mode.
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = undefined;
            if (val.parts && !_AST2['default'].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join('.');
              this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
            } else {
              value = val.original || value;
              if (value.replace) {
                value = value.replace(/^\.\//g, '').replace(/^\.$/g, '');
              }
    
              this.opcode('pushId', val.type, value);
            }
          }
          this.accept(val);
        }
      },
    
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
    
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
    
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode('emptyHash', omitEmpty);
        }
    
        return params;
      },
    
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth],
              param = blockParams && _isArray$indexOf.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    
    function precompile(input, options, env) {
      if (input == null || typeof input !== 'string' && input.type !== 'Program') {
        throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
      }
    
      options = options || {};
      if (!('data' in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
    
      var ast = env.parse(input, options),
          environment = new env.Compiler().compile(ast, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    
    function compile(input, _x, env) {
      var options = arguments[1] === undefined ? {} : arguments[1];
    
      if (input == null || typeof input !== 'string' && input.type !== 'Program') {
        throw new _Exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
      }
    
      if (!('data' in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
    
      var compiled = undefined;
    
      function compileInput() {
        var ast = env.parse(input, options),
            environment = new env.Compiler().compile(ast, options),
            templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
        return env.template(templateSpec);
      }
    
      // Template is only compiled on first use and cached after that point.
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function (setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function (i, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i, data, blockParams, depths);
      };
      return ret;
    }
    
    function argEquals(a, b) {
      if (a === b) {
        return true;
      }
    
      if (_isArray$indexOf.isArray(a) && _isArray$indexOf.isArray(b) && a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (!argEquals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    }
    
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        // Casting to string here to make false and 0 literal values play nicely with the rest
        // of the system.
        sexpr.path = new _AST2['default'].PathExpression(false, 0, [literal.original + ''], literal.original + '', literal.loc);
      }
    }
  provide("handlebars/dist/cjs/handlebars/compiler/compiler", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/javascript-compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _COMPILER_REVISION$REVISION_CHANGES =  require('handlebars/dist/cjs/handlebars/base');
    
    var _Exception =  require('handlebars/dist/cjs/handlebars/exception');
    
    var _Exception2 = _interopRequireWildcard(_Exception);
    
    var _isArray =  require('handlebars/dist/cjs/handlebars/utils');
    
    var _CodeGen =  require('handlebars/dist/cjs/handlebars/compiler/code-gen');
    
    var _CodeGen2 = _interopRequireWildcard(_CodeGen);
    
    function Literal(value) {
      this.value = value;
    }
    
    function JavaScriptCompiler() {}
    
    JavaScriptCompiler.prototype = {
      // PUBLIC API: You can override these methods in a subclass to provide
      // alternative compiled forms for name lookup and buffering semantics
      nameLookup: function nameLookup(parent, name /* , type*/) {
        if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
          return [parent, '.', name];
        } else {
          return [parent, '[\'', name, '\']'];
        }
      },
      depthedLookup: function depthedLookup(name) {
        return [this.aliasable('this.lookup'), '(depths, "', name, '")'];
      },
    
      compilerInfo: function compilerInfo() {
        var revision = _COMPILER_REVISION$REVISION_CHANGES.COMPILER_REVISION,
            versions = _COMPILER_REVISION$REVISION_CHANGES.REVISION_CHANGES[revision];
        return [revision, versions];
      },
    
      appendToBuffer: function appendToBuffer(source, location, explicit) {
        // Force a source as this simplifies the merge logic.
        if (!_isArray.isArray(source)) {
          source = [source];
        }
        source = this.source.wrap(source, location);
    
        if (this.environment.isSimple) {
          return ['return ', source, ';'];
        } else if (explicit) {
          // This is a case where the buffer operation occurs as a child of another
          // construct, generally braces. We have to explicitly output these buffer
          // operations to ensure that the emitted code goes in the correct location.
          return ['buffer += ', source, ';'];
        } else {
          source.appendToBuffer = true;
          return source;
        }
      },
    
      initializeBuffer: function initializeBuffer() {
        return this.quotedString('');
      },
      // END PUBLIC API
    
      compile: function compile(environment, options, context, asObject) {
        this.environment = environment;
        this.options = options;
        this.stringParams = this.options.stringParams;
        this.trackIds = this.options.trackIds;
        this.precompile = !asObject;
    
        this.name = this.environment.name;
        this.isChild = !!context;
        this.context = context || {
          programs: [],
          environments: []
        };
    
        this.preamble();
    
        this.stackSlot = 0;
        this.stackVars = [];
        this.aliases = {};
        this.registers = { list: [] };
        this.hashes = [];
        this.compileStack = [];
        this.inlineStack = [];
        this.blockParams = [];
    
        this.compileChildren(environment, options);
    
        this.useDepths = this.useDepths || environment.useDepths || this.options.compat;
        this.useBlockParams = this.useBlockParams || environment.useBlockParams;
    
        var opcodes = environment.opcodes,
            opcode = undefined,
            firstLoc = undefined,
            i = undefined,
            l = undefined;
    
        for (i = 0, l = opcodes.length; i < l; i++) {
          opcode = opcodes[i];
    
          this.source.currentLocation = opcode.loc;
          firstLoc = firstLoc || opcode.loc;
          this[opcode.opcode].apply(this, opcode.args);
        }
    
        // Flush any trailing content that might be pending.
        this.source.currentLocation = firstLoc;
        this.pushSource('');
    
        /* istanbul ignore next */
        if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
          throw new _Exception2['default']('Compile completed with content left on stack');
        }
    
        var fn = this.createFunctionContext(asObject);
        if (!this.isChild) {
          var ret = {
            compiler: this.compilerInfo(),
            main: fn
          };
          var programs = this.context.programs;
          for (i = 0, l = programs.length; i < l; i++) {
            if (programs[i]) {
              ret[i] = programs[i];
            }
          }
    
          if (this.environment.usePartial) {
            ret.usePartial = true;
          }
          if (this.options.data) {
            ret.useData = true;
          }
          if (this.useDepths) {
            ret.useDepths = true;
          }
          if (this.useBlockParams) {
            ret.useBlockParams = true;
          }
          if (this.options.compat) {
            ret.compat = true;
          }
    
          if (!asObject) {
            ret.compiler = JSON.stringify(ret.compiler);
    
            this.source.currentLocation = { start: { line: 1, column: 0 } };
            ret = this.objectLiteral(ret);
    
            if (options.srcName) {
              ret = ret.toStringWithSourceMap({ file: options.destName });
              ret.map = ret.map && ret.map.toString();
            } else {
              ret = ret.toString();
            }
          } else {
            ret.compilerOptions = this.options;
          }
    
          return ret;
        } else {
          return fn;
        }
      },
    
      preamble: function preamble() {
        // track the last context pushed into place to allow skipping the
        // getContext opcode when it would be a noop
        this.lastContext = 0;
        this.source = new _CodeGen2['default'](this.options.srcName);
      },
    
      createFunctionContext: function createFunctionContext(asObject) {
        var varDeclarations = '';
    
        var locals = this.stackVars.concat(this.registers.list);
        if (locals.length > 0) {
          varDeclarations += ', ' + locals.join(', ');
        }
    
        // Generate minimizer alias mappings
        //
        // When using true SourceNodes, this will update all references to the given alias
        // as the source nodes are reused in situ. For the non-source node compilation mode,
        // aliases will not be used, but this case is already being run on the client and
        // we aren't concern about minimizing the template size.
        var aliasCount = 0;
        for (var alias in this.aliases) {
          // eslint-disable-line guard-for-in
          var node = this.aliases[alias];
    
          if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
            varDeclarations += ', alias' + ++aliasCount + '=' + alias;
            node.children[0] = 'alias' + aliasCount;
          }
        }
    
        var params = ['depth0', 'helpers', 'partials', 'data'];
    
        if (this.useBlockParams || this.useDepths) {
          params.push('blockParams');
        }
        if (this.useDepths) {
          params.push('depths');
        }
    
        // Perform a second pass over the output to merge content when possible
        var source = this.mergeSource(varDeclarations);
    
        if (asObject) {
          params.push(source);
    
          return Function.apply(this, params);
        } else {
          return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
        }
      },
      mergeSource: function mergeSource(varDeclarations) {
        var isSimple = this.environment.isSimple,
            appendOnly = !this.forceBuffer,
            appendFirst = undefined,
            sourceSeen = undefined,
            bufferStart = undefined,
            bufferEnd = undefined;
        this.source.each(function (line) {
          if (line.appendToBuffer) {
            if (bufferStart) {
              line.prepend('  + ');
            } else {
              bufferStart = line;
            }
            bufferEnd = line;
          } else {
            if (bufferStart) {
              if (!sourceSeen) {
                appendFirst = true;
              } else {
                bufferStart.prepend('buffer += ');
              }
              bufferEnd.add(';');
              bufferStart = bufferEnd = undefined;
            }
    
            sourceSeen = true;
            if (!isSimple) {
              appendOnly = false;
            }
          }
        });
    
        if (appendOnly) {
          if (bufferStart) {
            bufferStart.prepend('return ');
            bufferEnd.add(';');
          } else if (!sourceSeen) {
            this.source.push('return "";');
          }
        } else {
          varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
    
          if (bufferStart) {
            bufferStart.prepend('return buffer + ');
            bufferEnd.add(';');
          } else {
            this.source.push('return buffer;');
          }
        }
    
        if (varDeclarations) {
          this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
        }
    
        return this.source.merge();
      },
    
      // [blockValue]
      //
      // On stack, before: hash, inverse, program, value
      // On stack, after: return value of blockHelperMissing
      //
      // The purpose of this opcode is to take a block of the form
      // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
      // replace it on the stack with the result of properly
      // invoking blockHelperMissing.
      blockValue: function blockValue(name) {
        var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
            params = [this.contextName(0)];
        this.setupHelperArgs(name, 0, params);
    
        var blockName = this.popStack();
        params.splice(1, 0, blockName);
    
        this.push(this.source.functionCall(blockHelperMissing, 'call', params));
      },
    
      // [ambiguousBlockValue]
      //
      // On stack, before: hash, inverse, program, value
      // Compiler value, before: lastHelper=value of last found helper, if any
      // On stack, after, if no lastHelper: same as [blockValue]
      // On stack, after, if lastHelper: value
      ambiguousBlockValue: function ambiguousBlockValue() {
        // We're being a bit cheeky and reusing the options value from the prior exec
        var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
            params = [this.contextName(0)];
        this.setupHelperArgs('', 0, params, true);
    
        this.flushInline();
    
        var current = this.topStack();
        params.splice(1, 0, current);
    
        this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
      },
    
      // [appendContent]
      //
      // On stack, before: ...
      // On stack, after: ...
      //
      // Appends the string value of `content` to the current buffer
      appendContent: function appendContent(content) {
        if (this.pendingContent) {
          content = this.pendingContent + content;
        } else {
          this.pendingLocation = this.source.currentLocation;
        }
    
        this.pendingContent = content;
      },
    
      // [append]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Coerces `value` to a String and appends it to the current buffer.
      //
      // If `value` is truthy, or 0, it is coerced into a string and appended
      // Otherwise, the empty string is appended
      append: function append() {
        if (this.isInline()) {
          this.replaceStack(function (current) {
            return [' != null ? ', current, ' : ""'];
          });
    
          this.pushSource(this.appendToBuffer(this.popStack()));
        } else {
          var local = this.popStack();
          this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
          if (this.environment.isSimple) {
            this.pushSource(['else { ', this.appendToBuffer('\'\'', undefined, true), ' }']);
          }
        }
      },
    
      // [appendEscaped]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Escape `value` and append it to the buffer
      appendEscaped: function appendEscaped() {
        this.pushSource(this.appendToBuffer([this.aliasable('this.escapeExpression'), '(', this.popStack(), ')']));
      },
    
      // [getContext]
      //
      // On stack, before: ...
      // On stack, after: ...
      // Compiler value, after: lastContext=depth
      //
      // Set the value of the `lastContext` compiler value to the depth
      getContext: function getContext(depth) {
        this.lastContext = depth;
      },
    
      // [pushContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext, ...
      //
      // Pushes the value of the current context onto the stack.
      pushContext: function pushContext() {
        this.pushStackLiteral(this.contextName(this.lastContext));
      },
    
      // [lookupOnContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext[name], ...
      //
      // Looks up the value of `name` on the current context and pushes
      // it onto the stack.
      lookupOnContext: function lookupOnContext(parts, falsy, scoped) {
        var i = 0;
    
        if (!scoped && this.options.compat && !this.lastContext) {
          // The depthed query is expected to handle the undefined logic for the root level that
          // is implemented below, so we evaluate that directly in compat mode
          this.push(this.depthedLookup(parts[i++]));
        } else {
          this.pushContext();
        }
    
        this.resolvePath('context', parts, i, falsy);
      },
    
      // [lookupBlockParam]
      //
      // On stack, before: ...
      // On stack, after: blockParam[name], ...
      //
      // Looks up the value of `parts` on the given block param and pushes
      // it onto the stack.
      lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
        this.useBlockParams = true;
    
        this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
        this.resolvePath('context', parts, 1);
      },
    
      // [lookupData]
      //
      // On stack, before: ...
      // On stack, after: data, ...
      //
      // Push the data lookup operator
      lookupData: function lookupData(depth, parts) {
        if (!depth) {
          this.pushStackLiteral('data');
        } else {
          this.pushStackLiteral('this.data(data, ' + depth + ')');
        }
    
        this.resolvePath('data', parts, 0, true);
      },
    
      resolvePath: function resolvePath(type, parts, i, falsy) {
        var _this = this;
    
        if (this.options.strict || this.options.assumeObjects) {
          this.push(strictLookup(this.options.strict, this, parts, type));
          return;
        }
    
        var len = parts.length;
        for (; i < len; i++) {
          /*eslint-disable no-loop-func */
          this.replaceStack(function (current) {
            var lookup = _this.nameLookup(current, parts[i], type);
            // We want to ensure that zero and false are handled properly if the context (falsy flag)
            // needs to have the special handling for these values.
            if (!falsy) {
              return [' != null ? ', lookup, ' : ', current];
            } else {
              // Otherwise we can use generic falsy handling
              return [' && ', lookup];
            }
          });
          /*eslint-enable no-loop-func */
        }
      },
    
      // [resolvePossibleLambda]
      //
      // On stack, before: value, ...
      // On stack, after: resolved value, ...
      //
      // If the `value` is a lambda, replace it on the stack by
      // the return value of the lambda
      resolvePossibleLambda: function resolvePossibleLambda() {
        this.push([this.aliasable('this.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
      },
    
      // [pushStringParam]
      //
      // On stack, before: ...
      // On stack, after: string, currentContext, ...
      //
      // This opcode is designed for use in string mode, which
      // provides the string value of a parameter along with its
      // depth rather than resolving it immediately.
      pushStringParam: function pushStringParam(string, type) {
        this.pushContext();
        this.pushString(type);
    
        // If it's a subexpression, the string result
        // will be pushed after this opcode.
        if (type !== 'SubExpression') {
          if (typeof string === 'string') {
            this.pushString(string);
          } else {
            this.pushStackLiteral(string);
          }
        }
      },
    
      emptyHash: function emptyHash(omitEmpty) {
        if (this.trackIds) {
          this.push('{}'); // hashIds
        }
        if (this.stringParams) {
          this.push('{}'); // hashContexts
          this.push('{}'); // hashTypes
        }
        this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
      },
      pushHash: function pushHash() {
        if (this.hash) {
          this.hashes.push(this.hash);
        }
        this.hash = { values: [], types: [], contexts: [], ids: [] };
      },
      popHash: function popHash() {
        var hash = this.hash;
        this.hash = this.hashes.pop();
    
        if (this.trackIds) {
          this.push(this.objectLiteral(hash.ids));
        }
        if (this.stringParams) {
          this.push(this.objectLiteral(hash.contexts));
          this.push(this.objectLiteral(hash.types));
        }
    
        this.push(this.objectLiteral(hash.values));
      },
    
      // [pushString]
      //
      // On stack, before: ...
      // On stack, after: quotedString(string), ...
      //
      // Push a quoted version of `string` onto the stack
      pushString: function pushString(string) {
        this.pushStackLiteral(this.quotedString(string));
      },
    
      // [pushLiteral]
      //
      // On stack, before: ...
      // On stack, after: value, ...
      //
      // Pushes a value onto the stack. This operation prevents
      // the compiler from creating a temporary variable to hold
      // it.
      pushLiteral: function pushLiteral(value) {
        this.pushStackLiteral(value);
      },
    
      // [pushProgram]
      //
      // On stack, before: ...
      // On stack, after: program(guid), ...
      //
      // Push a program expression onto the stack. This takes
      // a compile-time guid and converts it into a runtime-accessible
      // expression.
      pushProgram: function pushProgram(guid) {
        if (guid != null) {
          this.pushStackLiteral(this.programExpression(guid));
        } else {
          this.pushStackLiteral(null);
        }
      },
    
      // [invokeHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // Pops off the helper's parameters, invokes the helper,
      // and pushes the helper's return value onto the stack.
      //
      // If the helper is not found, `helperMissing` is called.
      invokeHelper: function invokeHelper(paramSize, name, isSimple) {
        var nonHelper = this.popStack(),
            helper = this.setupHelper(paramSize, name),
            simple = isSimple ? [helper.name, ' || '] : '';
    
        var lookup = ['('].concat(simple, nonHelper);
        if (!this.options.strict) {
          lookup.push(' || ', this.aliasable('helpers.helperMissing'));
        }
        lookup.push(')');
    
        this.push(this.source.functionCall(lookup, 'call', helper.callParams));
      },
    
      // [invokeKnownHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // This operation is used when the helper is known to exist,
      // so a `helperMissing` fallback is not required.
      invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
        var helper = this.setupHelper(paramSize, name);
        this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
      },
    
      // [invokeAmbiguous]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of disambiguation
      //
      // This operation is used when an expression like `{{foo}}`
      // is provided, but we don't know at compile-time whether it
      // is a helper or a path.
      //
      // This operation emits more code than the other options,
      // and can be avoided by passing the `knownHelpers` and
      // `knownHelpersOnly` flags at compile-time.
      invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
        this.useRegister('helper');
    
        var nonHelper = this.popStack();
    
        this.emptyHash();
        var helper = this.setupHelper(0, name, helperCall);
    
        var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
    
        var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
        if (!this.options.strict) {
          lookup[0] = '(helper = ';
          lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
        }
    
        this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
      },
    
      // [invokePartial]
      //
      // On stack, before: context, ...
      // On stack after: result of partial invocation
      //
      // This operation pops off a context, invokes a partial with that context,
      // and pushes the result of the invocation back.
      invokePartial: function invokePartial(isDynamic, name, indent) {
        var params = [],
            options = this.setupParams(name, 1, params, false);
    
        if (isDynamic) {
          name = this.popStack();
          delete options.name;
        }
    
        if (indent) {
          options.indent = JSON.stringify(indent);
        }
        options.helpers = 'helpers';
        options.partials = 'partials';
    
        if (!isDynamic) {
          params.unshift(this.nameLookup('partials', name, 'partial'));
        } else {
          params.unshift(name);
        }
    
        if (this.options.compat) {
          options.depths = 'depths';
        }
        options = this.objectLiteral(options);
        params.push(options);
    
        this.push(this.source.functionCall('this.invokePartial', '', params));
      },
    
      // [assignToHash]
      //
      // On stack, before: value, ..., hash, ...
      // On stack, after: ..., hash, ...
      //
      // Pops a value off the stack and assigns it to the current hash
      assignToHash: function assignToHash(key) {
        var value = this.popStack(),
            context = undefined,
            type = undefined,
            id = undefined;
    
        if (this.trackIds) {
          id = this.popStack();
        }
        if (this.stringParams) {
          type = this.popStack();
          context = this.popStack();
        }
    
        var hash = this.hash;
        if (context) {
          hash.contexts[key] = context;
        }
        if (type) {
          hash.types[key] = type;
        }
        if (id) {
          hash.ids[key] = id;
        }
        hash.values[key] = value;
      },
    
      pushId: function pushId(type, name, child) {
        if (type === 'BlockParam') {
          this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
        } else if (type === 'PathExpression') {
          this.pushString(name);
        } else if (type === 'SubExpression') {
          this.pushStackLiteral('true');
        } else {
          this.pushStackLiteral('null');
        }
      },
    
      // HELPERS
    
      compiler: JavaScriptCompiler,
    
      compileChildren: function compileChildren(environment, options) {
        var children = environment.children,
            child = undefined,
            compiler = undefined;
    
        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];
          compiler = new this.compiler(); // eslint-disable-line new-cap
    
          var index = this.matchExistingProgram(child);
    
          if (index == null) {
            this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
            index = this.context.programs.length;
            child.index = index;
            child.name = 'program' + index;
            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
            this.context.environments[index] = child;
    
            this.useDepths = this.useDepths || compiler.useDepths;
            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
          } else {
            child.index = index;
            child.name = 'program' + index;
    
            this.useDepths = this.useDepths || child.useDepths;
            this.useBlockParams = this.useBlockParams || child.useBlockParams;
          }
        }
      },
      matchExistingProgram: function matchExistingProgram(child) {
        for (var i = 0, len = this.context.environments.length; i < len; i++) {
          var environment = this.context.environments[i];
          if (environment && environment.equals(child)) {
            return i;
          }
        }
      },
    
      programExpression: function programExpression(guid) {
        var child = this.environment.children[guid],
            programParams = [child.index, 'data', child.blockParams];
    
        if (this.useBlockParams || this.useDepths) {
          programParams.push('blockParams');
        }
        if (this.useDepths) {
          programParams.push('depths');
        }
    
        return 'this.program(' + programParams.join(', ') + ')';
      },
    
      useRegister: function useRegister(name) {
        if (!this.registers[name]) {
          this.registers[name] = true;
          this.registers.list.push(name);
        }
      },
    
      push: function push(expr) {
        if (!(expr instanceof Literal)) {
          expr = this.source.wrap(expr);
        }
    
        this.inlineStack.push(expr);
        return expr;
      },
    
      pushStackLiteral: function pushStackLiteral(item) {
        this.push(new Literal(item));
      },
    
      pushSource: function pushSource(source) {
        if (this.pendingContent) {
          this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
          this.pendingContent = undefined;
        }
    
        if (source) {
          this.source.push(source);
        }
      },
    
      replaceStack: function replaceStack(callback) {
        var prefix = ['('],
            stack = undefined,
            createdStack = undefined,
            usedLiteral = undefined;
    
        /* istanbul ignore next */
        if (!this.isInline()) {
          throw new _Exception2['default']('replaceStack on non-inline');
        }
    
        // We want to merge the inline statement into the replacement statement via ','
        var top = this.popStack(true);
    
        if (top instanceof Literal) {
          // Literals do not need to be inlined
          stack = [top.value];
          prefix = ['(', stack];
          usedLiteral = true;
        } else {
          // Get or create the current stack name for use by the inline
          createdStack = true;
          var _name = this.incrStack();
    
          prefix = ['((', this.push(_name), ' = ', top, ')'];
          stack = this.topStack();
        }
    
        var item = callback.call(this, stack);
    
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push(prefix.concat(item, ')'));
      },
    
      incrStack: function incrStack() {
        this.stackSlot++;
        if (this.stackSlot > this.stackVars.length) {
          this.stackVars.push('stack' + this.stackSlot);
        }
        return this.topStackName();
      },
      topStackName: function topStackName() {
        return 'stack' + this.stackSlot;
      },
      flushInline: function flushInline() {
        var inlineStack = this.inlineStack;
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          /* istanbul ignore if */
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            var stack = this.incrStack();
            this.pushSource([stack, ' = ', entry, ';']);
            this.compileStack.push(stack);
          }
        }
      },
      isInline: function isInline() {
        return this.inlineStack.length;
      },
    
      popStack: function popStack(wrapped) {
        var inline = this.isInline(),
            item = (inline ? this.inlineStack : this.compileStack).pop();
    
        if (!wrapped && item instanceof Literal) {
          return item.value;
        } else {
          if (!inline) {
            /* istanbul ignore next */
            if (!this.stackSlot) {
              throw new _Exception2['default']('Invalid stack pop');
            }
            this.stackSlot--;
          }
          return item;
        }
      },
    
      topStack: function topStack() {
        var stack = this.isInline() ? this.inlineStack : this.compileStack,
            item = stack[stack.length - 1];
    
        /* istanbul ignore if */
        if (item instanceof Literal) {
          return item.value;
        } else {
          return item;
        }
      },
    
      contextName: function contextName(context) {
        if (this.useDepths && context) {
          return 'depths[' + context + ']';
        } else {
          return 'depth' + context;
        }
      },
    
      quotedString: function quotedString(str) {
        return this.source.quotedString(str);
      },
    
      objectLiteral: function objectLiteral(obj) {
        return this.source.objectLiteral(obj);
      },
    
      aliasable: function aliasable(name) {
        var ret = this.aliases[name];
        if (ret) {
          ret.referenceCount++;
          return ret;
        }
    
        ret = this.aliases[name] = this.source.wrap(name);
        ret.aliasable = true;
        ret.referenceCount = 1;
    
        return ret;
      },
    
      setupHelper: function setupHelper(paramSize, name, blockHelper) {
        var params = [],
            paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
        var foundHelper = this.nameLookup('helpers', name, 'helper');
    
        return {
          params: params,
          paramsInit: paramsInit,
          name: foundHelper,
          callParams: [this.contextName(0)].concat(params)
        };
      },
    
      setupParams: function setupParams(helper, paramSize, params) {
        var options = {},
            contexts = [],
            types = [],
            ids = [],
            param = undefined;
    
        options.name = this.quotedString(helper);
        options.hash = this.popStack();
    
        if (this.trackIds) {
          options.hashIds = this.popStack();
        }
        if (this.stringParams) {
          options.hashTypes = this.popStack();
          options.hashContexts = this.popStack();
        }
    
        var inverse = this.popStack(),
            program = this.popStack();
    
        // Avoid setting fn and inverse if neither are set. This allows
        // helpers to do a check for `if (options.fn)`
        if (program || inverse) {
          options.fn = program || 'this.noop';
          options.inverse = inverse || 'this.noop';
        }
    
        // The parameters go on to the stack in order (making sure that they are evaluated in order)
        // so we need to pop them off the stack in reverse order
        var i = paramSize;
        while (i--) {
          param = this.popStack();
          params[i] = param;
    
          if (this.trackIds) {
            ids[i] = this.popStack();
          }
          if (this.stringParams) {
            types[i] = this.popStack();
            contexts[i] = this.popStack();
          }
        }
    
        if (this.trackIds) {
          options.ids = this.source.generateArray(ids);
        }
        if (this.stringParams) {
          options.types = this.source.generateArray(types);
          options.contexts = this.source.generateArray(contexts);
        }
    
        if (this.options.data) {
          options.data = 'data';
        }
        if (this.useBlockParams) {
          options.blockParams = 'blockParams';
        }
        return options;
      },
    
      setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
        var options = this.setupParams(helper, paramSize, params, true);
        options = this.objectLiteral(options);
        if (useRegister) {
          this.useRegister('options');
          params.push('options');
          return ['options=', options];
        } else {
          params.push(options);
          return '';
        }
      }
    };
    
    (function () {
      var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
    
      var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
    
      for (var i = 0, l = reservedWords.length; i < l; i++) {
        compilerWords[reservedWords[i]] = true;
      }
    })();
    
    JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
      return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
    };
    
    function strictLookup(requireTerminal, compiler, parts, type) {
      var stack = compiler.popStack(),
          i = 0,
          len = parts.length;
      if (requireTerminal) {
        len--;
      }
    
      for (; i < len; i++) {
        stack = compiler.nameLookup(stack, parts[i], type);
      }
    
      if (requireTerminal) {
        return [compiler.aliasable('this.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
      } else {
        return stack;
      }
    }
    
    exports['default'] = JavaScriptCompiler;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars/compiler/javascript-compiler", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    
    var _runtime =  require('handlebars/dist/cjs/handlebars.runtime');
    
    var _runtime2 = _interopRequireWildcard(_runtime);
    
    // Compiler imports
    
    var _AST =  require('handlebars/dist/cjs/handlebars/compiler/ast');
    
    var _AST2 = _interopRequireWildcard(_AST);
    
    var _Parser$parse =  require('handlebars/dist/cjs/handlebars/compiler/base');
    
    var _Compiler$compile$precompile =  require('handlebars/dist/cjs/handlebars/compiler/compiler');
    
    var _JavaScriptCompiler =  require('handlebars/dist/cjs/handlebars/compiler/javascript-compiler');
    
    var _JavaScriptCompiler2 = _interopRequireWildcard(_JavaScriptCompiler);
    
    var _Visitor =  require('handlebars/dist/cjs/handlebars/compiler/visitor');
    
    var _Visitor2 = _interopRequireWildcard(_Visitor);
    
    var _noConflict =  require('handlebars/dist/cjs/handlebars/no-conflict');
    
    var _noConflict2 = _interopRequireWildcard(_noConflict);
    
    var _create = _runtime2['default'].create;
    function create() {
      var hb = _create();
    
      hb.compile = function (input, options) {
        return _Compiler$compile$precompile.compile(input, options, hb);
      };
      hb.precompile = function (input, options) {
        return _Compiler$compile$precompile.precompile(input, options, hb);
      };
    
      hb.AST = _AST2['default'];
      hb.Compiler = _Compiler$compile$precompile.Compiler;
      hb.JavaScriptCompiler = _JavaScriptCompiler2['default'];
      hb.Parser = _Parser$parse.parser;
      hb.parse = _Parser$parse.parse;
    
      return hb;
    }
    
    var inst = create();
    inst.create = create;
    
    _noConflict2['default'](inst);
    
    inst.Visitor = _Visitor2['default'];
    
    inst['default'] = inst;
    
    exports['default'] = inst;
    module.exports = exports['default'];
  provide("handlebars/dist/cjs/handlebars", module.exports);
}(global));

// pakmanager:handlebars/dist/cjs/handlebars/compiler/printer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };
    
    exports.__esModule = true;
    exports.print = print;
    exports.PrintVisitor = PrintVisitor;
    /*eslint-disable new-cap */
    
    var _Visitor =  require('handlebars/dist/cjs/handlebars/compiler/visitor');
    
    var _Visitor2 = _interopRequireWildcard(_Visitor);
    
    function print(ast) {
      return new PrintVisitor().accept(ast);
    }
    
    function PrintVisitor() {
      this.padding = 0;
    }
    
    PrintVisitor.prototype = new _Visitor2['default']();
    
    PrintVisitor.prototype.pad = function (string) {
      var out = '';
    
      for (var i = 0, l = this.padding; i < l; i++) {
        out = out + '  ';
      }
    
      out = out + string + '\n';
      return out;
    };
    
    PrintVisitor.prototype.Program = function (program) {
      var out = '',
          body = program.body,
          i = undefined,
          l = undefined;
    
      if (program.blockParams) {
        var blockParams = 'BLOCK PARAMS: [';
        for (i = 0, l = program.blockParams.length; i < l; i++) {
          blockParams += ' ' + program.blockParams[i];
        }
        blockParams += ' ]';
        out += this.pad(blockParams);
      }
    
      for (i = 0, l = body.length; i < l; i++) {
        out = out + this.accept(body[i]);
      }
    
      this.padding--;
    
      return out;
    };
    
    PrintVisitor.prototype.MustacheStatement = function (mustache) {
      return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
    };
    
    PrintVisitor.prototype.BlockStatement = function (block) {
      var out = '';
    
      out = out + this.pad('BLOCK:');
      this.padding++;
      out = out + this.pad(this.SubExpression(block));
      if (block.program) {
        out = out + this.pad('PROGRAM:');
        this.padding++;
        out = out + this.accept(block.program);
        this.padding--;
      }
      if (block.inverse) {
        if (block.program) {
          this.padding++;
        }
        out = out + this.pad('{{^}}');
        this.padding++;
        out = out + this.accept(block.inverse);
        this.padding--;
        if (block.program) {
          this.padding--;
        }
      }
      this.padding--;
    
      return out;
    };
    
    PrintVisitor.prototype.PartialStatement = function (partial) {
      var content = 'PARTIAL:' + partial.name.original;
      if (partial.params[0]) {
        content += ' ' + this.accept(partial.params[0]);
      }
      if (partial.hash) {
        content += ' ' + this.accept(partial.hash);
      }
      return this.pad('{{> ' + content + ' }}');
    };
    
    PrintVisitor.prototype.ContentStatement = function (content) {
      return this.pad('CONTENT[ \'' + content.value + '\' ]');
    };
    
    PrintVisitor.prototype.CommentStatement = function (comment) {
      return this.pad('{{! \'' + comment.value + '\' }}');
    };
    
    PrintVisitor.prototype.SubExpression = function (sexpr) {
      var params = sexpr.params,
          paramStrings = [],
          hash = undefined;
    
      for (var i = 0, l = params.length; i < l; i++) {
        paramStrings.push(this.accept(params[i]));
      }
    
      params = '[' + paramStrings.join(', ') + ']';
    
      hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';
    
      return this.accept(sexpr.path) + ' ' + params + hash;
    };
    
    PrintVisitor.prototype.PathExpression = function (id) {
      var path = id.parts.join('/');
      return (id.data ? '@' : '') + 'PATH:' + path;
    };
    
    PrintVisitor.prototype.StringLiteral = function (string) {
      return '"' + string.value + '"';
    };
    
    PrintVisitor.prototype.NumberLiteral = function (number) {
      return 'NUMBER{' + number.value + '}';
    };
    
    PrintVisitor.prototype.BooleanLiteral = function (bool) {
      return 'BOOLEAN{' + bool.value + '}';
    };
    
    PrintVisitor.prototype.UndefinedLiteral = function () {
      return 'UNDEFINED';
    };
    
    PrintVisitor.prototype.NullLiteral = function () {
      return 'NULL';
    };
    
    PrintVisitor.prototype.Hash = function (hash) {
      var pairs = hash.pairs,
          joinedPairs = [];
    
      for (var i = 0, l = pairs.length; i < l; i++) {
        joinedPairs.push(this.accept(pairs[i]));
      }
    
      return 'HASH{' + joinedPairs.join(', ') + '}';
    };
    PrintVisitor.prototype.HashPair = function (pair) {
      return pair.key + '=' + this.accept(pair.value);
    };
    /*eslint-enable new-cap */
  provide("handlebars/dist/cjs/handlebars/compiler/printer", module.exports);
}(global));

// pakmanager:handlebars
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // USAGE:
    // var handlebars =  require('handlebars');
    /* eslint-disable no-var */
    
    // var local = handlebars.create();
    
    var handlebars =  require('handlebars/dist/cjs/handlebars')['default'];
    
    var printer =  require('handlebars/dist/cjs/handlebars/compiler/printer');
    handlebars.PrintVisitor = printer.PrintVisitor;
    handlebars.print = printer.print;
    
    module.exports = handlebars;
    
    // Publish a Node.js require() handler for .handlebars and .hbs files
    function extension(module, filename) {
      var fs = require('fs');
      var templateString = fs.readFileSync(filename, 'utf8');
      module.exports = handlebars.compile(templateString);
    }
    /* istanbul ignore else */
    if (typeof require !== 'undefined' && require.extensions) {
      require.extensions['.handlebars'] = extension;
      require.extensions['.hbs'] = extension;
    }
    
  provide("handlebars", module.exports);
}(global));

// pakmanager:cli-spinner
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var readline = require('readline');
    
    var defaultSpinnerString = 0;
    var defaultSpinnerDelay = 60;
    
    var Spinner = function(textToShow){
      this.text = textToShow || '';
      this.setSpinnerString(defaultSpinnerString);
      this.setSpinnerDelay(defaultSpinnerDelay);
    };
    
    Spinner.spinners = [
      '|/-\\',
      '--',
      '',
      '',
      '',
      '',
      '.oOOo.',
      '.oO@*',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      ''
    ];
    
    Spinner.setDefaultSpinnerString = function(value) {
      defaultSpinnerString = value;
    };
    
    Spinner.setDefaultSpinnerDelay = function(value) {
      defaultSpinnerDelay = value;
    };
    
    Spinner.prototype.start = function() {
      var current = 0;
      var self = this;
      var hasPos = self.text.indexOf('%s') > -1;
      this.id = setInterval(function() {
        var msg = hasPos ? self.text.replace('%s', self.chars[current]) : self.chars[current] + ' ' + self.text;
        clearLine();
        process.stdout.write(msg);
        current = ++current % self.chars.length;
      }, this.delay);
    };
    
    Spinner.prototype.setSpinnerDelay = function(n) {
      this.delay = n;
    };
    
    Spinner.prototype.setSpinnerString = function(str) {
      this.chars = mapToSpinner(str, this.spinners).split('');
    };
    
    Spinner.prototype.stop = function(clear) {
      clearInterval(this.id);
      if (clear) {
        clearLine();
      }
    };
    
    // Helpers
    
    function isInt(value) {
      return (typeof value==='number' && (value%1)===0);
    }
    
    function mapToSpinner(value, spinners) {
      // Not an integer, return as strng
      if (!isInt(value)) {
        return value + '';
      }
    
      // Check if index is within bounds
      value = (value >= Spinner.spinners.length) ? 0 : value;
      // If negative, count from the end
      value = (value < 0) ? Spinner.spinners.length + value : value;
    
      return Spinner.spinners[value];
    }
    
    function clearLine() {
        readline.clearLine(process.stdout, 0);
        readline.cursorTo(process.stdout, 0);
    }
    
    exports.Spinner = Spinner;
  provide("cli-spinner", module.exports);
}(global));

// pakmanager:read
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = read
    
    var readline = require('readline')
    var Mute = require('mute-stream')
    
    function read (opts, cb) {
      if (opts.num) {
        throw new Error('read() no longer accepts a char number limit')
      }
    
      if (typeof opts.default !== 'undefined' &&
          typeof opts.default !== 'string' &&
          typeof opts.default !== 'number') {
        throw new Error('default value must be string or number')
      }
    
      var input = opts.input || process.stdin
      var output = opts.output || process.stdout
      var prompt = (opts.prompt || '').trim() + ' '
      var silent = opts.silent
      var editDef = false
      var timeout = opts.timeout
    
      var def = opts.default || ''
      if (def) {
        if (silent) {
          prompt += '(<default hidden>) '
        } else if (opts.edit) {
          editDef = true
        } else {
          prompt += '(' + def + ') '
        }
      }
      var terminal = !!(opts.terminal || output.isTTY)
    
      var m = new Mute({ replace: opts.replace, prompt: prompt })
      m.pipe(output, {end: false})
      output = m
      var rlOpts = { input: input, output: output, terminal: terminal }
    
      if (process.version.match(/^v0\.6/)) {
        var rl = readline.createInterface(rlOpts.input, rlOpts.output)
      } else {
        var rl = readline.createInterface(rlOpts)
      }
    
    
      output.unmute()
      rl.setPrompt(prompt)
      rl.prompt()
      if (silent) {
        output.mute()
      } else if (editDef) {
        rl.line = def
        rl.cursor = def.length
        rl._refreshLine()
      }
    
      var called = false
      rl.on('line', onLine)
      rl.on('error', onError)
    
      rl.on('SIGINT', function () {
        rl.close()
        onError(new Error('canceled'))
      })
    
      var timer
      if (timeout) {
        timer = setTimeout(function () {
          onError(new Error('timed out'))
        }, timeout)
      }
    
      function done () {
        called = true
        rl.close()
    
        if (process.version.match(/^v0\.6/)) {
          rl.input.removeAllListeners('data')
          rl.input.removeAllListeners('keypress')
          rl.input.pause()
        }
    
        clearTimeout(timer)
        output.mute()
        output.end()
      }
    
      function onError (er) {
        if (called) return
        done()
        return cb(er)
      }
    
      function onLine (line) {
        if (called) return
        if (silent && terminal) {
          output.unmute()
          output.write('\r\n')
        }
        done()
        // truncate the \n at the end.
        line = line.replace(/\r?\n$/, '')
        var isDefault = !!(editDef && line === def)
        if (def && !line) {
          isDefault = true
          line = def
        }
        cb(null, line, isDefault)
      }
    }
    
  provide("read", module.exports);
}(global));

// pakmanager:revalidator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function (exports) {
      exports.validate = validate;
      exports.mixin = mixin;
    
      //
      // ### function validate (object, schema, options)
      // #### {Object} object the object to validate.
      // #### {Object} schema (optional) the JSON Schema to validate against.
      // #### {Object} options (optional) options controlling the validation
      //      process. See {@link #validate.defaults) for details.
      // Validate <code>object</code> against a JSON Schema.
      // If <code>object</code> is self-describing (i.e. has a
      // <code>$schema</code> property), it will also be validated
      // against the referenced schema. [TODO]: This behaviour bay be
      // suppressed by setting the {@link #validate.options.???}
      // option to <code>???</code>.[/TODO]
      //
      // If <code>schema</code> is not specified, and <code>object</code>
      // is not self-describing, validation always passes.
      //
      // <strong>Note:</strong> in order to pass options but no schema,
      // <code>schema</code> <em>must</em> be specified in the call to
      // <code>validate()</code>; otherwise, <code>options</code> will
      // be interpreted as the schema. <code>schema</code> may be passed
      // as <code>null</code>, <code>undefinded</code>, or the empty object
      // (<code>{}</code>) in this case.
      //
      function validate(object, schema, options) {
        options = mixin({}, validate.defaults, options);
        var errors = [];
    
        if (schema.type === 'array')
          validateProperty(object, object, '', schema, options, errors);
        else
          validateObject(object, schema, options, errors);
    
        //
        // TODO: self-described validation
        // if (! options.selfDescribing) { ... }
        //
    
        return {
          valid: !(errors.length),
          errors: errors
        };
      };
    
      /**
       * Default validation options. Defaults can be overridden by
       * passing an 'options' hash to {@link #validate}. They can
       * also be set globally be changing the values in
       * <code>validate.defaults</code> directly.
       */
      validate.defaults = {
          /**
           * <p>
           * Enforce 'format' constraints.
           * </p><p>
           * <em>Default: <code>true</code></em>
           * </p>
           */
          validateFormats: true,
          /**
           * <p>
           * When {@link #validateFormats} is <code>true</code>,
           * treat unrecognized formats as validation errors.
           * </p><p>
           * <em>Default: <code>false</code></em>
           * </p>
           *
           * @see validation.formats for default supported formats.
           */
          validateFormatsStrict: false,
          /**
           * <p>
           * When {@link #validateFormats} is <code>true</code>,
           * also validate formats defined in {@link #validate.formatExtensions}.
           * </p><p>
           * <em>Default: <code>true</code></em>
           * </p>
           */
          validateFormatExtensions: true,
          /**
           * <p>
           * When {@link #additionalProperties} is <code>true</code>,
           * allow additional unvisited properties on the object.
           * </p><p>
           * <em>Default: <code>true</code></em>
           * </p>
           */
          additionalProperties: true
      };
    
      /**
       * Default messages to include with validation errors.
       */
      validate.messages = {
          required:             "is required",
          allowEmpty:           "must not be empty",
          minLength:            "is too short (minimum is %{expected} characters)",
          maxLength:            "is too long (maximum is %{expected} characters)",
          pattern:              "invalid input",
          minimum:              "must be greater than or equal to %{expected}",
          maximum:              "must be less than or equal to %{expected}",
          exclusiveMinimum:     "must be greater than %{expected}",
          exclusiveMaximum:     "must be less than %{expected}",
          divisibleBy:          "must be divisible by %{expected}",
          minItems:             "must contain more than %{expected} items",
          maxItems:             "must contain less than %{expected} items",
          uniqueItems:          "must hold a unique set of values",
          format:               "is not a valid %{expected}",
          conform:              "must conform to given constraint",
          type:                 "must be of %{expected} type",
          additionalProperties: "must not exist"
      };
      validate.messages['enum'] = "must be present in given enumerator";
    
      /**
       *
       */
      validate.formats = {
        'email':          /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
        'ip-address':     /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/i,
        'ipv6':           /^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$/,
        'date-time':      /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:.\d{1,3})?Z$/,
        'date':           /^\d{4}-\d{2}-\d{2}$/,
        'time':           /^\d{2}:\d{2}:\d{2}$/,
        'color':          /^#[a-z0-9]{6}|#[a-z0-9]{3}|(?:rgb\(\s*(?:[+-]?\d+%?)\s*,\s*(?:[+-]?\d+%?)\s*,\s*(?:[+-]?\d+%?)\s*\))aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow$/i,
        //'style':        (not supported)
        //'phone':        (not supported)
        //'uri':          (not supported)
        'host-name':      /^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])/,
        'utc-millisec':   {
          test: function (value) {
            return typeof(value) === 'number' && value >= 0;
          }
        },
        'regex':          {
          test: function (value) {
            try { new RegExp(value) }
            catch (e) { return false }
    
            return true;
          }
        }
      };
    
      /**
       *
       */
      validate.formatExtensions = {
        'url': /^(https?|ftp|git):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
      };
    
      function mixin(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) { continue }
    
          if (typeof(source) !== 'object') {
            throw new TypeError('mixin non-object');
          }
    
          for (var p in source) {
            if (source.hasOwnProperty(p)) {
              obj[p] = source[p];
            }
          }
        }
    
        return obj;
      };
    
      function validateObject(object, schema, options, errors) {
        var props, allProps = Object.keys(object),
            visitedProps = [];
    
        // see 5.2
        if (schema.properties) {
          props = schema.properties;
          for (var p in props) {
            if (props.hasOwnProperty(p)) {
              visitedProps.push(p);
              validateProperty(object, object[p], p, props[p], options, errors);
            }
          }
        }
    
        // see 5.3
        if (schema.patternProperties) {
          props = schema.patternProperties;
          for (var p in props) {
            if (props.hasOwnProperty(p)) {
              var re = new RegExp(p);
    
              // Find all object properties that are matching `re`
              for (var k in object) {
                if (object.hasOwnProperty(k)) {
                  if (re.exec(k) !== null) {
                    validateProperty(object, object[k], k, props[p], options, errors);
                    visitedProps.push(k);
                  }
                }
              }
            }
          }
        }
    
        //if additionalProperties is not defined set default value
        if (schema.additionalProperties === undefined) {
          schema.additionalProperties = options.additionalProperties;
        }
    
        // see 5.4
        if (undefined !== schema.additionalProperties) {
          var i, l;
    
          var unvisitedProps = allProps.filter(function(k){
            return -1 === visitedProps.indexOf(k);
          });
    
          // Prevent additional properties; each unvisited property is therefore an error
          if (schema.additionalProperties === false && unvisitedProps.length > 0) {
            for (i = 0, l = unvisitedProps.length; i < l; i++) {
              error("additionalProperties", unvisitedProps[i], object[unvisitedProps[i]], false, errors);
            }
          }
          // additionalProperties is a schema and validate unvisited properties against that schema
          else if (typeof schema.additionalProperties == "object" && unvisitedProps.length > 0) {
            for (i = 0, l = unvisitedProps.length; i < l; i++) {
              validateProperty(object, object[unvisitedProps[i]], unvisitedProps[i], schema.unvisitedProperties, options, errors);
            }
          }
        }
    
      };
    
      function validateProperty(object, value, property, schema, options, errors) {
        var format,
            valid,
            spec,
            type;
    
        function constrain(name, value, assert) {
          if (schema[name] !== undefined && !assert(value, schema[name])) {
            error(name, property, value, schema, errors);
          }
        }
    
        if (value === undefined) {
          if (schema.required && schema.type !== 'any') {
            return error('required', property, undefined, schema, errors);
          } else {
            return;
          }
        }
    
        if (options.cast) {
          if (('integer' === schema.type || 'number' === schema.type) && value == +value) {
            value = +value;
            object[property] = value;
          }
    
          if ('boolean' === schema.type) {
            if ('true' === value || '1' === value || 1 === value) {
              value = true;
              object[property] = value;
            }
    
            if ('false' === value || '0' === value || 0 === value) {
              value = false;
              object[property] = value;
            }
          }
        }
    
        if (schema.format && options.validateFormats) {
          format = schema.format;
    
          if (options.validateFormatExtensions) { spec = validate.formatExtensions[format] }
          if (!spec) { spec = validate.formats[format] }
          if (!spec) {
            if (options.validateFormatsStrict) {
              return error('format', property, value, schema, errors);
            }
          }
          else {
            if (!spec.test(value)) {
              return error('format', property, value, schema, errors);
            }
          }
        }
    
        if (schema['enum'] && schema['enum'].indexOf(value) === -1) {
          error('enum', property, value, schema, errors);
        }
    
        // Dependencies (see 5.8)
        if (typeof schema.dependencies === 'string' &&
            object[schema.dependencies] === undefined) {
          error('dependencies', property, null, schema, errors);
        }
    
        if (isArray(schema.dependencies)) {
          for (var i = 0, l = schema.dependencies.length; i < l; i++) {
            if (object[schema.dependencies[i]] === undefined) {
              error('dependencies', property, null, schema, errors);
            }
          }
        }
    
        if (typeof schema.dependencies === 'object') {
          validateObject(object, schema.dependencies, options, errors);
        }
    
        checkType(value, schema.type, function(err, type) {
          if (err) return error('type', property, typeof value, schema, errors);
    
          constrain('conform', value, function (a, e) { return e(a, object) });
    
          switch (type || (isArray(value) ? 'array' : typeof value)) {
            case 'string':
              constrain('allowEmpty', value,        function (a, e) { return e ? e : a !== '' });
              constrain('minLength',  value.length, function (a, e) { return a >= e });
              constrain('maxLength',  value.length, function (a, e) { return a <= e });
              constrain('pattern',    value,        function (a, e) {
                e = typeof e === 'string'
                  ? e = new RegExp(e)
                  : e;
                return e.test(a)
              });
              break;
            case 'integer':
            case 'number':
              constrain('minimum',     value, function (a, e) { return a >= e });
              constrain('maximum',     value, function (a, e) { return a <= e });
              constrain('exclusiveMinimum', value, function (a, e) { return a > e });
              constrain('exclusiveMaximum', value, function (a, e) { return a < e });
              constrain('divisibleBy', value, function (a, e) {
                var multiplier = Math.max((a - Math.floor(a)).toString().length - 2, (e - Math.floor(e)).toString().length - 2);
                multiplier = multiplier > 0 ? Math.pow(10, multiplier) : 1;
                return (a * multiplier) % (e * multiplier) === 0
              });
              break;
            case 'array':
              constrain('items', value, function (a, e) {
                var nestedErrors;
                for (var i = 0, l = a.length; i < l; i++) {
                  nestedErrors = [];
                  validateProperty(object, a[i], property, e, options, nestedErrors);
                  nestedErrors.forEach(function (err) {
                    err.property =
                      (property ? property + '.' : '') +
                      i +
                      (err.property ? '.' + err.property.replace(property + '.', '') : '');
                  });
                  nestedErrors.unshift(0, 0);
                  Array.prototype.splice.apply(errors, nestedErrors);
                }
                return true;
              });
              constrain('minItems', value, function (a, e) { return a.length >= e });
              constrain('maxItems', value, function (a, e) { return a.length <= e });
              constrain('uniqueItems', value, function (a, e) {
                if (!e) return true;
    
                var h = {};
    
                for (var i = 0, l = a.length; i < l; i++) {
                  var key = JSON.stringify(a[i]);
                  if (h[key]) return false;
                  h[key] = true;
                }
    
                return true;
              });
              break;
            case 'object':
              // Recursive validation
              if (schema.properties || schema.patternProperties || schema.additionalProperties) {
                var nestedErrors = [];
                validateObject(value, schema, options, nestedErrors);
                nestedErrors.forEach(function (e) {
                  e.property = property + '.' + e.property
                });
                nestedErrors.unshift(0, 0);
                Array.prototype.splice.apply(errors, nestedErrors);
              }
              break;
          }
        });
      };
    
      function checkType(val, type, callback) {
        var result = false,
            types = isArray(type) ? type : [type];
    
        // No type - no check
        if (type === undefined) return callback(null, type);
    
        // Go through available types
        // And fine first matching
        for (var i = 0, l = types.length; i < l; i++) {
          type = types[i].toLowerCase().trim();
          if (type === 'string' ? typeof val === 'string' :
              type === 'array' ? isArray(val) :
              type === 'object' ? val && typeof val === 'object' &&
                                 !isArray(val) :
              type === 'number' ? typeof val === 'number' :
              type === 'integer' ? typeof val === 'number' && Math.floor(val) === val :
              type === 'null' ? val === null :
              type === 'boolean'? typeof val === 'boolean' :
              type === 'date' ? isDate(val) :
              type === 'any' ? typeof val !== 'undefined' : false) {
            return callback(null, type);
          }
        };
    
        callback(true);
      };
    
      function error(attribute, property, actual, schema, errors) {
        var lookup = { expected: schema[attribute], actual: actual, attribute: attribute, property: property };
        var message = schema.messages && schema.messages[attribute] || schema.message || validate.messages[attribute] || "no default message";
        message = message.replace(/%\{([a-z]+)\}/ig, function (_, match) { return lookup[match.toLowerCase()] || ''; });
        errors.push({
          attribute: attribute,
          property:  property,
          expected:  schema[attribute],
          actual:    actual,
          message:   message
        });
      };
    
      function isArray(value) {
        var s = typeof value;
        if (s === 'object') {
          if (value) {
            if (typeof value.length === 'number' &&
               !(value.propertyIsEnumerable('length')) &&
               typeof value.splice === 'function') {
               return true;
            }
          }
        }
        return false;
      }
    
      function isDate(value) {
        var s = typeof value;
        if (s === 'object') {
          if (value) {
            if (typeof value.getTime === 'function') {
              return true;
            }
          }
        }
    
        return false;
      }
    
    })(typeof module === 'object' && module && module.exports ? module.exports : window);
    
  provide("revalidator", module.exports);
}(global));

// pakmanager:utile/lib/file
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * file.js: Simple utilities for working with the file system.
     *
     * (C) 2011, Charlie Robbins & the Contributors
     * MIT LICENSE
     *
     */
    
    var fs = require('fs');
    
    exports.readJson = exports.readJSON = function (file, callback) {
      if (typeof callback !== 'function') {
        throw new Error('utile.file.readJson needs a callback');
      }
    
      fs.readFile(file, 'utf-8', function (err, data) {
        if (err) {
          return callback(err);
        }
    
        try {
          var json = JSON.parse(data);
          callback(null, json);
        }
        catch (err) {
          return callback(err);
        }
      });
    };
    
    exports.readJsonSync = exports.readJSONSync = function (file) {
      return JSON.parse(fs.readFileSync(file, 'utf-8'));
    };
    
  provide("utile/lib/file", module.exports);
}(global));

// pakmanager:utile/lib/base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * base64.js: An extremely simple implementation of base64 encoding / decoding using node.js Buffers
     *
     * (C) 2010, Charlie Robbins & the Contributors.
     *
     */
    
    var base64 = exports;
    
    //
    // ### function encode (unencoded)
    // #### @unencoded {string} The string to base64 encode
    // Encodes the specified string to base64 using node.js Buffers.
    //
    base64.encode = function (unencoded) {
      var encoded;
    
      try {
        encoded = new Buffer(unencoded || '').toString('base64');
      }
      catch (ex) {
        return null;
      }
    
      return encoded;
    };
    
    //
    // ### function decode (encoded)
    // #### @encoded {string} The string to base64 decode
    // Decodes the specified string from base64 using node.js Buffers.
    //
    base64.decode = function (encoded) {
      var decoded;
    
      try {
        decoded = new Buffer(encoded || '', 'base64').toString('utf8');
      }
      catch (ex) {
        return null;
      }
    
      return decoded;
    };
    
  provide("utile/lib/base64", module.exports);
}(global));

// pakmanager:utile/lib/format
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * format.js: `util.format` enhancement to allow custom formatting parameters.
     *
     * (C) 2011, Charlie Robbins & the Contributors
     * MIT LICENSE
     *
     */
    
    var util = require('util');
    
    exports = module.exports = function(str) {
      var formats = [].slice.call(arguments, 1, 3);
    
      if (!(formats[0] instanceof Array && formats[1] instanceof Array) || arguments.length > 3)
        return util.format.apply(null, arguments);
    
      var replacements = formats.pop(),
          formats = formats.shift();
    
      formats.forEach(function(format, id) {
        str = str.replace(new RegExp(format), replacements[id]);
      });
    
      return str;
    };
    
  provide("utile/lib/format", module.exports);
}(global));

// pakmanager:utile/lib/index
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * index.js: Top-level include for the `utile` module.
     *
     * (C) 2011, Charlie Robbins & the Contributors
     * MIT LICENSE
     *
     */
    
    var fs = require('fs'),
        path = require('path'),
        util = require('util');
    
    var utile = module.exports;
    
    //
    // Extend the `utile` object with all methods from the
    // core node `util` methods.
    //
    Object.keys(util).forEach(function (key) {
      utile[key] = util[key];
    });
    
    Object.defineProperties(utile, {
    
      //
      // ### function async
      // Simple wrapper to `require('async')`.
      //
      'async': {
        get: function() {
          return utile.async = require('async');
        }
      },
    
      //
      // ### function inflect
      // Simple wrapper to `require('i')`.
      //
      'inflect': {
        get: function() {
          return utile.inflect = require('i')();
        }
      },
    
      //
      // ### function mkdirp
      // Simple wrapper to `require('mkdirp')`
      //
      'mkdirp': {
        get: function() {
          return utile.mkdirp = require('mkdirp');
        }
      },
    
      //
      // ### function deepEqual
      // Simple wrapper to `require('deep-equal')`
      // Remark: deepEqual is 4x faster then using assert.deepEqual
      //         see: https://gist.github.com/2790507
      //
      'deepEqual': {
        get: function() {
          return utile.deepEqual = require('deep-equal');
        }
      },
    
      //
      // ### function rimraf
      // Simple wrapper to `require('rimraf')`
      //
      'rimraf': {
        get: function() {
          return utile.rimraf = require('rimraf');
        }
      },
    
      //
      // ### function cpr
      // Simple wrapper to `require('ncp').ncp`
      //
      'cpr': {
        get: function() {
          return utile.cpr = require('ncp').ncp;
        }
      },
    
      //
      // ### @file {Object}
      // Lazy-loaded `file` module
      //
      'file': {
        get: function() {
          return utile.file =  require('utile/lib/file');
        }
      },
    
      //
      // ### @args {Object}
      // Lazy-loaded `args` module
      //
      'args': {
        get: function() {
          return utile.args =  require('utile/lib/args');
        }
      },
    
      //
      // ### @base64 {Object}
      // Lazy-loaded `base64` object
      //
      'base64': {
        get: function() {
          return utile.base64 =  require('utile/lib/base64');
        }
      },
    
      //
      // ### @format {Object}
      // Lazy-loaded `format` object
      //
      'format': {
        get: function() {
          return utile.format =  require('utile/lib/format');
        }
      }
    
    });
    
    
    //
    // ### function rargs(_args)
    // #### _args {Arguments} Original function arguments
    //
    // Top-level method will accept a javascript "arguments" object
    // (the actual keyword "arguments" inside any scope) and return
    // back an Array.
    //
    utile.rargs = function (_args, slice) {
      if (!slice) {
        slice = 0;
      }
    
      var len = (_args || []).length,
          args = new Array(len - slice),
          i;
    
      //
      // Convert the raw `_args` to a proper Array.
      //
      for (i = slice; i < len; i++) {
        args[i - slice] = _args[i];
      }
    
      return args;
    };
    
    //
    // ### function each (obj, iterator)
    // #### @obj {Object} Object to iterate over
    // #### @iterator {function} Continuation to use on each key. `function (value, key, object)`
    // Iterate over the keys of an object.
    //
    utile.each = function (obj, iterator) {
      Object.keys(obj).forEach(function (key) {
        iterator(obj[key], key, obj);
      });
    };
    
    //
    // ### function find (o)
    //
    //
    utile.find = function (obj, pred) {
      var value, key;
    
      for (key in obj) {
        value = obj[key];
        if (pred(value, key)) {
          return value;
        }
      }
    };
    
    //
    // ### function pad (str, len, chr)
    // ### @str {String} String to pad
    // ### @len {Number} Number of chars to pad str with
    // ### @chr {String} Optional replacement character, defaults to empty space
    // Appends chr to str until it reaches a length of len
    //
    utile.pad = function pad(str, len, chr) {
      var s;
      if (!chr) {
        chr = ' ';
      }
      str = str || '';
      s = str;
      if (str.length < len) {
        for (var i = 0; i < (len - str.length); i++) {
          s += chr;
        }
      }
      return s;
    }
    
    //
    // ### function path (obj, path, value)
    // ### @obj {Object} Object to insert value into
    // ### @path {Array} List of nested keys to insert value at
    // Retreives a value from given Object, `obj`, located at the
    // nested keys, `path`.
    //
    utile.path = function (obj, path) {
      var key, i;
    
      for (i in path) {
        if (typeof obj === 'undefined') {
          return undefined;
        }
    
        key = path[i];
        obj = obj[key];
      }
    
      return obj;
    };
    
    //
    // ### function createPath (obj, path, value)
    // ### @obj {Object} Object to insert value into
    // ### @path {Array} List of nested keys to insert value at
    // ### @value {*} Value to insert into the object.
    // Inserts the `value` into the given Object, `obj`, creating
    // any keys in `path` along the way if necessary.
    //
    utile.createPath = function (obj, path, value) {
      var key, i;
    
      for (i in path) {
        key = path[i];
        if (!obj[key]) {
          obj[key] = ((+i + 1 === path.length) ? value : {});
        }
    
        obj = obj[key];
      }
    };
    
    //
    // ### function mixin (target [source0, source1, ...])
    // Copies enumerable properties from `source0 ... sourceN`
    // onto `target` and returns the resulting object.
    //
    utile.mixin = function (target) {
      utile.rargs(arguments, 1).forEach(function (o) {
        Object.getOwnPropertyNames(o).forEach(function(attr) {
          var getter = Object.getOwnPropertyDescriptor(o, attr).get,
              setter = Object.getOwnPropertyDescriptor(o, attr).set;
    
          if (!getter && !setter) {
            target[attr] = o[attr];
          }
          else {
            Object.defineProperty(target, attr, {
              get: getter,
              set: setter
            });
          }
        });
      });
    
      return target;
    };
    
    
    //
    // ### function capitalize (str)
    // #### @str {string} String to capitalize
    // Capitalizes the specified `str`.
    //
    utile.capitalize = utile.inflect.camelize;
    
    //
    // ### function escapeRegExp (str)
    // #### @str {string} String to be escaped
    // Escape string for use in Javascript regex
    //
    utile.escapeRegExp = function (str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    };
    
    //
    // ### function randomString (length)
    // #### @length {integer} The number of bits for the random base64 string returned to contain
    // randomString returns a pseude-random ASCII string (subset)
    // the return value is a string of length bits/6 of characters
    // from the base64 alphabet.
    //
    utile.randomString = function (length) {
      var chars, rand, i, ret, mod, bits;
    
      chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      ret = '';
      // standard 4
      mod = 4;
      // default is 16
      bits = length * mod || 64;
    
      // in v8, Math.random() yields 32 pseudo-random bits (in spidermonkey it gives 53)
      while (bits > 0) {
        // 32-bit integer
        rand = Math.floor(Math.random() * 0x100000000);
        //we use the top bits
        for (i = 26; i > 0 && bits > 0; i -= mod, bits -= mod) {
          ret += chars[0x3F & rand >>> i];
        }
      }
    
      return ret;
    };
    
    //
    // ### function filter (object, test)
    // #### @obj {Object} Object to iterate over
    // #### @pred {function} Predicate applied to each property. `function (value, key, object)`
    // Returns an object with properties from `obj` which satisfy
    // the predicate `pred`
    //
    utile.filter = function (obj, pred) {
      var copy;
      if (Array.isArray(obj)) {
        copy = [];
        utile.each(obj, function (val, key) {
          if (pred(val, key, obj)) {
            copy.push(val);
          }
        });
      }
      else {
        copy = {};
        utile.each(obj, function (val, key) {
          if (pred(val, key, obj)) {
            copy[key] = val;
          }
        });
      }
      return copy;
    };
    
    //
    // ### function requireDir (directory)
    // #### @directory {string} Directory to require
    // Requires all files and directories from `directory`, returning an object
    // with keys being filenames (without trailing `.js`) and respective values
    // being return values of `require(filename)`.
    //
    utile.requireDir = function (directory) {
      var result = {},
          files = fs.readdirSync(directory);
    
      files.forEach(function (file) {
        if (file.substr(-3) === '.js') {
          file = file.substr(0, file.length - 3);
        }
        result[file] = require(path.resolve(directory, file));
      });
      return result;
    };
    
    //
    // ### function requireDirLazy (directory)
    // #### @directory {string} Directory to require
    // Lazily requires all files and directories from `directory`, returning an
    // object with keys being filenames (without trailing `.js`) and respective
    // values (getters) being return values of `require(filename)`.
    //
    utile.requireDirLazy = function (directory) {
      var result = {},
          files = fs.readdirSync(directory);
    
      files.forEach(function (file) {
        if (file.substr(-3) === '.js') {
          file = file.substr(0, file.length - 3);
        }
        Object.defineProperty(result, file, {
          get: function() {
            return result[file] = require(path.resolve(directory, file));
          }
        });
      });
    
      return result;
    };
    
    //
    // ### function clone (object, filter)
    // #### @object {Object} Object to clone
    // #### @filter {Function} Filter to be used
    // Shallow clones the specified object.
    //
    utile.clone = function (object, filter) {
      return Object.keys(object).reduce(filter ? function (obj, k) {
        if (filter(k)) obj[k] = object[k];
        return obj;
      } : function (obj, k) {
        obj[k] = object[k];
        return obj;
      }, {});
    };
    
    //
    // ### function camelToUnderscore (obj)
    // #### @obj {Object} Object to convert keys on.
    // Converts all keys of the type `keyName` to `key_name` on the
    // specified `obj`.
    //
    utile.camelToUnderscore = function (obj) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
    
      if (Array.isArray(obj)) {
        obj.forEach(utile.camelToUnderscore);
        return obj;
      }
    
      Object.keys(obj).forEach(function (key) {
        var k = utile.inflect.underscore(key);
        if (k !== key) {
          obj[k] = obj[key];
          delete obj[key];
          key = k;
        }
        utile.camelToUnderscore(obj[key]);
      });
    
      return obj;
    };
    
    //
    // ### function underscoreToCamel (obj)
    // #### @obj {Object} Object to convert keys on.
    // Converts all keys of the type `key_name` to `keyName` on the
    // specified `obj`.
    //
    utile.underscoreToCamel = function (obj) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
    
      if (Array.isArray(obj)) {
        obj.forEach(utile.underscoreToCamel);
        return obj;
      }
    
      Object.keys(obj).forEach(function (key) {
        var k = utile.inflect.camelize(key, false);
        if (k !== key) {
          obj[k] = obj[key];
          delete obj[key];
          key = k;
        }
        utile.underscoreToCamel(obj[key]);
      });
    
      return obj;
    };
    
  provide("utile/lib/index", module.exports);
}(global));

// pakmanager:utile/lib/args
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * args.js: function argument parsing helper utility
     *
     * (C) 2011, Charlie Robbins & the Contributors
     * MIT LICENSE
     *
     */
    
    var utile =  require('utile/lib/index');
    
    //
    // ### function args(_args)
    // #### _args {Arguments} Original function arguments
    //
    // Top-level method will accept a javascript "arguments" object (the actual keyword
    // "arguments" inside any scope), and attempt to return back an intelligent object
    // representing the functions arguments
    //
    module.exports = function (_args) {
      var args = utile.rargs(_args),
          _cb;
    
      //
      // Find and define the first argument
      //
      Object.defineProperty(args, 'first', { value: args[0] });
    
      //
      // Find and define any callback
      //
      _cb = args[args.length - 1] || args[args.length];
      if (typeof _cb === "function") {
        Object.defineProperty(args, 'callback', { value: _cb });
        Object.defineProperty(args, 'cb', { value: _cb });
        args.pop();
      }
    
      //
      // Find and define the last argument
      //
      if (args.length) {
        Object.defineProperty(args, 'last', { value: args[args.length - 1] });
      }
    
      return args;
    };
    
  provide("utile/lib/args", module.exports);
}(global));

// pakmanager:utile
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * index.js: Top-level include for the `utile` module.
     *
     * (C) 2011, Charlie Robbins & the Contributors
     * MIT LICENSE
     *
     */
    
    var fs = require('fs'),
        path = require('path'),
        util = require('util');
    
    var utile = module.exports;
    
    //
    // Extend the `utile` object with all methods from the
    // core node `util` methods.
    //
    Object.keys(util).forEach(function (key) {
      utile[key] = util[key];
    });
    
    Object.defineProperties(utile, {
    
      //
      // ### function async
      // Simple wrapper to `require('async')`.
      //
      'async': {
        get: function() {
          return utile.async = require('async');
        }
      },
    
      //
      // ### function inflect
      // Simple wrapper to `require('i')`.
      //
      'inflect': {
        get: function() {
          return utile.inflect = require('i')();
        }
      },
    
      //
      // ### function mkdirp
      // Simple wrapper to `require('mkdirp')`
      //
      'mkdirp': {
        get: function() {
          return utile.mkdirp = require('mkdirp');
        }
      },
    
      //
      // ### function deepEqual
      // Simple wrapper to `require('deep-equal')`
      // Remark: deepEqual is 4x faster then using assert.deepEqual
      //         see: https://gist.github.com/2790507
      //
      'deepEqual': {
        get: function() {
          return utile.deepEqual = require('deep-equal');
        }
      },
    
      //
      // ### function rimraf
      // Simple wrapper to `require('rimraf')`
      //
      'rimraf': {
        get: function() {
          return utile.rimraf = require('rimraf');
        }
      },
    
      //
      // ### function cpr
      // Simple wrapper to `require('ncp').ncp`
      //
      'cpr': {
        get: function() {
          return utile.cpr = require('ncp').ncp;
        }
      },
    
      //
      // ### @file {Object}
      // Lazy-loaded `file` module
      //
      'file': {
        get: function() {
          return utile.file =  require('utile/lib/file');
        }
      },
    
      //
      // ### @args {Object}
      // Lazy-loaded `args` module
      //
      'args': {
        get: function() {
          return utile.args =  require('utile/lib/args');
        }
      },
    
      //
      // ### @base64 {Object}
      // Lazy-loaded `base64` object
      //
      'base64': {
        get: function() {
          return utile.base64 =  require('utile/lib/base64');
        }
      },
    
      //
      // ### @format {Object}
      // Lazy-loaded `format` object
      //
      'format': {
        get: function() {
          return utile.format =  require('utile/lib/format');
        }
      }
    
    });
    
    
    //
    // ### function rargs(_args)
    // #### _args {Arguments} Original function arguments
    //
    // Top-level method will accept a javascript "arguments" object
    // (the actual keyword "arguments" inside any scope) and return
    // back an Array.
    //
    utile.rargs = function (_args, slice) {
      if (!slice) {
        slice = 0;
      }
    
      var len = (_args || []).length,
          args = new Array(len - slice),
          i;
    
      //
      // Convert the raw `_args` to a proper Array.
      //
      for (i = slice; i < len; i++) {
        args[i - slice] = _args[i];
      }
    
      return args;
    };
    
    //
    // ### function each (obj, iterator)
    // #### @obj {Object} Object to iterate over
    // #### @iterator {function} Continuation to use on each key. `function (value, key, object)`
    // Iterate over the keys of an object.
    //
    utile.each = function (obj, iterator) {
      Object.keys(obj).forEach(function (key) {
        iterator(obj[key], key, obj);
      });
    };
    
    //
    // ### function find (o)
    //
    //
    utile.find = function (obj, pred) {
      var value, key;
    
      for (key in obj) {
        value = obj[key];
        if (pred(value, key)) {
          return value;
        }
      }
    };
    
    //
    // ### function pad (str, len, chr)
    // ### @str {String} String to pad
    // ### @len {Number} Number of chars to pad str with
    // ### @chr {String} Optional replacement character, defaults to empty space
    // Appends chr to str until it reaches a length of len
    //
    utile.pad = function pad(str, len, chr) {
      var s;
      if (!chr) {
        chr = ' ';
      }
      str = str || '';
      s = str;
      if (str.length < len) {
        for (var i = 0; i < (len - str.length); i++) {
          s += chr;
        }
      }
      return s;
    }
    
    //
    // ### function path (obj, path, value)
    // ### @obj {Object} Object to insert value into
    // ### @path {Array} List of nested keys to insert value at
    // Retreives a value from given Object, `obj`, located at the
    // nested keys, `path`.
    //
    utile.path = function (obj, path) {
      var key, i;
    
      for (i in path) {
        if (typeof obj === 'undefined') {
          return undefined;
        }
    
        key = path[i];
        obj = obj[key];
      }
    
      return obj;
    };
    
    //
    // ### function createPath (obj, path, value)
    // ### @obj {Object} Object to insert value into
    // ### @path {Array} List of nested keys to insert value at
    // ### @value {*} Value to insert into the object.
    // Inserts the `value` into the given Object, `obj`, creating
    // any keys in `path` along the way if necessary.
    //
    utile.createPath = function (obj, path, value) {
      var key, i;
    
      for (i in path) {
        key = path[i];
        if (!obj[key]) {
          obj[key] = ((+i + 1 === path.length) ? value : {});
        }
    
        obj = obj[key];
      }
    };
    
    //
    // ### function mixin (target [source0, source1, ...])
    // Copies enumerable properties from `source0 ... sourceN`
    // onto `target` and returns the resulting object.
    //
    utile.mixin = function (target) {
      utile.rargs(arguments, 1).forEach(function (o) {
        Object.getOwnPropertyNames(o).forEach(function(attr) {
          var getter = Object.getOwnPropertyDescriptor(o, attr).get,
              setter = Object.getOwnPropertyDescriptor(o, attr).set;
    
          if (!getter && !setter) {
            target[attr] = o[attr];
          }
          else {
            Object.defineProperty(target, attr, {
              get: getter,
              set: setter
            });
          }
        });
      });
    
      return target;
    };
    
    
    //
    // ### function capitalize (str)
    // #### @str {string} String to capitalize
    // Capitalizes the specified `str`.
    //
    utile.capitalize = utile.inflect.camelize;
    
    //
    // ### function escapeRegExp (str)
    // #### @str {string} String to be escaped
    // Escape string for use in Javascript regex
    //
    utile.escapeRegExp = function (str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    };
    
    //
    // ### function randomString (length)
    // #### @length {integer} The number of bits for the random base64 string returned to contain
    // randomString returns a pseude-random ASCII string (subset)
    // the return value is a string of length bits/6 of characters
    // from the base64 alphabet.
    //
    utile.randomString = function (length) {
      var chars, rand, i, ret, mod, bits;
    
      chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';
      ret = '';
      // standard 4
      mod = 4;
      // default is 16
      bits = length * mod || 64;
    
      // in v8, Math.random() yields 32 pseudo-random bits (in spidermonkey it gives 53)
      while (bits > 0) {
        // 32-bit integer
        rand = Math.floor(Math.random() * 0x100000000);
        //we use the top bits
        for (i = 26; i > 0 && bits > 0; i -= mod, bits -= mod) {
          ret += chars[0x3F & rand >>> i];
        }
      }
    
      return ret;
    };
    
    //
    // ### function filter (object, test)
    // #### @obj {Object} Object to iterate over
    // #### @pred {function} Predicate applied to each property. `function (value, key, object)`
    // Returns an object with properties from `obj` which satisfy
    // the predicate `pred`
    //
    utile.filter = function (obj, pred) {
      var copy;
      if (Array.isArray(obj)) {
        copy = [];
        utile.each(obj, function (val, key) {
          if (pred(val, key, obj)) {
            copy.push(val);
          }
        });
      }
      else {
        copy = {};
        utile.each(obj, function (val, key) {
          if (pred(val, key, obj)) {
            copy[key] = val;
          }
        });
      }
      return copy;
    };
    
    //
    // ### function requireDir (directory)
    // #### @directory {string} Directory to require
    // Requires all files and directories from `directory`, returning an object
    // with keys being filenames (without trailing `.js`) and respective values
    // being return values of `require(filename)`.
    //
    utile.requireDir = function (directory) {
      var result = {},
          files = fs.readdirSync(directory);
    
      files.forEach(function (file) {
        if (file.substr(-3) === '.js') {
          file = file.substr(0, file.length - 3);
        }
        result[file] = require(path.resolve(directory, file));
      });
      return result;
    };
    
    //
    // ### function requireDirLazy (directory)
    // #### @directory {string} Directory to require
    // Lazily requires all files and directories from `directory`, returning an
    // object with keys being filenames (without trailing `.js`) and respective
    // values (getters) being return values of `require(filename)`.
    //
    utile.requireDirLazy = function (directory) {
      var result = {},
          files = fs.readdirSync(directory);
    
      files.forEach(function (file) {
        if (file.substr(-3) === '.js') {
          file = file.substr(0, file.length - 3);
        }
        Object.defineProperty(result, file, {
          get: function() {
            return result[file] = require(path.resolve(directory, file));
          }
        });
      });
    
      return result;
    };
    
    //
    // ### function clone (object, filter)
    // #### @object {Object} Object to clone
    // #### @filter {Function} Filter to be used
    // Shallow clones the specified object.
    //
    utile.clone = function (object, filter) {
      return Object.keys(object).reduce(filter ? function (obj, k) {
        if (filter(k)) obj[k] = object[k];
        return obj;
      } : function (obj, k) {
        obj[k] = object[k];
        return obj;
      }, {});
    };
    
    //
    // ### function camelToUnderscore (obj)
    // #### @obj {Object} Object to convert keys on.
    // Converts all keys of the type `keyName` to `key_name` on the
    // specified `obj`.
    //
    utile.camelToUnderscore = function (obj) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
    
      if (Array.isArray(obj)) {
        obj.forEach(utile.camelToUnderscore);
        return obj;
      }
    
      Object.keys(obj).forEach(function (key) {
        var k = utile.inflect.underscore(key);
        if (k !== key) {
          obj[k] = obj[key];
          delete obj[key];
          key = k;
        }
        utile.camelToUnderscore(obj[key]);
      });
    
      return obj;
    };
    
    //
    // ### function underscoreToCamel (obj)
    // #### @obj {Object} Object to convert keys on.
    // Converts all keys of the type `key_name` to `keyName` on the
    // specified `obj`.
    //
    utile.underscoreToCamel = function (obj) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
    
      if (Array.isArray(obj)) {
        obj.forEach(utile.underscoreToCamel);
        return obj;
      }
    
      Object.keys(obj).forEach(function (key) {
        var k = utile.inflect.camelize(key, false);
        if (k !== key) {
          obj[k] = obj[key];
          delete obj[key];
          key = k;
        }
        utile.underscoreToCamel(obj[key]);
      });
    
      return obj;
    };
    
  provide("utile", module.exports);
}(global));

// pakmanager:winston/lib/winston/config/cli-config
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * cli-config.js: Config that conform to commonly used CLI logging levels.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var cliConfig = exports;
    
    cliConfig.levels = {
      silly: 0,
      input: 1,
      verbose: 2,
      prompt: 3,
      debug: 4,
      info: 5,
      data: 6,
      help: 7,
      warn: 8,
      error: 9
    };
    
    cliConfig.colors = {
      silly: 'magenta',
      input: 'grey',
      verbose: 'cyan',
      prompt: 'grey',
      debug: 'blue',
      info: 'green',
      data: 'grey',
      help: 'cyan',
      warn: 'yellow',
      error: 'red'
    };
  provide("winston/lib/winston/config/cli-config", module.exports);
}(global));

// pakmanager:winston/lib/winston/config/npm-config
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * npm-config.js: Config that conform to npm logging levels.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var npmConfig = exports;
    
    npmConfig.levels = {
      silly: 0,
      debug: 1,
      verbose: 2,
      info: 3,
      warn: 4,
      error: 5
    };
    
    npmConfig.colors = {
      silly: 'magenta',
      verbose: 'cyan',
      debug: 'blue',
      info: 'green',
      warn: 'yellow',
      error: 'red'
    };
  provide("winston/lib/winston/config/npm-config", module.exports);
}(global));

// pakmanager:winston/lib/winston/config/syslog-config
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * syslog-config.js: Config that conform to syslog logging levels.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var syslogConfig = exports;
    
    syslogConfig.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7,
    };
    
    syslogConfig.colors = {
      emerg: 'red',
      alert: 'yellow',
      crit: 'red',
      error: 'red',
      warning: 'red',
      notice: 'yellow',
      info: 'green',
      debug: 'blue',
    };
  provide("winston/lib/winston/config/syslog-config", module.exports);
}(global));

// pakmanager:winston/lib/winston/config
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * config.js: Default settings for all levels that winston knows about
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var colors = require('colors/safe');
    
    var config = exports,
        allColors = exports.allColors = {};
    
    config.addColors = function (colors) {
      mixin(allColors, colors);
    };
    
    config.colorize = function (level, message) {
      if (typeof message === 'undefined') message = level;
    
      var colorized = message;
      if (allColors[level] instanceof Array) {
        for (var i = 0, l = allColors[level].length; i < l; ++i) {
          colorized = colors[allColors[level][i]](colorized);
        }
      } else if (allColors[level].match(/\s/)) {
        var colorArr = allColors[level].split(/\s+/);
        for (var i = 0; i < colorArr.length; ++i) {
          colorized = colors[colorArr[i]](colorized);
        }
        allColors[level] = colorArr;
      } else {
        colorized = colors[allColors[level]](colorized);
      }
      return colorized;
    };
    
    //
    // Export config sets
    //
    config.cli    =  require('winston/lib/winston/config/cli-config');
    config.npm    =  require('winston/lib/winston/config/npm-config');
    config.syslog =  require('winston/lib/winston/config/syslog-config');
    
    //
    // Add colors for pre-defined config sets
    //
    config.addColors(config.cli.colors);
    config.addColors(config.npm.colors);
    config.addColors(config.syslog.colors);
    
    function mixin (target) {
      var args = Array.prototype.slice.call(arguments, 1);
    
      args.forEach(function (a) {
        var keys = Object.keys(a);
        for (var i = 0; i < keys.length; i++) {
          target[keys[i]] = a[keys[i]];
        }
      });
      return target;
    };
    
  provide("winston/lib/winston/config", module.exports);
}(global));

// pakmanager:winston/lib/winston/common
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * common.js: Internal helper and utility functions for winston
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var util = require('util'),
        crypto = require('crypto'),
        cycle = require('cycle'),
        fs = require('fs'),
        config =  require('winston/lib/winston/config');
    
    //
    // ### function setLevels (target, past, current)
    // #### @target {Object} Object on which to set levels.
    // #### @past {Object} Previous levels set on target.
    // #### @current {Object} Current levels to set on target.
    // Create functions on the target objects for each level
    // in current.levels. If past is defined, remove functions
    // for each of those levels.
    //
    exports.setLevels = function (target, past, current, isDefault) {
      var self = this;
      if (past) {
        Object.keys(past).forEach(function (level) {
          delete target[level];
        });
      }
    
      target.levels = current || config.npm.levels;
      if (target.padLevels) {
        target.levelLength = exports.longestElement(Object.keys(target.levels));
      }
    
      //
      //  Define prototype methods for each log level
      //  e.g. target.log('info', msg) <=> target.info(msg)
      //
      Object.keys(target.levels).forEach(function (level) {
    
        // TODO Refactor logging methods into a different object to avoid name clashes
        if (level === 'log') {
          console.warn('Log level named "log" will clash with the method "log". Consider using a different name.');
          return;
        }
    
        target[level] = function (msg) {
          // build argument list (level, msg, ... [string interpolate], [{metadata}], [callback])
          var args = [level].concat(Array.prototype.slice.call(arguments));
          target.log.apply(target, args);
        };
      });
    
      return target;
    };
    
    //
    // ### function longestElement
    // #### @xs {Array} Array to calculate against
    // Returns the longest element in the `xs` array.
    //
    exports.longestElement = function (xs) {
      return Math.max.apply(
        null,
        xs.map(function (x) { return x.length; })
      );
    };
    
    //
    // ### function clone (obj)
    // #### @obj {Object} Object to clone.
    // Helper method for deep cloning pure JSON objects
    // i.e. JSON objects that are either literals or objects (no Arrays, etc)
    //
    exports.clone = function (obj) {
      //
      // We only need to clone reference types (Object)
      //
      if (obj instanceof Error) {
        return obj;
      }
      else if (!(obj instanceof Object)) {
        return obj;
      }
      else if (obj instanceof Date) {
        return obj;
      }
    
      var copy = {};
      for (var i in obj) {
        if (Array.isArray(obj[i])) {
          copy[i] = obj[i].slice(0);
        }
        else if (obj[i] instanceof Buffer) {
            copy[i] = obj[i].slice(0);
        }
        else if (typeof obj[i] != 'function') {
          copy[i] = obj[i] instanceof Object ? exports.clone(obj[i]) : obj[i];
        }
        else if (typeof obj[i] === 'function') {
          copy[i] = obj[i];
        }
      }
    
      return copy;
    };
    
    //
    // ### function log (options)
    // #### @options {Object} All information about the log serialization.
    // Generic logging function for returning timestamped strings
    // with the following options:
    //
    //    {
    //      level:     'level to add to serialized message',
    //      message:   'message to serialize',
    //      meta:      'additional logging metadata to serialize',
    //      colorize:  false, // Colorizes output (only if `.json` is false)
    //      timestamp: true   // Adds a timestamp to the serialized message
    //      label:     'label to prepend the message'
    //    }
    //
    exports.log = function (options) {
      var timestampFn = typeof options.timestamp === 'function'
            ? options.timestamp
            : exports.timestamp,
          timestamp   = options.timestamp ? timestampFn() : null,
          showLevel   = options.showLevel === undefined ? true : options.showLevel,
          meta        = options.meta !== null && options.meta !== undefined && !(options.meta instanceof Error)
            ? exports.clone(cycle.decycle(options.meta))
            : options.meta || null,
          output;
    
      //
      // raw mode is intended for outputing winston as streaming JSON to STDOUT
      //
      if (options.raw) {
        if (typeof meta !== 'object' && meta != null) {
          meta = { meta: meta };
        }
        output         = exports.clone(meta) || {};
        output.level   = options.level;
        output.message = options.message.stripColors;
        return JSON.stringify(output);
      }
    
      //
      // json mode is intended for pretty printing multi-line json to the terminal
      //
      if (options.json || true === options.logstash) {
        if (typeof meta !== 'object' && meta != null) {
          meta = { meta: meta };
        }
    
        output         = exports.clone(meta) || {};
        output.level   = options.level;
        output.message = output.message || '';
    
        if (options.label) { output.label = options.label; }
        if (options.message) { output.message = options.message; }
        if (timestamp) { output.timestamp = timestamp; }
    
        if (options.logstash === true) {
          // use logstash format
          var logstashOutput = {};
          if (output.message !== undefined) {
            logstashOutput['@message'] = output.message;
            delete output.message;
          }
    
          if (output.timestamp !== undefined) {
            logstashOutput['@timestamp'] = output.timestamp;
            delete output.timestamp;
          }
    
          logstashOutput['@fields'] = exports.clone(output);
          output = logstashOutput;
        }
    
        if (typeof options.stringify === 'function') {
          return options.stringify(output);
        }
    
        return JSON.stringify(output, function (key, value) {
          return value instanceof Buffer
            ? value.toString('base64')
            : value;
        });
      }
    
      //
      // Remark: this should really be a call to `util.format`.
      //
      if (typeof options.formatter == 'function') {
        return String(options.formatter(exports.clone(options)));
      }
    
      output = timestamp ? timestamp + ' - ' : '';
      if (showLevel) {
        output += options.colorize === 'all' || options.colorize === 'level' || options.colorize === true
          ? config.colorize(options.level)
          : options.level;
      }
    
      output += (timestamp || showLevel) ? ': ' : '';
      output += options.label ? ('[' + options.label + '] ') : '';
      output += options.colorize === 'all' || options.colorize === 'message'
        ? config.colorize(options.level, options.message)
        : options.message;
    
      if (meta !== null && meta !== undefined) {
        if (meta && meta instanceof Error && meta.stack) {
          meta = meta.stack;
        }
    
        if (typeof meta !== 'object') {
          output += ' ' + meta;
        }
        else if (Object.keys(meta).length > 0) {
          if (typeof options.prettyPrint === 'function') {
            output += ' ' + options.prettyPrint(meta);
          } else if (options.prettyPrint) {
            output += ' ' + '\n' + util.inspect(meta, false, options.depth || null, options.colorize);
          } else if (
            options.humanReadableUnhandledException
              && Object.keys(meta).length === 5
              && meta.hasOwnProperty('date')
              && meta.hasOwnProperty('process')
              && meta.hasOwnProperty('os')
              && meta.hasOwnProperty('trace')
              && meta.hasOwnProperty('stack')) {
    
            //
            // If meta carries unhandled exception data serialize the stack nicely
            //
            var stack = meta.stack;
            delete meta.stack;
            delete meta.trace;
            output += ' ' + exports.serialize(meta);
            output += '\n' + stack.join('\n');
          } else {
            output += ' ' + exports.serialize(meta);
          }
        }
      }
    
      return output;
    };
    
    exports.capitalize = function (str) {
      return str && str[0].toUpperCase() + str.slice(1);
    };
    
    //
    // ### function hash (str)
    // #### @str {string} String to hash.
    // Utility function for creating unique ids
    // e.g. Profiling incoming HTTP requests on the same tick
    //
    exports.hash = function (str) {
      return crypto.createHash('sha1').update(str).digest('hex');
    };
    
    //
    // ### function pad (n)
    // Returns a padded string if `n < 10`.
    //
    exports.pad = function (n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    };
    
    //
    // ### function timestamp ()
    // Returns a timestamp string for the current time.
    //
    exports.timestamp = function () {
      return new Date().toISOString();
    };
    
    //
    // ### function serialize (obj, key)
    // #### @obj {Object|literal} Object to serialize
    // #### @key {string} **Optional** Optional key represented by obj in a larger object
    // Performs simple comma-separated, `key=value` serialization for Loggly when
    // logging to non-JSON inputs.
    //
    exports.serialize = function (obj, key) {
      if (obj === null) {
        obj = 'null';
      }
      else if (obj === undefined) {
        obj = 'undefined';
      }
      else if (obj === false) {
        obj = 'false';
      }
    
      if (typeof obj !== 'object') {
        return key ? key + '=' + obj : obj;
      }
    
      if (obj instanceof Buffer) {
        return key ? key + '=' + obj.toString('base64') : obj.toString('base64');
      }
    
      var msg = '',
          keys = Object.keys(obj),
          length = keys.length;
    
      for (var i = 0; i < length; i++) {
        if (Array.isArray(obj[keys[i]])) {
          msg += keys[i] + '=[';
    
          for (var j = 0, l = obj[keys[i]].length; j < l; j++) {
            msg += exports.serialize(obj[keys[i]][j]);
            if (j < l - 1) {
              msg += ', ';
            }
          }
    
          msg += ']';
        }
        else if (obj[keys[i]] instanceof Date) {
          msg += keys[i] + '=' + obj[keys[i]];
        }
        else {
          msg += exports.serialize(obj[keys[i]], keys[i]);
        }
    
        if (i < length - 1) {
          msg += ', ';
        }
      }
    
      return msg;
    };
    
    
    //
    // ### function tailFile (options, callback)
    // #### @options {Object} Options for tail.
    // #### @callback {function} Callback to execute on every line.
    // `tail -f` a file. Options must include file.
    //
    exports.tailFile = function tail(options, callback) {
      var stream = fs.createReadStream(options.file, { encoding: 'utf8' }),
          buff = '',
          destroy,
          row = 0;
    
      destroy = stream.destroy.bind(stream);
      stream.destroy = function () {};
    
      if (options.start === -1) {
        delete options.start;
      }
    
      stream.on('data', function (data) {
        var data = (buff + data).split(/\n+/),
            l = data.length - 1,
            i = 0;
    
        for (; i < l; i++) {
          if (options.start == null || row > options.start) {
            callback(null, data[i]);
          }
          row++;
        }
    
        buff = data[l];
      });
    
      stream.on('error', function (err) {
        callback(err);
        destroy();
      });
    
      stream.on('end', function () {
        if (buff) {
          stream.emit('line', buff);
          buff = '';
        }
    
        resume();
      });
    
      function resume() {
        setTimeout(function () {
          stream.resume();
        }, 1000);
      }
    
      return destroy;
    };
    
  provide("winston/lib/winston/common", module.exports);
}(global));

// pakmanager:winston/lib/winston/exception
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * exception.js: Utility methods for gathing information about uncaughtExceptions.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var os = require('os'),
        stackTrace = require('stack-trace');
    
    var exception = exports;
    
    exception.getAllInfo = function (err) {
      return {
        date:    new Date().toString(),
        process: exception.getProcessInfo(),
        os:      exception.getOsInfo(),
        trace:   exception.getTrace(err),
        stack:   err.stack && err.stack.split('\n')
      };
    };
    
    exception.getProcessInfo = function () {
      return {
        pid:         process.pid,
        uid:         process.getuid ? process.getuid() : null,
        gid:         process.getgid ? process.getgid() : null,
        cwd:         process.cwd(),
        execPath:    process.execPath,
        version:     process.version,
        argv:        process.argv,
        memoryUsage: process.memoryUsage()
      };
    };
    
    exception.getOsInfo = function () {
      return {
        loadavg: os.loadavg(),
        uptime:  os.uptime()
      };
    };
    
    exception.getTrace = function (err) {
      var trace = err ? stackTrace.parse(err) : stackTrace.get();
      return trace.map(function (site) {
        return {
          column:   site.getColumnNumber(),
          file:     site.getFileName(),
          function: site.getFunctionName(),
          line:     site.getLineNumber(),
          method:   site.getMethodName(),
          native:   site.isNative(),
        }
      });
    };
    
  provide("winston/lib/winston/exception", module.exports);
}(global));

// pakmanager:winston/lib/winston/transports
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * transports.js: Set of all transports Winston knows about
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var fs = require('fs'),
        path = require('path'),
        common =  require('winston/lib/winston/common');
    
    var transports = exports;
    
    //
    // Setup all transports as lazy-loaded getters.
    //
    fs.readdirSync(path.join(__dirname, 'transports')).forEach(function (file) {
      var transport = file.replace('.js', ''),
          name  = common.capitalize(transport);
    
      if (transport === 'transport') {
        return;
      }
      else if (~transport.indexOf('-')) {
        name = transport.split('-').map(function (part) {
          return common.capitalize(part);
        }).join('');
      }
    
      transports.__defineGetter__(name, function () {
        return require('./transports/' + transport)[name];
      });
    });
  provide("winston/lib/winston/transports", module.exports);
}(global));

// pakmanager:winston/lib/winston/logger
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * logger.js: Core logger object used by winston.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var events = require('events'),
        util = require('util'),
        async = require('async'),
        config =  require('winston/lib/winston/config'),
        common =  require('winston/lib/winston/common'),
        exception =  require('winston/lib/winston/exception'),
        Stream = require('stream').Stream;
    
    //
    // ### function Logger (options)
    // #### @options {Object} Options for this instance.
    // Constructor function for the Logger object responsible
    // for persisting log messages and metadata to one or more transports.
    //
    var Logger = exports.Logger = function (options) {
      events.EventEmitter.call(this);
      options = options || {};
    
      var self = this,
          handleExceptions = false;
    
      //
      // Set Levels and default logging level
      //
      this.padLevels = options.padLevels || false;
      this.setLevels(options.levels);
      if (options.colors) {
        config.addColors(options.colors);
      }
    
      //
      // Hoist other options onto this instance.
      //
      this.level       = options.level || 'info';
      this.emitErrs    = options.emitErrs || false;
      this.stripColors = options.stripColors || false;
      this.exitOnError = typeof options.exitOnError !== 'undefined'
        ? options.exitOnError
        : true;
    
      //
      // Setup other intelligent default settings.
      //
      this.transports        = {};
      this.rewriters         = [];
      this.filters           = [];
      this.exceptionHandlers = {};
      this.profilers         = {};
      this._names            = [];
      this._hnames           = [];
    
      if (options.transports) {
        options.transports.forEach(function (transport) {
          self.add(transport, null, true);
    
          if (transport.handleExceptions) {
            handleExceptions = true;
          }
        });
      }
    
      if (options.rewriters) {
        options.rewriters.forEach(function (rewriter) {
          self.addRewriter(rewriter);
        });
      }
    
      if (options.exceptionHandlers) {
        handleExceptions = true;
        options.exceptionHandlers.forEach(function (handler) {
          self._hnames.push(handler.name);
          self.exceptionHandlers[handler.name] = handler;
        });
      }
    
      if (options.handleExceptions || handleExceptions) {
        this.handleExceptions();
      }
    };
    
    //
    // Inherit from `events.EventEmitter`.
    //
    util.inherits(Logger, events.EventEmitter);
    
    //
    // ### function extend (target)
    // #### @target {Object} Target to extend.
    // Extends the target object with a 'log' method
    // along with a method for each level in this instance.
    //
    Logger.prototype.extend = function (target) {
      var self = this;
      ['log', 'profile', 'startTimer'].concat(Object.keys(this.levels)).forEach(function (method) {
        target[method] = function () {
          return self[method].apply(self, arguments);
        };
      });
    
      return this;
    };
    
    //
    // ### function log (level, msg, [meta], callback)
    // #### @level {string} Level at which to log the message.
    // #### @msg {string} Message to log
    // #### @meta {Object} **Optional** Additional metadata to attach
    // #### @callback {function} Continuation to respond to when complete.
    // Core logging method exposed to Winston. Metadata is optional.
    //
    Logger.prototype.log = function (level) {
      var self = this,
          args = Array.prototype.slice.call(arguments, 1);
    
      while(args[args.length - 1] === null) {
        args.pop();
      }
    
      var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null,
          meta     = typeof args[args.length - 1] === 'object' && Object.prototype.toString.call(args[args.length - 1]) !== '[object RegExp]' ? args.pop() : {},
          msg      = util.format.apply(null, args);
    
      // If we should pad for levels, do so
      if (this.padLevels) {
        msg = new Array(this.levelLength - level.length + 1).join(' ') + msg;
      }
    
      function onError (err) {
        if (callback) {
          callback(err);
        }
        else if (self.emitErrs) {
          self.emit('error', err);
        }
      }
    
    
      if (Object.keys(this.transports).length === 0) {
        return onError(new Error('Cannot log with no transports.'));
      }
      else if (typeof self.levels[level] === 'undefined') {
        return onError(new Error('Unknown log level: ' + level));
      }
    
      this.rewriters.forEach(function (rewriter) {
        meta = rewriter(level, msg, meta);
      });
    
      this.filters.forEach(function(filter) {
        var filtered = filter(msg, meta, level);
        if (typeof filtered === 'string')
          msg = filtered;
        else {
          msg = filtered.msg;
          meta = filtered.meta;
        }
      });
    
      //
      // For consideration of terminal 'color" programs like colors.js,
      // which can add ANSI escape color codes to strings, we destyle the
      // ANSI color escape codes when `this.stripColors` is set.
      //
      // see: http://en.wikipedia.org/wiki/ANSI_escape_code
      //
      if (this.stripColors) {
        var code = /\u001b\[(\d+(;\d+)*)?m/g;
        msg = ('' + msg).replace(code, '');
      }
    
      //
      // Log for each transport and emit 'logging' event
      //
      function emit(name, next) {
        var transport = self.transports[name];
        if ((transport.level && self.levels[transport.level] <= self.levels[level])
          || (!transport.level && self.levels[self.level] <= self.levels[level])) {
          transport.log(level, msg, meta, function (err) {
            if (err) {
              err.transport = transport;
              cb(err);
              return next();
            }
            self.emit('logging', transport, level, msg, meta);
            next();
          });
        } else {
          next();
        }
      }
    
      //
      // Respond to the callback
      //
      function cb(err) {
        if (callback) {
          if (err) return callback(err);
          callback(null, level, msg, meta);
        }
        callback = null;
        if (!err) {
          self.emit('logged', level, msg, meta);
        }
      }
    
      async.forEach(this._names, emit, cb);
    
      return this;
    };
    
    //
    // ### function query (options, callback)
    // #### @options {Object} Query options for this instance.
    // #### @callback {function} Continuation to respond to when complete.
    // Queries the all transports for this instance with the specified `options`.
    // This will aggregate each transport's results into one object containing
    // a property per transport.
    //
    Logger.prototype.query = function (options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
    
      var self = this,
          options = options || {},
          results = {},
          query = common.clone(options.query) || {},
          transports;
    
      //
      // Helper function to query a single transport
      //
      function queryTransport(transport, next) {
        if (options.query) {
          options.query = transport.formatQuery(query);
        }
    
        transport.query(options, function (err, results) {
          if (err) {
            return next(err);
          }
    
          next(null, transport.formatResults(results, options.format));
        });
      }
    
      //
      // Helper function to accumulate the results from
      // `queryTransport` into the `results`.
      //
      function addResults (transport, next) {
        queryTransport(transport, function (err, result) {
          //
          // queryTransport could potentially invoke the callback
          // multiple times since Transport code can be unpredictable.
          //
          if (next) {
            result = err || result;
            if (result) {
              results[transport.name] = result;
            }
    
            next();
          }
    
          next = null;
        });
      }
    
      //
      // If an explicit transport is being queried then
      // respond with the results from only that transport
      //
      if (options.transport) {
        options.transport = options.transport.toLowerCase();
        return queryTransport(this.transports[options.transport], callback);
      }
    
      //
      // Create a list of all transports for this instance.
      //
      transports = this._names.map(function (name) {
        return self.transports[name];
      }).filter(function (transport) {
        return !!transport.query;
      });
    
      //
      // Iterate over the transports in parallel setting the
      // appropriate key in the `results`
      //
      async.forEach(transports, addResults, function () {
        callback(null, results);
      });
    };
    
    //
    // ### function stream (options)
    // #### @options {Object} Stream options for this instance.
    // Returns a log stream for all transports. Options object is optional.
    //
    Logger.prototype.stream = function (options) {
      var self = this,
          options = options || {},
          out = new Stream,
          streams = [],
          transports;
    
      if (options.transport) {
        var transport = this.transports[options.transport];
        delete options.transport;
        if (transport && transport.stream) {
          return transport.stream(options);
        }
      }
    
      out._streams = streams;
      out.destroy = function () {
        var i = streams.length;
        while (i--) streams[i].destroy();
      };
    
      //
      // Create a list of all transports for this instance.
      //
      transports = this._names.map(function (name) {
        return self.transports[name];
      }).filter(function (transport) {
        return !!transport.stream;
      });
    
      transports.forEach(function (transport) {
        var stream = transport.stream(options);
        if (!stream) return;
    
        streams.push(stream);
    
        stream.on('log', function (log) {
          log.transport = log.transport || [];
          log.transport.push(transport.name);
          out.emit('log', log);
        });
    
        stream.on('error', function (err) {
          err.transport = err.transport || [];
          err.transport.push(transport.name);
          out.emit('error', err);
        });
      });
    
      return out;
    };
    
    //
    // ### function close ()
    // Cleans up resources (streams, event listeners) for all
    // transports associated with this instance (if necessary).
    //
    Logger.prototype.close = function () {
      var self = this;
    
      this._names.forEach(function (name) {
        var transport = self.transports[name];
        if (transport && transport.close) {
          transport.close();
        }
      });
    
      this.emit('close');
    };
    
    //
    // ### function handleExceptions ()
    // Handles `uncaughtException` events for the current process
    //
    Logger.prototype.handleExceptions = function () {
      var args = Array.prototype.slice.call(arguments),
          handlers = [],
          self = this;
    
      args.forEach(function (a) {
        if (Array.isArray(a)) {
          handlers = handlers.concat(a);
        }
        else {
          handlers.push(a);
        }
      });
    
      handlers.forEach(function (handler) {
        self.exceptionHandlers[handler.name] = handler;
      });
    
      this._hnames = Object.keys(self.exceptionHandlers);
    
      if (!this.catchExceptions) {
        this.catchExceptions = this._uncaughtException.bind(this);
        process.on('uncaughtException', this.catchExceptions);
      }
    };
    
    //
    // ### function unhandleExceptions ()
    // Removes any handlers to `uncaughtException` events
    // for the current process
    //
    Logger.prototype.unhandleExceptions = function () {
      var self = this;
    
      if (this.catchExceptions) {
        Object.keys(this.exceptionHandlers).forEach(function (name) {
          var handler = self.exceptionHandlers[name];
          if (handler.close) {
            handler.close();
          }
        });
    
        this.exceptionHandlers = {};
        Object.keys(this.transports).forEach(function (name) {
          var transport = self.transports[name];
          if (transport.handleExceptions) {
            transport.handleExceptions = false;
          }
        })
    
        process.removeListener('uncaughtException', this.catchExceptions);
        this.catchExceptions = false;
      }
    };
    
    //
    // ### function add (transport, [options])
    // #### @transport {Transport} Prototype of the Transport object to add.
    // #### @options {Object} **Optional** Options for the Transport to add.
    // #### @instance {Boolean} **Optional** Value indicating if `transport` is already instantiated.
    // Adds a transport of the specified type to this instance.
    //
    Logger.prototype.add = function (transport, options, created) {
      var instance = created ? transport : (new (transport)(options));
    
      if (!instance.name && !instance.log) {
        throw new Error('Unknown transport with no log() method');
      }
      else if (this.transports[instance.name]) {
        throw new Error('Transport already attached: ' + instance.name);
      }
    
      this.transports[instance.name] = instance;
      this._names = Object.keys(this.transports);
    
      //
      // Listen for the `error` event on the new Transport
      //
      instance._onError = this._onError.bind(this, instance)
      if (!created) {
        instance.on('error', instance._onError);
      }
    
      //
      // If this transport has `handleExceptions` set to `true`
      // and we are not already handling exceptions, do so.
      //
      if (instance.handleExceptions && !this.catchExceptions) {
        this.handleExceptions();
      }
    
      return this;
    };
    
    //
    // ### function addRewriter (transport, [options])
    // #### @transport {Transport} Prototype of the Transport object to add.
    // #### @options {Object} **Optional** Options for the Transport to add.
    // #### @instance {Boolean} **Optional** Value indicating if `transport` is already instantiated.
    // Adds a transport of the specified type to this instance.
    //
    Logger.prototype.addRewriter = function (rewriter) {
      this.rewriters.push(rewriter);
    }
    
    //
    // ### function addFilter (filter)
    // #### @filter {function} Filter function, called with the message and
    // optional metadata as the two arguments.
    // Expected to return either the filtered message or an object with properties:
    //   - msg = the filtered message string
    //   - meta = the filtered metadata object
    //
    Logger.prototype.addFilter = function (filter) {
      this.filters.push(filter);
    }
    
    //
    // ### function clear ()
    // Remove all transports from this instance
    //
    Logger.prototype.clear = function () {
      for (var name in this.transports) {
        this.remove({ name: name });
      }
    };
    
    //
    // ### function remove (transport)
    // #### @transport {Transport|String} Transport or Name to remove.
    // Removes a transport of the specified type from this instance.
    //
    Logger.prototype.remove = function (transport) {
      var name = typeof transport !== 'string'
        ? transport.name || transport.prototype.name
        : transport;
    
      if (!this.transports[name]) {
        throw new Error('Transport ' + name + ' not attached to this instance');
      }
    
      var instance = this.transports[name];
      delete this.transports[name];
      this._names = Object.keys(this.transports);
    
      if (instance.close) {
        instance.close();
      }
    
      if (instance._onError) {
        instance.removeListener('error', instance._onError);
      }
      return this;
    };
    
    var ProfileHandler = function (logger) {
      this.logger = logger;
    
      this.start = Date.now();
    
      this.done = function (msg) {
        var args, callback, meta;
        args     = Array.prototype.slice.call(arguments);
        callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;
        meta     = typeof args[args.length - 1] === 'object' ? args.pop() : {};
    
        meta.durationMs = (Date.now()) - this.start;
    
        return this.logger.info(msg, meta, callback);
      }
    }
    
    Logger.prototype.startTimer = function () {
      return new ProfileHandler(this);
    }
    
    //
    // ### function profile (id, [msg, meta, callback])
    // #### @id {string} Unique id of the profiler
    // #### @msg {string} **Optional** Message to log
    // #### @meta {Object} **Optional** Additional metadata to attach
    // #### @callback {function} **Optional** Continuation to respond to when complete.
    // Tracks the time inbetween subsequent calls to this method
    // with the same `id` parameter. The second call to this method
    // will log the difference in milliseconds along with the message.
    //
    Logger.prototype.profile = function (id) {
      var now = Date.now(), then, args,
          msg, meta, callback;
    
      if (this.profilers[id]) {
        then = this.profilers[id];
        delete this.profilers[id];
    
        // Support variable arguments: msg, meta, callback
        args     = Array.prototype.slice.call(arguments);
        callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;
        meta     = typeof args[args.length - 1] === 'object' ? args.pop() : {};
        msg      = args.length === 2 ? args[1] : id;
    
        // Set the duration property of the metadata
        meta.durationMs = now - then;
        return this.info(msg, meta, callback);
      }
      else {
        this.profilers[id] = now;
      }
    
      return this;
    };
    
    //
    // ### function setLevels (target)
    // #### @target {Object} Target levels to use on this instance
    // Sets the `target` levels specified on this instance.
    //
    Logger.prototype.setLevels = function (target) {
      return common.setLevels(this, this.levels, target);
    };
    
    //
    // ### function cli ()
    // Configures this instance to have the default
    // settings for command-line interfaces: no timestamp,
    // colors enabled, padded output, and additional levels.
    //
    Logger.prototype.cli = function () {
      this.padLevels = true;
      this.setLevels(config.cli.levels);
      config.addColors(config.cli.colors);
    
      if (this.transports.console) {
        this.transports.console.colorize = this.transports.console.colorize || true;
        this.transports.console.timestamp = this.transports.console.timestamp || false;
      }
    
      return this;
    };
    
    //
    // ### @private function _uncaughtException (err)
    // #### @err {Error} Error to handle
    // Logs all relevant information around the `err` and
    // exits the current process.
    //
    Logger.prototype._uncaughtException = function (err) {
      var self = this,
          responded = false,
          info = exception.getAllInfo(err),
          handlers = this._getExceptionHandlers(),
          timeout,
          doExit;
    
      //
      // Calculate if we should exit on this error
      //
      doExit = typeof this.exitOnError === 'function'
        ? this.exitOnError(err)
        : this.exitOnError;
    
      function logAndWait(transport, next) {
        transport.logException('uncaughtException: ' + (err.message || err), info, next, err);
      }
    
      function gracefulExit() {
        if (doExit && !responded) {
          //
          // Remark: Currently ignoring any exceptions from transports
          //         when catching uncaught exceptions.
          //
          clearTimeout(timeout);
          responded = true;
          process.exit(1);
        }
      }
    
      if (!handlers || handlers.length === 0) {
        return gracefulExit();
      }
    
      //
      // Log to all transports and allow the operation to take
      // only up to `3000ms`.
      //
      async.forEach(handlers, logAndWait, gracefulExit);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3000);
      }
    };
    
    //
    // ### @private function _getExceptionHandlers ()
    // Returns the list of transports and exceptionHandlers
    // for this instance.
    //
    Logger.prototype._getExceptionHandlers = function () {
      var self = this;
    
      return this._hnames.map(function (name) {
        return self.exceptionHandlers[name];
      }).concat(this._names.map(function (name) {
        return self.transports[name].handleExceptions && self.transports[name];
      })).filter(Boolean);
    };
    
    //
    // ### @private function _onError (transport, err)
    // #### @transport {Object} Transport on which the error occured
    // #### @err {Error} Error that occurred on the transport
    // Bubbles the error, `err`, that occured on the specified `transport`
    // up from this instance if `emitErrs` has been set.
    //
    Logger.prototype._onError = function (transport, err) {
      if (this.emitErrs) {
        this.emit('error', err, transport);
      }
    };
    
  provide("winston/lib/winston/logger", module.exports);
}(global));

// pakmanager:winston/lib/winston/transports/transport
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * transport.js: Base Transport object for all Winston transports.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var events = require('events'),
        util = require('util');
    
    //
    // ### function Transport (options)
    // #### @options {Object} Options for this instance.
    // Constructor function for the Tranport object responsible
    // base functionality for all winston transports.
    //
    var Transport = exports.Transport = function (options) {
      events.EventEmitter.call(this);
    
      options        = options        || {};
      this.silent    = options.silent || false;
      this.raw       = options.raw    || false;
      this.name      = options.name   || this.name;
      this.formatter = options.formatter;
    
      //
      // Do not set a default level. When `level` is falsey on any
      // `Transport` instance, any `Logger` instance uses the
      // configured level (instead of the Transport level)
      //
      this.level = options.level;
    
      this.handleExceptions = options.handleExceptions || false;
      this.exceptionsLevel  = options.exceptionsLevel || 'error';
      this.humanReadableUnhandledException = options.humanReadableUnhandledException || false;
    };
    
    //
    // Inherit from `events.EventEmitter`.
    //
    util.inherits(Transport, events.EventEmitter);
    
    //
    // ### function formatQuery (query)
    // #### @query {string|Object} Query to format
    // Formats the specified `query` Object (or string) to conform
    // with the underlying implementation of this transport.
    //
    Transport.prototype.formatQuery = function (query) {
      return query;
    };
    
    //
    // ### function normalizeQuery (query)
    // #### @options {string|Object} Query to normalize
    // Normalize options for query
    //
    Transport.prototype.normalizeQuery = function (options) {
      //
      // Use options similar to loggly.
      // [See Loggly Search API](http://wiki.loggly.com/retrieve_events#optional)
      //
    
      options = options || {};
    
      // limit
      options.rows = options.rows || options.limit || 10;
    
      // starting row offset
      options.start = options.start || 0;
    
      // now
      options.until = options.until || new Date;
      if (typeof options.until !== 'object') {
        options.until = new Date(options.until);
      }
    
      // now - 24
      options.from = options.from || (options.until - (24 * 60 * 60 * 1000));
      if (typeof options.from !== 'object') {
        options.from = new Date(options.from);
      }
    
    
      // 'asc' or 'desc'
      options.order = options.order || 'desc';
    
      // which fields to select
      options.fields = options.fields;
    
      return options;
    };
    
    //
    // ### function formatResults (results, options)
    // #### @results {Object|Array} Results returned from `.query`.
    // #### @options {Object} **Optional** Formatting options
    // Formats the specified `results` with the given `options` accordinging
    // to the implementation of this transport.
    //
    Transport.prototype.formatResults = function (results, options) {
      return results;
    };
    
    //
    // ### function logException (msg, meta, callback)
    // #### @msg {string} Message to log
    // #### @meta {Object} **Optional** Additional metadata to attach
    // #### @callback {function} Continuation to respond to when complete.
    // Logs the specified `msg`, `meta` and responds to the callback once the log
    // operation is complete to ensure that the event loop will not exit before
    // all logging has completed.
    //
    Transport.prototype.logException = function (msg, meta, callback) {
      var self = this;
    
      function onLogged () {
        self.removeListener('error', onError);
        callback();
      }
    
      function onError () {
        self.removeListener('logged', onLogged);
        callback();
      }
    
      this.once('logged', onLogged);
      this.once('error', onError);
      this.log(self.exceptionsLevel, msg, meta, function () { });
    };
    
  provide("winston/lib/winston/transports/transport", module.exports);
}(global));

// pakmanager:winston/lib/winston
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * winston.js: Top-level include defining Winston.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var winston = exports;
    
    //
    // Expose version using `pkginfo`
    //
    require('pkginfo')(module, 'version');
    
    //
    // Include transports defined by default by winston
    //
    winston.transports =  require('winston/lib/winston/transports');
    
    //
    // Expose utility methods
    //
    var common             =  require('winston/lib/winston/common');
    winston.hash           = common.hash;
    winston.clone          = common.clone;
    winston.longestElement = common.longestElement;
    winston.exception      =  require('winston/lib/winston/exception');
    winston.config         =  require('winston/lib/winston/config');
    winston.addColors      = winston.config.addColors;
    
    //
    // Expose core Logging-related prototypes.
    //
    winston.Container      =  require('winston/lib/winston/container').Container;
    winston.Logger         =  require('winston/lib/winston/logger').Logger;
    winston.Transport      =  require('winston/lib/winston/transports/transport').Transport;
    
    //
    // We create and expose a default `Container` to `winston.loggers` so that the
    // programmer may manage multiple `winston.Logger` instances without any additional overhead.
    //
    // ### some-file1.js
    //
    //     var logger =  require('winston').loggers.get('something');
    //
    // ### some-file2.js
    //
    //     var logger =  require('winston').loggers.get('something');
    //
    winston.loggers = new winston.Container();
    
    //
    // We create and expose a 'defaultLogger' so that the programmer may do the
    // following without the need to create an instance of winston.Logger directly:
    //
    //     var winston =  require('winston');
    //     winston.log('info', 'some message');
    //     winston.error('some error');
    //
    var defaultLogger = new winston.Logger({
      transports: [new winston.transports.Console()]
    });
    
    //
    // Pass through the target methods onto `winston.
    //
    var methods = [
      'log',
      'query',
      'stream',
      'add',
      'remove',
      'clear',
      'profile',
      'startTimer',
      'extend',
      'cli',
      'handleExceptions',
      'unhandleExceptions',
      'addRewriter',
      'addFilter'
    ];
    common.setLevels(winston, null, defaultLogger.levels);
    methods.forEach(function (method) {
      winston[method] = function () {
        return defaultLogger[method].apply(defaultLogger, arguments);
      };
    });
    
    //
    // ### function cli ()
    // Configures the default winston logger to have the
    // settings for command-line interfaces: no timestamp,
    // colors enabled, padded output, and additional levels.
    //
    winston.cli = function () {
      winston.padLevels = true;
      common.setLevels(winston, defaultLogger.levels, winston.config.cli.levels);
      defaultLogger.setLevels(winston.config.cli.levels);
      winston.config.addColors(winston.config.cli.colors);
    
      if (defaultLogger.transports.console) {
        defaultLogger.transports.console.colorize = true;
        defaultLogger.transports.console.timestamp = false;
      }
    
      return winston;
    };
    
    //
    // ### function setLevels (target)
    // #### @target {Object} Target levels to use
    // Sets the `target` levels specified on the default winston logger.
    //
    winston.setLevels = function (target) {
      common.setLevels(winston, defaultLogger.levels, target);
      defaultLogger.setLevels(target);
    };
    
    //
    // Define getter / setter for the default logger level
    // which need to be exposed by winston.
    //
    Object.defineProperty(winston, 'level', {
      get: function () {
        return defaultLogger.level;
      },
      set: function (val) {
        defaultLogger.level = val;
    
        Object.keys(defaultLogger.transports).forEach(function(key) {
          defaultLogger.transports[key].level = val;
        });
      }
    });
    
    //
    // Define getters / setters for appropriate properties of the
    // default logger which need to be exposed by winston.
    //
    ['emitErrs', 'exitOnError', 'padLevels', 'levelLength', 'stripColors'].forEach(function (prop) {
      Object.defineProperty(winston, prop, {
        get: function () {
          return defaultLogger[prop];
        },
        set: function (val) {
          defaultLogger[prop] = val;
        }
      });
    });
    
    //
    // @default {Object}
    // The default transports and exceptionHandlers for
    // the default winston logger.
    //
    Object.defineProperty(winston, 'default', {
      get: function () {
        return {
          transports: defaultLogger.transports,
          exceptionHandlers: defaultLogger.exceptionHandlers
        };
      }
    });
    
  provide("winston/lib/winston", module.exports);
}(global));

// pakmanager:winston/lib/winston/container
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * container.js: Inversion of control container for winston logger instances
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var common =  require('winston/lib/winston/common'),
        winston =  require('winston/lib/winston'),
        extend = require('util')._extend;
    
    //
    // ### function Container (options)
    // #### @options {Object} Default pass-thru options for Loggers
    // Constructor function for the Container object responsible for managing
    // a set of `winston.Logger` instances based on string ids.
    //
    var Container = exports.Container = function (options) {
      this.loggers = {};
      this.options = options || {};
      this.default = {
        transports: [
          new winston.transports.Console({
            level: 'silly',
            colorize: false
          })
        ]
      }
    };
    
    //
    // ### function get / add (id, options)
    // #### @id {string} Id of the Logger to get
    // #### @options {Object} **Optional** Options for the Logger instance
    // Retreives a `winston.Logger` instance for the specified `id`. If
    // an instance does not exist, one is created.
    //
    Container.prototype.get = Container.prototype.add = function (id, options) {
      var self = this,
          existing;
    
      if (!this.loggers[id]) {
        //
        // Remark: Simple shallow clone for configuration options in case we pass in
        // instantiated protoypal objects
        //
        options = extend({}, options || this.options || this.default);
        existing = options.transports || this.options.transports;
        //
        // Remark: Make sure if we have an array of transports we slice it to make copies
        // of those references.
        //
        options.transports = existing ? existing.slice() : [];
    
        if (options.transports.length === 0 && (!options || !options['console'])) {
          options.transports.push(this.default.transports[0]);
        }
    
        Object.keys(options).forEach(function (key) {
          if (key === 'transports') {
            return;
          }
    
          var name = common.capitalize(key);
    
          if (!winston.transports[name]) {
            throw new Error('Cannot add unknown transport: ' + name);
          }
    
          var namedOptions = options[key];
          namedOptions.id = id;
          options.transports.push(new (winston.transports[name])(namedOptions));
        });
    
        this.loggers[id] = new winston.Logger(options);
    
        this.loggers[id].on('close', function () {
            self._delete(id);
        });
      }
    
      return this.loggers[id];
    };
    
    //
    // ### function close (id)
    // #### @id {string} **Optional** Id of the Logger instance to find
    // Returns a boolean value indicating if this instance
    // has a logger with the specified `id`.
    //
    Container.prototype.has = function (id) {
      return !!this.loggers[id];
    };
    
    //
    // ### function close (id)
    // #### @id {string} **Optional** Id of the Logger instance to close
    // Closes a `Logger` instance with the specified `id` if it exists.
    // If no `id` is supplied then all Loggers are closed.
    //
    Container.prototype.close = function (id) {
      var self = this;
    
      function _close (id) {
        if (!self.loggers[id]) {
          return;
        }
    
        self.loggers[id].close();
        self._delete(id);
      }
    
      return id ? _close(id) : Object.keys(this.loggers).forEach(function (id) {
        _close(id);
      });
    };
    
    //
    // ### @private function _delete (id)
    // #### @id {string} Id of the Logger instance to delete from container
    // Deletes a `Logger` instance with the specified `id`.
    //
    Container.prototype._delete = function (id) {
        delete this.loggers[id];
    }
    
    
  provide("winston/lib/winston/container", module.exports);
}(global));

// pakmanager:winston
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * winston.js: Top-level include defining Winston.
     *
     * (C) 2010 Charlie Robbins
     * MIT LICENCE
     *
     */
    
    var winston = exports;
    
    //
    // Expose version using `pkginfo`
    //
    require('pkginfo')(module, 'version');
    
    //
    // Include transports defined by default by winston
    //
    winston.transports =  require('winston/lib/winston/transports');
    
    //
    // Expose utility methods
    //
    var common             =  require('winston/lib/winston/common');
    winston.hash           = common.hash;
    winston.clone          = common.clone;
    winston.longestElement = common.longestElement;
    winston.exception      =  require('winston/lib/winston/exception');
    winston.config         =  require('winston/lib/winston/config');
    winston.addColors      = winston.config.addColors;
    
    //
    // Expose core Logging-related prototypes.
    //
    winston.Container      =  require('winston/lib/winston/container').Container;
    winston.Logger         =  require('winston/lib/winston/logger').Logger;
    winston.Transport      =  require('winston/lib/winston/transports/transport').Transport;
    
    //
    // We create and expose a default `Container` to `winston.loggers` so that the
    // programmer may manage multiple `winston.Logger` instances without any additional overhead.
    //
    // ### some-file1.js
    //
    //     var logger =  require('winston').loggers.get('something');
    //
    // ### some-file2.js
    //
    //     var logger =  require('winston').loggers.get('something');
    //
    winston.loggers = new winston.Container();
    
    //
    // We create and expose a 'defaultLogger' so that the programmer may do the
    // following without the need to create an instance of winston.Logger directly:
    //
    //     var winston =  require('winston');
    //     winston.log('info', 'some message');
    //     winston.error('some error');
    //
    var defaultLogger = new winston.Logger({
      transports: [new winston.transports.Console()]
    });
    
    //
    // Pass through the target methods onto `winston.
    //
    var methods = [
      'log',
      'query',
      'stream',
      'add',
      'remove',
      'clear',
      'profile',
      'startTimer',
      'extend',
      'cli',
      'handleExceptions',
      'unhandleExceptions',
      'addRewriter',
      'addFilter'
    ];
    common.setLevels(winston, null, defaultLogger.levels);
    methods.forEach(function (method) {
      winston[method] = function () {
        return defaultLogger[method].apply(defaultLogger, arguments);
      };
    });
    
    //
    // ### function cli ()
    // Configures the default winston logger to have the
    // settings for command-line interfaces: no timestamp,
    // colors enabled, padded output, and additional levels.
    //
    winston.cli = function () {
      winston.padLevels = true;
      common.setLevels(winston, defaultLogger.levels, winston.config.cli.levels);
      defaultLogger.setLevels(winston.config.cli.levels);
      winston.config.addColors(winston.config.cli.colors);
    
      if (defaultLogger.transports.console) {
        defaultLogger.transports.console.colorize = true;
        defaultLogger.transports.console.timestamp = false;
      }
    
      return winston;
    };
    
    //
    // ### function setLevels (target)
    // #### @target {Object} Target levels to use
    // Sets the `target` levels specified on the default winston logger.
    //
    winston.setLevels = function (target) {
      common.setLevels(winston, defaultLogger.levels, target);
      defaultLogger.setLevels(target);
    };
    
    //
    // Define getter / setter for the default logger level
    // which need to be exposed by winston.
    //
    Object.defineProperty(winston, 'level', {
      get: function () {
        return defaultLogger.level;
      },
      set: function (val) {
        defaultLogger.level = val;
    
        Object.keys(defaultLogger.transports).forEach(function(key) {
          defaultLogger.transports[key].level = val;
        });
      }
    });
    
    //
    // Define getters / setters for appropriate properties of the
    // default logger which need to be exposed by winston.
    //
    ['emitErrs', 'exitOnError', 'padLevels', 'levelLength', 'stripColors'].forEach(function (prop) {
      Object.defineProperty(winston, prop, {
        get: function () {
          return defaultLogger[prop];
        },
        set: function (val) {
          defaultLogger[prop] = val;
        }
      });
    });
    
    //
    // @default {Object}
    // The default transports and exceptionHandlers for
    // the default winston logger.
    //
    Object.defineProperty(winston, 'default', {
      get: function () {
        return {
          transports: defaultLogger.transports,
          exceptionHandlers: defaultLogger.exceptionHandlers
        };
      }
    });
    
  provide("winston", module.exports);
}(global));

// pakmanager:cjson
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs'),
        Path = require('path'),
        jsonlint = require('jsonlint');
    
    /**
     * Default options.
     *
     * @type {Object}
     */
    exports.options = {
        // merge all passed/found config files, see `cjson.extend`
        merge: false,
        // allows you to do some string replacements, see `cjson.replace`.
        replace: null,
        // freeze config recursively, see `cjson.freeze`
        freeze: false,
        // you can use any other extension for your config files, f.e. *.cjson
        ext: '.json',
        // you can use any parser, f.e. you could switch to JSON.parse for speed
        parse: jsonlint.parse
    }
    
    /**
     * Remove single and multilie comments. Make sure to
     * leave them inside of strings.
     *
     * @param {String} json file.
     * @return {String} json without comments.
     */
    exports.decomment = function(str) {
        var i,
            curChar, nextChar,
            inString = false,
            inComment = false,
            newStr = '';
    
        for (i = 0; i < str.length; ++i) {
            curChar = str.charAt(i);
            nextChar = str.charAt(i + 1);
    
            // it's either closing or opening inString and it is not escaped
            if (!inComment && curChar === '"' && str.charAt(i - 1) !== '\\') {
                inString = !inString;
            }
    
            // we are not inside of a string
            if (!inString) {
                // singleline comment start
                if (!inComment && curChar + nextChar === '//') {
                    ++i;
                    inComment = 1;
                // singleline comment end
                } else if (inComment === 1 && curChar === '\n') {
                    inComment = false;
                // multiline comment start
                } else if (!inComment && curChar + nextChar === '/*') {
                    ++i;
                    inComment = 2;
                    curChar = '';
                // multiline comment end
                } else if (inComment === 2 && curChar + nextChar === '*/') {
                    ++i;
                    inComment = false;
                    curChar = '';
                }
    
                if (inComment) {
                    curChar = '';
                }
            }
    
            newStr += curChar;
        }
    
    
        return newStr;
    };
    
    /**
     * Decomment the string and parse json.
     *
     * @param {String} json.
     * @param {Function} [reviver] will be called for every key and value at every
     *     level of the final result.
     * @return {Object} parsed json object.
     */
    exports.parse = function(str, reviver) {
        return exports.options.parse(exports.decomment(str), reviver);
    };
    
    /**
     * Replace templates with data. {{toReplace}}
     *
     * @param {String} json.
     * @param {Object} data data hash.
     * @return {String} json string with replaced data.
     */
    exports.replace = function(str, data) {
        return str.replace(/\{\{([^}]+)\}\}/g, function(match, search) {
            return data[search] ? data[search] : match;
        });
    };
    
    /**
     * Merge objects to the first one
     *
     * @param {Boolean|Object} deep if set true, deep merge will be done.
     * @param {Object} obj1 any object.
     * @param {Object} obj2 any object.
     * @return {Object} target merged object.
     */
    exports.extend = (function() {
        var toString = Object.prototype.toString,
            obj = '[object Object]';
    
        return function extend(deep, obj1, obj2 /*, obj1, obj2, obj3 */) {
            // take first argument, if its not a boolean
            var args = arguments,
                i = deep === true ? 1 : 0,
                key,
                target = args[i];
    
            for (++i; i < args.length; ++i) {
                for (key in args[i]) {
                    if (deep === true &&
                        target[key] &&
                        // if not doing this check you may end in
                        // endless loop if using deep option
                        toString.call(args[i][key]) === obj &&
                        toString.call(target[key]) === obj) {
    
                        // create a copy of target object to avoid subobjects changes
                        target[key] = extend(deep, {}, target[key]);
    
                        extend(deep, target[key], args[i][key]);
                    } else {
                        target[key] = args[i][key];
                    }
                }
            }
    
            return target;
        };
    }());
    
    /**
     * Freeze the object recursively.
     *
     * @param {Object} obj.
     * @return {Object}
     */
    exports.freeze = function freeze(obj) {
        var key;
    
        if (obj instanceof Object) {
            for (key in obj) {
                freeze(obj[key]);
            }
    
            Object.freeze(obj);
        }
    };
    
    /**
     * Load and parse a config file/files.
     *
     * @param {String|Array} path absolute path/paths to the file/files or dir.
     * @param {Object|Boolean} [options] if true, extend all jsons to the first one,
     *     it can be also object {merge: true, replace: {key: 'value'}}
     * @return {Object} conf parsed json object.
     */
    exports.load = function load(path, options) {
        var data, paths, conf;
    
        if (options === true) {
            options = {merge: true};
        }
    
        options = exports.extend({}, exports.options, options);
    
        if (Array.isArray(path)) {
            conf = {};
            path.forEach(function(path) {
                var data = load(path, options),
                    filename;
    
                if (options.merge) {
                    exports.extend(true, conf, data);
                } else {
                    filename = Path.basename(path, options.ext);
                    conf[filename] = data;
                }
            });
    
            return conf;
        }
    
        if (fs.statSync(path).isDirectory()) {
            paths = [];
            fs.readdirSync(path).forEach(function(filename) {
                var file = Path.join(path, filename);
    
                if (Path.extname(file) == options.ext && fs.statSync(file).isFile()) {
                    paths.push(file);
                }
            });
    
            return load(paths, options);
        }
    
        data = fs.readFileSync(path, 'utf-8');
    
        if (options.replace) {
            data = exports.replace(data, options.replace);
        }
    
        try {
            data = exports.parse(data);
        } catch(err) {
            err.message += '\nFile: "' + path + '"';
            throw err;
        }
    
        if (options.freeze) {
            exports.freeze(data);
        }
    
        return data;
    };
    
  provide("cjson", module.exports);
}(global));

// pakmanager:jsonfile
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    
    function readFile (file, options, callback) {
      if (callback == null) {
        callback = options
        options = {}
      }
    
      fs.readFile(file, options, function (err, data) {
        if (err) return callback(err)
    
        var obj
        try {
          obj = JSON.parse(data, options ? options.reviver : null)
        } catch (err2) {
          return callback(err2)
        }
    
        callback(null, obj)
      })
    }
    
    function readFileSync (file, options) {
      options = options || {}
      if (typeof options === 'string') {
        options = {encoding: options}
      }
    
      var shouldThrow = 'throws' in options ? options.throw : true
    
      if (shouldThrow) { // i.e. throw on invalid JSON
        return JSON.parse(fs.readFileSync(file, options), options.reviver)
      } else {
        try {
          return JSON.parse(fs.readFileSync(file, options), options.reviver)
        } catch (err) {
          return null
        }
      }
    }
    
    function writeFile (file, obj, options, callback) {
      if (callback == null) {
        callback = options
        options = {}
      }
    
      var spaces = typeof options === 'object' && options !== null
        ? 'spaces' in options
        ? options.spaces : this.spaces
        : this.spaces
    
      var str = ''
      try {
        str = JSON.stringify(obj, options ? options.replacer : null, spaces) + '\n'
      } catch (err) {
        if (callback) return callback(err, null)
      }
    
      fs.writeFile(file, str, options, callback)
    }
    
    function writeFileSync (file, obj, options) {
      options = options || {}
    
      var spaces = typeof options === 'object' && options !== null
        ? 'spaces' in options
        ? options.spaces : this.spaces
        : this.spaces
    
      var str = JSON.stringify(obj, options.replacer, spaces) + '\n'
      // not sure if fs.writeFileSync returns anything, but just in case
      return fs.writeFileSync(file, str, options)
    }
    
    var jsonfile = {
      spaces: null,
      readFile: readFile,
      readFileSync: readFileSync,
      writeFile: writeFile,
      writeFileSync: writeFileSync
    }
    
    module.exports = jsonfile
    
  provide("jsonfile", module.exports);
}(global));

// pakmanager:nodemiral-forcetty/lib/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports.randomId = function randomId(noOfTexts) {
      noOfTexts = noOfTexts || 17;
      
      var text = "";
      var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    
      for( var i=0; i < noOfTexts; i++ ) {
          text += possible.charAt(Math.floor(Math.random() * possible.length));
      }
      return text;
    };
  provide("nodemiral-forcetty/lib/helpers", module.exports);
}(global));

// pakmanager:nodemiral-forcetty/lib/session
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var spawn = require('child_process').spawn;
    var exec = require('child_process').exec;
    var util = require('util');
    var helpers =  require('nodemiral-forcetty/lib/helpers');
    var fs = require('fs');
    var ejs = require('ejs');
    var path = require('path');
    var debug = require('debug');
    require('colors');
    
    function Session(host, auth, options) {
      if(!(this instanceof Session)) {
        return new Session(host, auth, options);
      }
    
      var self = this;
      this._host = host;
      this._auth = auth;
      this._options = options || {};
    
      this._tasks = [];
      this._callbacks = [];
    
      this._timeout = this._options.timeout;
    
      this._sshOptions = '';
      if (!this._options.ssh) this._options.ssh = {};
      Object.keys(this._options.ssh).forEach(function (key) {
        self._sshOptions += util.format(' -o %s=%s',  key, self._options.ssh[key]);
      });
      this._debug = debug('nodemiral:sess:' + host);
    }
    
    Session.prototype.setTimeout = function(timeoutMillis) {
      this._debug('set timeout: %d', timeoutMillis);
      this._timeout = timeoutMillis;
    };
    
    Session.prototype.copy = function(src, dest, vars, options, callback) {
      if(typeof(options) == 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      callback = callback || function() {};
    
      var self = this;
      var command;
      var copyFile = src;
      var tmpFile;
      var pemFile;
    
      this._debug('copy file - src: %s, dest: %s, vars: %j', src, dest, vars);
    
      if(typeof(vars) == 'function') {
        callback = vars;
        vars = null;
      }
    
      //lets do templating
      if(vars) {
        copyFile = tmpFile = '/tmp/' + helpers.randomId();
      }
    
      if(this._auth.pem) {
        pemFile = '/tmp/' + helpers.randomId();
        fs.writeFile(pemFile, this._auth.pem, { mode: '0400' }, afterPemFileWritten);
      } else if(this._auth.password) {
        command = util.format('sshpass -p %s scp%s %s %s@%s:%s', 
          this._auth.password, self._sshOptions, copyFile, this._auth.username, this._host, dest);
        startProcessing();
      } else {
        throw new Error('NO_PASSWORD_OR_PEM');
      }
    
      function afterPemFileWritten(err) {
        if(err) {
          callback(err);
        } else {
          command = util.format('scp%s -i %s %s %s@%s:%s', 
            self._sshOptions, pemFile, copyFile, self._auth.username, self._host, dest);
          startProcessing();  
        }
      }
    
      function startProcessing() {
        if(vars) {
          //do templating
          self._applyTemplate(src, vars, afterTemplateApplied)
        } else {
          self._doSpawn(command, options, afterCompleted);
        }
      }
    
      function afterTemplateApplied(err, content) {
        if(err) {
          callback(err);
        } else {
          fs.writeFile(tmpFile, content, afterFileWritten);
        }
      }
    
      function afterFileWritten(err) {
        if(err) {
          callback(err);
        } else {
          self._doSpawn(command, options, afterCompleted);
        }
      }
    
      function afterCompleted() {
        var args = arguments;
        deletePemFile();
    
        function deletePemFile() {
          if(pemFile) {
            fs.unlink(pemFile, deleteTmpFile);
          } else {
            deleteTmpFile();
          }
        }
        function deleteTmpFile() {
          if(tmpFile) {
            fs.unlink(tmpFile, sendCallback);
          } else {
            sendCallback();
          }
        }
    
        function sendCallback() {
          //unlink error should not throw any errors
          callback.apply(null, args);
        }
      }
    };
    
    Session.prototype.execute = function(shellCommand, options, callback) {
      if(typeof(options) == 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      callback = callback || function() {};
    
      var self = this;
      var tmpScript = '/tmp/' + helpers.randomId();
      var command;
      var pemFile;
    
      this._debug('execute - command: %s', shellCommand);
    
      if(this._auth.pem) {
        pemFile = '/tmp/' + helpers.randomId();
        fs.writeFile(pemFile, this._auth.pem, { mode: '0400' }, afterPemFileWritten);
      } else if(this._auth.password) {
        command = util.format('sshpass -p %s ssh%s -t -t %s@%s "bash " < %s', 
          this._auth.password, self._sshOptions, this._auth.username, this._host, tmpScript);
        startProcessing();
      } else {
        throw new Error('NO_PASSWORD_OR_PEM');
      }
    
      function afterPemFileWritten(err) {
        if(err) {
          callback(err);
        } else {
          command = util.format('ssh%s -t -t -i %s %s@%s "bash " < %s', 
            self._sshOptions, pemFile, self._auth.username, self._host, tmpScript);
          startProcessing();
        }
      }
    
      function startProcessing() {
        // Append shellCommand with exits so bash doesn't hang
        shellCommand += "\nexit\nexit";
        fs.writeFile(tmpScript, shellCommand, function(err) {
          if(err) {
            callback(err);
          } else {
            self._doSpawn(command, options, afterCompleted);
          }
        });
      }
    
      function afterCompleted() {
        var args = arguments;
    
        if(pemFile) {
          fs.unlink(pemFile, removeTmpScript);
        } else {
          removeTmpScript();
        }
    
        function removeTmpScript() {
          fs.unlink(tmpScript, sendCallback);
        }
    
        function sendCallback(err) {
          //unlink error should not throw any errors
          callback.apply(err, args);
        }
      }
    };
    
    Session.prototype.executeScript = function(scriptFile, vars, options, callback) {
      if(typeof(options) == 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      callback = callback || function() {};
    
      var self = this;
    
      this._applyTemplate(scriptFile, vars, function(err, content) {
        if(err) {
          callback(err);
        } else {
          self.execute(content, options, callback);
        }
      });
    };
    
    Session.prototype._applyTemplate = function(file, vars, callback) {
      var self = this;
      fs.readFile(file, {encoding: 'utf8'}, function(err, content) {
        if(err) {
          callback(err);
        } else {
          if(vars) {
            var ejsOptions = self._options.ejs || {};
            var content = ejs.compile(content, ejsOptions)(vars);
          }
          callback(null, content);
        } 
      });
    };
    
    Session.prototype._doSpawn = function(command, options, callback) {
      var self = this;
      var tmpScript = '/tmp/' + helpers.randomId();
      var logs = { stdout: "", stderr: ""};
      var bash;
      var timeoutHandler;
      var verbosity = this._options.verbose;
    
      this._debug('spawning command- %s', command);
    
      fs.writeFile(tmpScript, command, function(err) {
        if(err) {
          callback(err);
        } else {
          executeTmpScript();
        }
      });
    
      function executeTmpScript() {
        bash = spawn('bash', [tmpScript]);
        
        bash.stdout.on('data', onStdOut);
        bash.stderr.on('data', onStdErr);
        bash.once('error', sendCallback);
        bash.once('close', onClose);
    
        if(options.onStdout) {
          bash.stdout.on('data', options.onStdout);
        }
    
        if(options.onStderr) {
          bash.stderr.on('data', options.onStderr);
        }
    
        //self._timeout = 10000;
        if(self._timeout) {
          timeoutHandler = setTimeout(onTimeout, self._timeout);
        }
      }
    
      function sendCallback(err, code, logs) {
        if(err) {
          self._debug('error: %s', err.message);
        } else {
          self._debug('spawn completed - code: %d - \n\tstdout: %s \t\tstderr', code, logs.stdout, logs.stderr);
        }
    
        if(callback) {
          callback(err, code, logs);
          callback = null;
    
          //cleanup
          bash.stdout.removeListener('data', onStdOut);
          bash.stderr.removeListener('data', onStdErr);
    
          if(options.onStdout) {
            bash.stdout.removeListener('data', options.onStdout);
          }
          if(options.onStderr) {
            bash.stderr.removeListener('data', options.onStderr);
          }
    
          bash.removeListener('error', sendCallback);
          bash.removeListener('close', onClose);
    
          //clean up tmpScript
          fs.unlink(tmpScript);
        }
      }
    
      function onClose(code) {
        if(timeoutHandler) {
          clearTimeout(timeoutHandler);
          timeoutHandler = null;
        }
        sendCallback(null, code, logs);
      }
    
      function onStdOut(data) {
        if (verbosity) console.log(data.toString().yellow);
        logs.stdout += data.toString();
      }
    
      function onStdErr(data) {
        if (verbosity) console.log(data.toString().red);
        logs.stderr += data.toString();
      }
    
      function onTimeout() {
        var killScript = path.resolve(__dirname, '../scripts/kill.sh');
        sendCallback(new Error('TIMEOUT'));
        exec('sh ' + killScript + ' ' + bash.pid, function(err) {
          if(err) {
            console.error('Killing on timeout failed');
          }
        });
        timeoutHandler = null;
      }
    };
    
    module.exports = Session;
  provide("nodemiral-forcetty/lib/session", module.exports);
}(global));

// pakmanager:nodemiral-forcetty/lib/taskList
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var EventEmitter = require('events').EventEmitter;
    var util = require('util');
    var Session =  require('nodemiral-forcetty/lib/session');
    var handlebars = require('handlebars');
    var colors = require('colors');
    
    function TaskList(name, options) {
      if(!(this instanceof TaskList)) {
        return new TaskList(name, options);
      }
      this._name = name;
      this._options = options || {};
    
      this._pretty = this._options.pretty !== false;
      this._ignoreErrors = true; //this._options.ignoreErrors;
      this._taskQueue = [];
    
      //used as a global variable used by all the tasks for each session
      this._vars = {};
    
      //used by all the tasks and sessions;
      this._globalVars = {}; 
    
      this._dependingTasks = [];
    }
    
    util.inherits(TaskList, EventEmitter);
    
    TaskList.prototype.run = function(sessions, options, callback) {
      var self = this;
      
      if(!sessions) {
        throw new Error('First parameter should be either a session or a list of sessions');
      } else if(!(sessions instanceof Array)) {
        sessions = [sessions];
      }
    
      if(typeof(options) == 'function') {
        callback = options;
        options = {};
      }
      options = options || {};
      var summaryMap = {};
      var completed = 0;
    
      self.log('info', 'Started TaskList: ' + this._name);
      Array.prototype.forEach.call(sessions, function(session) {
        self._runTaskQueue(session, function(err, history) {
          summaryMap[session._host] = {error: err, history: history};
    
          if(++completed == sessions.length) {
            self.log('info', 'Completed TaskList: ' + self._name);
            if(callback) callback(summaryMap);
          }
        });
      });
    };
    
    TaskList.prototype.concat = function(taskLists, name, options) {
      if(typeof(name) == 'object') {
        options = name;
        name = null;
      }
    
      name = name || this._name + '+';
      options = options || this._options;
      var newTaskList = new TaskList(name, options);
    
      //merge content of _taskQueue of all taskLists into the new one
      var actionQueueList = taskLists.map(function(taskList) { return taskList._taskQueue; });
      actionQueueList.unshift(this._taskQueue);
      newTaskList._taskQueue = newTaskList._taskQueue.concat.apply(newTaskList._taskQueue, actionQueueList);
    
      return newTaskList;
    };
    
    TaskList.prototype._runTaskQueue = function(session, callback) {
      var self = this;
      var cnt = 0;
      var taskHistory = [];
      
      runTask();
    
      function runTask() {
        var task = self._taskQueue[cnt++];
        if(task) {
          self.emit('started', task.id);
          self.log('log', util.format('[%s] '.magenta+'- %s', session._host, task.id));
          var options = self._evaluateOptions(task.options, session);
    
          // Spinner
          var Spinner = require('cli-spinner').Spinner;
          var spinr = new Spinner('%s');
          spinr.start();
    
          TaskList._registeredTasks[task.type](session, options, function(err) {
            if(err) {
              taskHistory.push({
                task: task.id,
                status: 'FAILED',
                error: err.message
              });
    
              // stop spinner
              spinr.stop(true);
    
              self.emit('failed', err, task.id);
              self.log('error', util.format('[%s] '.magenta+'\u2718 %s: FAILED\n\t%s'.red, session._host, task.id, err.message.replace(/\n/g, '\n\t')));
    
              if(self._ignoreErrors) {
                runTask();
              } else {
                callback(err, taskHistory);
              }
            } else {
              taskHistory.push({
                task: task.id,
                status: 'SUCCESS'
              });
    
              // stop spinner
              spinr.stop(true);
    
              self.log('log', util.format('[%s] '.magenta+'\u2714 %s: SUCCESS'.green, session._host, task.id));
              self.emit('success', task.id);
              runTask();
            }
          }, function(stdout, stderr) {
            var vars = self._getVarsForSession(session);
            if(task.varsMapper) {
              task.varsMapper.call(vars, stdout, stderr, self._globalVars);
            }
          });
        } else {
          callback(null, taskHistory);
        }
      }
    };
    
    TaskList.prototype._getVarsForSession = function(session) {
      if(!this._vars[session._host]) {
        this._vars[session._host] = {};
      }
    
      return this._vars[session._host];
    };
    
    TaskList.prototype._evaluateOptions = function(options, session) {
      var self = this;
    
      if(options instanceof Array) {
        for(var lc=0; lc<options.length; lc++) {
          self._evaluateOptions(options[lc], session);
        }
        return options;
      } else if(typeof(options) == 'object') {
        for(var key in options) {
          var value = options[key];
    
          if(typeof(value) == 'function') {
            var vars = self._getVarsForSession(session);
            options[key] = value.call(vars, self._globalVars);
          } else if(value == null) {
            options[key] = value;
          } else if(typeof(value) == 'string') {
            //add ejs support
            var vars = self._getVarsForSession(session);
            options[key] = handlebars.compile(value)(vars);
          } else {
            options[key] = self._evaluateOptions(value, session);
          }
        }
        return options;
      } else {
        return options;
      }
    };
    
    TaskList.prototype.log = function(type, message) {
      if (this._pretty) {
        if (type == 'info') {
          message = '[localhost] '.magenta + message.bold.cyan;
        } else if (type == 'error') {
          message = message.bold.red;
        } else {
          message = message.yellow;
        }
    
        console[type](message);
      }
    };
    
    TaskList.prototype.depends = function(taskList) {
      this._dependingTasks.push(taskList);
    };
    
    TaskList._registeredTasks = {};
    
    TaskList.registerTask = function(name, callback) {
      TaskList._registeredTasks[name] = callback;
      TaskList.prototype[name] = function(id, options, varsMapper) {
        this._taskQueue.push({
          type: name, 
          id: id,
          options: options,
          varsMapper: varsMapper
        });
      };
    };
    
    module.exports = TaskList;
    
  provide("nodemiral-forcetty/lib/taskList", module.exports);
}(global));

// pakmanager:nodemiral-forcetty/lib/taskListsRunner
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors = require('colors');
    
    function TaskListRunner(options) {
      if(!(this instanceof TaskListRunner)) {
        return new TaskListRunner(options);
      }
    
      this._options = options || {};
      this._items = [];
    
      this._vars = {};
      this._globalVars = {};
    }
    
    TaskListRunner.prototype.add = function(taskList, sessions) {
      var self = this;
      if(!sessions) {
        throw new Error('No session provided');
      } else if(!sessions instanceof Array) {
        sessions = [sessions]
      }
    
      //adding dependencies
      taskList._dependingTasks.forEach(function(tl) {
        self.add(tl, sessions);
      });
    
      //setting up vars
      taskList._vars = this._vars;
      taskList._globalVars = this._globalVars;
    
      this._items.push({
        taskList: taskList, 
        sessions: sessions
      });
    };
    
    TaskListRunner.prototype.run = function(options) {
      var self = this;
      var count = 0;
    
      runTaskList();
      function runTaskList() {
        var item = self._items[count++];
        if(item) {
          item.taskList.run(item.sessions, options, function(summaryMap) {
            var erroredSummaryMap = self._pickErrored(summaryMap);
            if(erroredSummaryMap) {
              self._printErroredSummaryMap(erroredSummaryMap);
            } else {
              runTaskList();
            }
          });
        }
      }
    };
    
    TaskListRunner.prototype._pickErrored = function(summaryMap) {
      var erroredSummaryMap = {};
      var errorFound = false;
    
      for(var host in summaryMap) {
        if(summaryMap[host].error) {
          erroredSummaryMap[host] = summaryMap[host];
          errorFound = true;
        }
      }
    
      if(errorFound) {
        return erroredSummaryMap;
      } else {
        return null;
      }
    };
    
    TaskListRunner.prototype._printErroredSummaryMap = function(summaryMap) {
      var hosts = Object.keys(summaryMap);
      var message = "\u2718 ERROR(S) in: " + hosts.join(', ');
      console.error(message.bold.red);
    };
    
    module.exports = TaskListRunner;
  provide("nodemiral-forcetty/lib/taskListsRunner", module.exports);
}(global));

// pakmanager:nodemiral-forcetty/lib/coreTasks
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function(hitler) {
      hitler.registerTask('copy', copy);
      hitler.registerTask('execute', execute);
      hitler.registerTask('executeScript', executeScript);
      hitler.registerTask('print', print);
    };
    
    function copy(session, options, callback, varsMapper) {
      if(options.vars) {
        session.copy(options.src, options.dest, options.vars, sendCallback(callback, varsMapper));
      } else {
        session.copy(options.src, options.dest, sendCallback(callback, varsMapper));
      }
    }
    
    function execute(session, options, callback, varsMapper) {
      session.execute(options.command, sendCallback(callback, varsMapper));
    }
    
    function executeScript(session, options, callback, varsMapper) {
      session.executeScript(options.script, options.vars || {}, sendCallback(callback, varsMapper));
    }
    
    function print(session, options, callback, varsMapper) {
      console.log(options.message);
      callback();
    }
    
    function sendCallback(callback, varsMapper) {
      return function(err, code, logs) {
        if (err) {
          callback(err);
        } else if(code !== 0) {
          
          var errorMessage = '\n-----------------------------------STDERR-----------------------------------\n';
          errorMessage += tail(logs.stderr);
          errorMessage += (errorMessage[errorMessage.length-1] != '\n')? '\n' : "";
          errorMessage += '-----------------------------------STDOUT-----------------------------------\n';
          errorMessage += tail(logs.stdout);
          errorMessage += (errorMessage[errorMessage.length-1] != '\n')? '\n' : "";
          errorMessage += '----------------------------------------------------------------------------';
    
          callback(new Error(errorMessage));
        } else {
          if(varsMapper) {
            varsMapper(applyTrim(logs.stdout), applyTrim(logs.stderr));
          }
          callback();
        }
      };
    
      function applyTrim(str) {
        if(str) {
          return str.trim();
        } else {
          return str;
        }
      }
    
      function tail(str) {
        if(str) {
          return str.substring(str.length-1000);
        } else {
          return "";
        }
      }
    }
  provide("nodemiral-forcetty/lib/coreTasks", module.exports);
}(global));

// pakmanager:nodemiral-forcetty
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Session =  require('nodemiral-forcetty/lib/session');
    var TaskList =  require('nodemiral-forcetty/lib/taskList');
    var TaskListsRunner =  require('nodemiral-forcetty/lib/taskListsRunner');
    
    var nodemiral = module.exports;
    nodemiral.session = Session;
    nodemiral.taskList = TaskList;
    nodemiral.taskListsRunner = TaskListsRunner;
    nodemiral.registerTask = TaskList.registerTask;
    
    //load initial core tasks
     require('nodemiral-forcetty/lib/coreTasks')(nodemiral);
  provide("nodemiral-forcetty", module.exports);
}(global));

// pakmanager:prompt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * prompt.js: Simple prompt for prompting information from the command line
     *
     * (C) 2010, Nodejitsu Inc.
     *
     */
    
    var events = require('events'),
        readline = require('readline'),
        utile = require('utile'),
        async = utile.async,
        read = require('read'),
        validate = require('revalidator').validate,
        winston = require('winston');
    
    //
    // Monkey-punch readline.Interface to work-around
    // https://github.com/joyent/node/issues/3860
    //
    readline.Interface.prototype.setPrompt = function(prompt, length) {
      this._prompt = prompt;
      if (length) {
        this._promptLength = length;
      } else {
        var lines = prompt.split(/[\r\n]/);
        var lastLine = lines[lines.length - 1];
        this._promptLength = lastLine.replace(/\u001b\[(\d+(;\d+)*)?m/g, '').length;
      }
    };
    
    //
    // Expose version using `pkginfo`
    //
    require('pkginfo')(module, 'version');
    
    var stdin, stdout, history = [];
    var prompt = module.exports = Object.create(events.EventEmitter.prototype);
    var logger = prompt.logger = new winston.Logger({
      transports: [new (winston.transports.Console)()]
    });
    
    prompt.started    = false;
    prompt.paused     = false;
    prompt.allowEmpty = false;
    prompt.message    = 'prompt';
    prompt.delimiter  = ': ';
    prompt.colors     = true;
    
    //
    // Create an empty object for the properties
    // known to `prompt`
    //
    prompt.properties = {};
    
    //
    // Setup the default winston logger to use
    // the `cli` levels and colors.
    //
    logger.cli();
    
    //
    // ### function start (options)
    // #### @options {Object} **Optional** Options to consume by prompt
    // Starts the prompt by listening to the appropriate events on `options.stdin`
    // and `options.stdout`. If no streams are supplied, then `process.stdin`
    // and `process.stdout` are used, respectively.
    //
    prompt.start = function (options) {
      if (prompt.started) {
        return;
      }
    
      options = options        || {};
      stdin   = options.stdin  || process.stdin;
      stdout  = options.stdout || process.stdout;
    
      //
      // By default: Remember the last `10` prompt property /
      // answer pairs and don't allow empty responses globally.
      //
      prompt.memory     = options.memory     || 10;
      prompt.allowEmpty = options.allowEmpty || false;
      prompt.message    = options.message    || prompt.message;
      prompt.delimiter  = options.delimiter  || prompt.delimiter;
      prompt.colors     = options.colors     || prompt.colors;
    
      if (process.platform !== 'win32') {
        // windows falls apart trying to deal with SIGINT
        process.on('SIGINT', function () {
          stdout.write('\n');
          process.exit(1);
        });
      }
    
      prompt.emit('start');
      prompt.started = true;
      return prompt;
    };
    
    //
    // ### function pause ()
    // Pauses input coming in from stdin
    //
    prompt.pause = function () {
      if (!prompt.started || prompt.paused) {
        return;
      }
    
      stdin.pause();
      prompt.emit('pause');
      prompt.paused = true;
      return prompt;
    };
    
    //
    // ### function resume ()
    // Resumes input coming in from stdin
    //
    prompt.resume = function () {
      if (!prompt.started || !prompt.paused) {
        return;
      }
    
      stdin.resume();
      prompt.emit('resume');
      prompt.paused = false;
      return prompt;
    };
    
    //
    // ### function history (search)
    // #### @search {Number|string} Index or property name to find.
    // Returns the `property:value` pair from within the prompts
    // `history` array.
    //
    prompt.history = function (search) {
      if (typeof search === 'number') {
        return history[search] || {};
      }
    
      var names = history.map(function (pair) {
        return typeof pair.property === 'string'
          ? pair.property
          : pair.property.name;
      });
    
      if (!~names.indexOf(search)) {
        return null;
      }
    
      return history.filter(function (pair) {
        return typeof pair.property === 'string'
          ? pair.property === search
          : pair.property.name === search;
      })[0];
    };
    
    //
    // ### function get (schema, callback)
    // #### @schema {Array|Object|string} Set of variables to get input for.
    // #### @callback {function} Continuation to pass control to when complete.
    // Gets input from the user via stdin for the specified message(s) `msg`.
    //
    prompt.get = function (schema, callback) {
      //
      // Transforms a full JSON-schema into an array describing path and sub-schemas.
      // Used for iteration purposes.
      //
      function untangle(schema, path) {
        var results = [];
        path = path || [];
    
        if (schema.properties) {
          //
          // Iterate over the properties in the schema and use recursion
          // to process sub-properties.
          //
          Object.keys(schema.properties).forEach(function (key) {
            var obj = {};
            obj[key] = schema.properties[key];
    
            //
            // Concat a sub-untangling to the results.
            //
            results = results.concat(untangle(obj[key], path.concat(key)));
          });
    
          // Return the results.
          return results;
        }
    
        //
        // This is a schema "leaf".
        //
        return {
          path: path,
          schema: schema
        };
      }
    
      //
      // Iterate over the values in the schema, represented as
      // a legit single-property object subschemas. Accepts `schema`
      // of the forms:
      //
      //    'prop-name'
      //
      //    ['string-name', { path: ['or-well-formed-subschema'], properties: ... }]
      //
      //    { path: ['or-well-formed-subschema'], properties: ... ] }
      //
      //    { properties: { 'schema-with-no-path' } }
      //
      // And transforms them all into
      //
      //    { path: ['path', 'to', 'property'], properties: { path: { to: ...} } }
      //
      function iterate(schema, get, done) {
        var iterator = [],
            result = {};
    
        if (typeof schema === 'string') {
          //
          // We can iterate over a single string.
          //
          iterator.push({
            path: [schema],
            schema: prompt.properties[schema.toLowerCase()] || {}
          });
        }
        else if (Array.isArray(schema)) {
          //
          // An array of strings and/or single-prop schema and/or no-prop schema.
          //
          iterator = schema.map(function (element) {
            if (typeof element === 'string') {
              return {
                path: [element],
                schema: prompt.properties[element.toLowerCase()] || {}
              };
            }
            else if (element.properties) {
              return {
                path: [Object.keys(element.properties)[0]],
                schema: element.properties[Object.keys(element.properties)[0]]
              };
            }
            else if (element.path && element.schema) {
              return element;
            }
            else {
              return {
                path: [element.name || 'question'],
                schema: element
              };
            }
          });
        }
        else if (schema.properties) {
          //
          // Or a complete schema `untangle` it for use.
          //
          iterator = untangle(schema);
        }
        else {
          //
          // Or a partial schema and path.
          // TODO: Evaluate need for this option.
          //
          iterator = [{
            schema: schema.schema ? schema.schema : schema,
            path: schema.path || [schema.name || 'question']
          }];
        }
    
        //
        // Now, iterate and assemble the result.
        //
        async.forEachSeries(iterator, function (branch, next) {
          get(branch, function assembler(err, line) {
            if (err) {
              return next(err);
            }
    
            function build(path, line) {
              var obj = {};
              if (path.length) {
                obj[path[0]] = build(path.slice(1), line);
                return obj;
              }
    
              return line;
            }
    
            function attach(obj, attr) {
              var keys;
              if (typeof attr !== 'object' || attr instanceof Array) {
                return attr;
              }
    
              keys = Object.keys(attr);
              if (keys.length) {
                if (!obj[keys[0]]) {
                  obj[keys[0]] = {};
                }
                obj[keys[0]] = attach(obj[keys[0]], attr[keys[0]]);
              }
    
              return obj;
            }
    
            result = attach(result, build(branch.path, line));
            next();
          });
        }, function (err) {
          return err ? done(err) : done(null, result);
        });
      }
    
      iterate(schema, function get(target, next) {
        prompt.getInput(target, function (err, line) {
          return err ? next(err) : next(null, line);
        });
      }, callback);
    
      return prompt;
    };
    
    //
    // ### function confirm (msg, callback)
    // #### @msg {Array|Object|string} set of message to confirm
    // #### @callback {function} Continuation to pass control to when complete.
    // Confirms a single or series of messages by prompting the user for a Y/N response.
    // Returns `true` if ALL messages are answered in the affirmative, otherwise `false`
    //
    // `msg` can be a string, or object (or array of strings/objects).
    // An object may have the following properties:
    //
    //    {
    //      description: 'yes/no' // message to prompt user
    //      pattern: /^[yntf]{1}/i // optional - regex defining acceptable responses
    //      yes: /^[yt]{1}/i // optional - regex defining `affirmative` responses
    //      message: 'yes/no' // optional - message to display for invalid responses
    //    }
    //
    prompt.confirm = function (/* msg, options, callback */) {
      var args     = Array.prototype.slice.call(arguments),
          msg      = args.shift(),
          callback = args.pop(),
          opts     = args.shift(),
          vars     = !Array.isArray(msg) ? [msg] : msg,
          RX_Y     = /^[yt]{1}/i,
          RX_YN    = /^[yntf]{1}/i;
    
      function confirm(target, next) {
        var yes = target.yes || RX_Y,
          options = utile.mixin({
            description: typeof target === 'string' ? target : target.description||'yes/no',
            pattern: target.pattern || RX_YN,
            name: 'confirm',
            message: target.message || 'yes/no'
          }, opts || {});
    
    
        prompt.get([options], function (err, result) {
          next(err ? false : yes.test(result[options.name]));
        });
      }
    
      async.rejectSeries(vars, confirm, function(result) {
        callback(null, result.length===0);
      });
    };
    
    
    // Variables needed outside of getInput for multiline arrays.
    var tmp = [];
    
    
    // ### function getInput (prop, callback)
    // #### @prop {Object|string} Variable to get input for.
    // #### @callback {function} Continuation to pass control to when complete.
    // Gets input from the user via stdin for the specified message `msg`.
    //
    prompt.getInput = function (prop, callback) {
      var schema = prop.schema || prop,
          propName = prop.path && prop.path.join(':') || prop,
          storedSchema = prompt.properties[propName.toLowerCase()],
          delim = prompt.delimiter,
          defaultLine,
          against,
          hidden,
          length,
          valid,
          name,
          raw,
          msg;
    
      //
      // If there is a stored schema for `propName` in `propmpt.properties`
      // then use it.
      //
      if (schema instanceof Object && !Object.keys(schema).length &&
        typeof storedSchema !== 'undefined') {
        schema = storedSchema;
      }
    
      //
      // Build a proper validation schema if we just have a string
      // and no `storedSchema`.
      //
      if (typeof prop === 'string' && !storedSchema) {
        schema = {};
      }
    
      schema = convert(schema);
      defaultLine = schema.default;
      name = prop.description || schema.description || propName;
      raw = prompt.colors
        ? [prompt.message, delim + name.grey, delim.grey]
        : [prompt.message, delim + name, delim];
    
      prop = {
        schema: schema,
        path: propName.split(':')
      };
    
      //
      // If the schema has no `properties` value then set
      // it to an object containing the current schema
      // for `propName`.
      //
      if (!schema.properties) {
        schema = (function () {
          var obj = { properties: {} };
          obj.properties[propName] = schema;
          return obj;
        })();
      }
    
      //
      // Handle overrides here.
      // TODO: Make overrides nestable
      //
      if (prompt.override && prompt.override[propName]) {
        if (prompt._performValidation(name, prop, prompt.override, schema, -1, callback)) {
          return callback(null, prompt.override[propName]);
        }
    
        delete prompt.override[propName];
      }
    
      var type = (schema.properties && schema.properties[propName] &&
                  schema.properties[propName].type || '').toLowerCase().trim(),
          wait = type === 'array';
    
      if (type === 'array') {
        length = prop.schema.maxItems;
        if (length) {
          msg = (tmp.length + 1).toString() + '/' + length.toString();
        }
        else {
          msg = (tmp.length + 1).toString();
        }
        msg += delim;
        raw.push(prompt.colors ? msg.grey : msg);
      }
    
      //
      // Calculate the raw length and colorize the prompt
      //
      length = raw.join('').length;
      raw[0] = raw[0];
      msg = raw.join('');
    
      if (schema.help) {
        schema.help.forEach(function (line) {
          logger.help(line);
        });
      }
    
      //
      // Emit a "prompting" event
      //
      prompt.emit('prompt', prop);
    
      //
      // If there is no default line, set it to an empty string
      //
      if(typeof defaultLine === 'undefined') {
        defaultLine = '';
      }
    
      //
      // set to string for readline ( will not accept Numbers )
      //
      defaultLine = defaultLine.toString();
    
      //
      // Make the actual read
      //
      read({
        prompt: msg,
        silent: prop.schema && prop.schema.hidden,
        default: defaultLine,
        input: stdin,
        output: stdout
      }, function (err, line) {
        if (err && wait === false) {
          return callback(err);
        }
    
        var against = {},
            numericInput,
            isValid;
    
        if (line !== '') {
    
          if (schema.properties[propName]) {
            var type = (schema.properties[propName].type || '').toLowerCase().trim() || undefined;
    
            //
            // Attempt to parse input as a float if the schema expects a number.
            //
            if (type == 'number') {
              numericInput = parseFloat(line, 10);
              if (!isNaN(numericInput)) {
                line = numericInput;
              }
            }
    
            //
            // Attempt to parse input as a boolean if the schema expects a boolean
            //
            if (type == 'boolean') {
              if(line === "true") {
                line = true;
              }
              if(line === "false") {
                line = false;
              }
            }
    
            //
            // If the type is an array, wait for the end. Fixes #54
            //
            if (type == 'array') {
              var length = prop.schema.maxItems;
              if (err) {
                if (err.message == 'canceled') {
                  wait = false;
                  stdout.write('\n');
                }
              }
              else {
                if (length) {
                  if (tmp.length + 1 < length) {
                    isValid = false;
                    wait = true;
                  }
                  else {
                    isValid = true;
                    wait = false;
                  }
                }
                else {
                  isValid = false;
                  wait = true;
                }
                tmp.push(line);
              }
              line = tmp;
            }
          }
    
          against[propName] = line;
        }
    
        if (prop && prop.schema.before) {
          line = prop.schema.before(line);
        }
    
        // Validate
        if (isValid === undefined) isValid = prompt._performValidation(name, prop, against, schema, line, callback);
    
        if (!isValid) {
          return prompt.getInput(prop, callback);
        }
    
        //
        // Log the resulting line, append this `property:value`
        // pair to the history for `prompt` and respond to
        // the callback.
        //
        logger.input(line.yellow);
        prompt._remember(propName, line);
        callback(null, line);
    
        // Make sure `tmp` is emptied
        tmp = [];
      });
    };
    
    //
    // ### function performValidation (name, prop, against, schema, line, callback)
    // #### @name {Object} Variable name
    // #### @prop {Object|string} Variable to get input for.
    // #### @against {Object} Input
    // #### @schema {Object} Validation schema
    // #### @line {String|Boolean} Input line
    // #### @callback {function} Continuation to pass control to when complete.
    // Perfoms user input validation, print errors if needed and returns value according to validation
    //
    prompt._performValidation = function (name, prop, against, schema, line, callback) {
      var numericInput, valid, msg;
    
      try {
        valid = validate(against, schema);
      }
      catch (err) {
        return (line !== -1) ? callback(err) : false;
      }
    
      if (!valid.valid) {
        msg = line !== -1 ? 'Invalid input for ' : 'Invalid command-line input for ';
    
        if (prompt.colors) {
          logger.error(msg + name.grey);
        }
        else {
          logger.error(msg + name);
        }
    
        if (prop.schema.message) {
          logger.error(prop.schema.message);
        }
    
        prompt.emit('invalid', prop, line);
      }
    
      return valid.valid;
    };
    
    //
    // ### function addProperties (obj, properties, callback)
    // #### @obj {Object} Object to add properties to
    // #### @properties {Array} List of properties to get values for
    // #### @callback {function} Continuation to pass control to when complete.
    // Prompts the user for values each of the `properties` if `obj` does not already
    // have a value for the property. Responds with the modified object.
    //
    prompt.addProperties = function (obj, properties, callback) {
      properties = properties.filter(function (prop) {
        return typeof obj[prop] === 'undefined';
      });
    
      if (properties.length === 0) {
        return callback(obj);
      }
    
      prompt.get(properties, function (err, results) {
        if (err) {
          return callback(err);
        }
        else if (!results) {
          return callback(null, obj);
        }
    
        function putNested (obj, path, value) {
          var last = obj, key;
    
          while (path.length > 1) {
            key = path.shift();
            if (!last[key]) {
              last[key] = {};
            }
    
            last = last[key];
          }
    
          last[path.shift()] = value;
        }
    
        Object.keys(results).forEach(function (key) {
          putNested(obj, key.split('.'), results[key]);
        });
    
        callback(null, obj);
      });
    
      return prompt;
    };
    
    //
    // ### @private function _remember (property, value)
    // #### @property {Object|string} Property that the value is in response to.
    // #### @value {string} User input captured by `prompt`.
    // Prepends the `property:value` pair into the private `history` Array
    // for `prompt` so that it can be accessed later.
    //
    prompt._remember = function (property, value) {
      history.unshift({
        property: property,
        value: value
      });
    
      //
      // If the length of the `history` Array
      // has exceeded the specified length to remember,
      // `prompt.memory`, truncate it.
      //
      if (history.length > prompt.memory) {
        history.splice(prompt.memory, history.length - prompt.memory);
      }
    };
    
    //
    // ### @private function convert (schema)
    // #### @schema {Object} Schema for a property
    // Converts the schema into new format if it is in old format
    //
    function convert(schema) {
      var newProps = Object.keys(validate.messages),
          newSchema = false,
          key;
    
      newProps = newProps.concat(['description', 'dependencies']);
    
      for (key in schema) {
        if (newProps.indexOf(key) > 0) {
          newSchema = true;
          break;
        }
      }
    
      if (!newSchema || schema.validator || schema.warning || typeof schema.empty !== 'undefined') {
        schema.description = schema.message;
        schema.message = schema.warning;
    
        if (typeof schema.validator === 'function') {
          schema.conform = schema.validator;
        } else {
          schema.pattern = schema.validator;
        }
    
        if (typeof schema.empty !== 'undefined') {
          schema.required = !(schema.empty);
        }
    
        delete schema.warning;
        delete schema.validator;
        delete schema.empty;
      }
    
      return schema;
    }
    
  provide("prompt", module.exports);
}(global));

// pakmanager:prompt-improved
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Requirements
    var readline = require('readline'),
    	chalk = require('chalk'),
    	read = require('read');
    
    // Utility extend
    function extend(obj) {
    	var args = Array.prototype.slice.call(arguments, 1);
    	for (var i = 0, len = args.length; i < len; i++) {
    		if (args[i]) {
    			for (var prop in args[i]) {
    				obj[prop] = args[i][prop];
    			}
    		}
    	}
        return obj;
    };
    
    // Constructor
    var Prompt = function(options) {
    
    	// Make sure this is a new instance of the prompt
    	if (!(this instanceof Prompt))
    		return new Prompt(options);
    
    	// Merge options
    	this.options = extend({}, Prompt.defaultOptions, options);
    };
    
    // Default options
    Prompt.defaultOptions = {
    	prefix           : '',
    	suffix           : ': ',
    	defaultPrefix    : ' (',
    	defaultSuffix    : ')',
    	textTheme        : chalk.bold,
    	prefixTheme      : chalk.white,
    	suffixTheme      : chalk.white,
    	defaultTheme     : chalk.white,
    	inputError       : 'Error encountered, try again.',
    	requiredError    : 'Required! Try again.',
    	invalidError     : 'Invalid input: ',
    	attemptsError    : 'Maximum attempts reached!',
    	stdin            : null,
    	stdout           : null,
    	stderr           : null,
    	timeout          : null,
    	confirm          : false,
    	overrideDefaults : {}
    };
    
    // Provides chalk
    Prompt.chalk = chalk;
    
    // Helpers for boolean questions
    Prompt.isBool = /^(?:y(?:es)?|n(?:o)?)$/i;
    Prompt.filterBool = function(value) {
    	value = value.toLowerCase();
    	if (value === 'y' || value === 'yes') return true;
    	return false;
    };
    
    // Ask a question
    Prompt.prototype.ask = function(question, options, callback) {
    
    	// Check callback
    	if (typeof callback !== 'function') {
    		callback = options;
    		options = undefined;
    	}
    
    	// Options are optional
    	if (typeof options === 'undefined') {
    		options = {};
    	}
    
    	// ask multiple questions
    	if (question instanceof Array) {
    		askMultiple.call(this, question, options, callback);
    		return;
    	}
    
    	// Can pass question in options
    	if (typeof question === 'object') {
    		options = question;
    		question = options.question;
    	}
    
    	askSingle.call(this, question, options, callback);
    
    };
    
    // Ask multiple questions
    function askMultiple(questions, options, callback) {
    
    	var output = {},
    		errors = null,
    		index = 0,
    		len = questions.length,
    		me = this;
    
    	// On completion of prompts
    	function finished() {
    		if (options.confirm) {
    
    			// Display before confirmation
    			if (options.confirm.before) {
    				log.call(me, options.confirm.before);
    			};
    
    			// Display input
    			for (var i in questions) {
    				if (!options.confirm.all) {
    					// Only display prompts that were asked
    					switch (typeof questions[i].depends) {
    						case 'boolean':
    							if (!questions[i].depends) continue;
    							break;
    						case 'function':
    							if (!questions[i].depends(output)) continue;
    							break;
    					}
    				}
    
    				var key = questions[i].key || questions[i].question;
    				logConfirmation.call(me, questions[i].question, output[key]);
    			}
    
    			// Display after confirmation
    			if (options.confirm.after) {
    				log.call(me, options.confirm.after);
    			}
    
    			// Ask for confirmation
    			me.ask(options.confirm.message || 'Confirm your input (Y/n)', {
    				default: options.confirm.default || 'Y',
    				boolean: true
    			}, function(err, res) {
    				if (res) {
    					callback(errors, output);
    				} else {
    					return askMultiple.call(me, questions, options, callback);
    				}
    			});
    		} else {
    			callback(errors, output);
    		}
    	}
    
    	// Loop through prompts
    	var next = function(err, res) {
    		// The key is either specified or just the question
    		var key = questions[index].key || questions[index].question;
    
    		// Keep the errors
    		if (err != null) {
    			if (errors === null) errors = {};
    			errors[key] = err;
    		}
    
    		// Keep the output
    		if (res != null) output[key] = res;
    
    		// If end of questions, callback
    		if (index == len-1) {
    			finished();
    			return;
    		}
    
    		// Increment and next
    		++index;
    		askSingle.call(me, questions[index].question, extend({}, options, questions[index]), next, output);
    	};
    
    	// Start the loop
    	askSingle.call(this, questions[index].question, extend({}, options, questions[index]), next, output);
    }
    
    // Ask a single question
    function askSingle(question, options, callback, _output) {
    
    	// Question and callback are not!
    	if (typeof question !== 'string' || typeof callback !== 'function')
    		throw new TypeError('Both question and callback are required!');
    
    	// Merge options
    	options = extend({}, this.options, options);
    
    	// Set the key to the question if it doesn't exist
    	if (!options.key)
    		options.key = question;
    
    	// Set default override
    	if (options.overrideDefaults && typeof options.overrideDefaults[options.key] !== 'undefined') {
    		var def = options.overrideDefaults[options.key];
    		if (options.boolean) {
    			if (options.overrideDefaults[options.key]) {
    				def = 'Y';
    			} else {
    				def = 'N';
    			}
    		}
    		options.default = def;
    	}
    	
    
    	// Prompt depends
    	switch (typeof options.depends) {
    		case 'boolean':
    			if (!options.depends) {
    				return callback(null, doAfterFilters(options.default, options));
    			}
    			break;
    		case 'function':
    			if (!options.depends(_output)) {
    				return callback(null, doAfterFilters(options.default, options));
    			}
    			break;
    	}
    
    	// Build prompt string
    	question = promptText(question, options);
    
    	// Ask the question
    	askQuestion.call(this, question, options, callback);
    
    };
    
    // Builds the prompt string
    function promptText(text, options) {
    	if (options.prefix) {
    		options.prefix = options.prefixTheme(options.prefix);
    	}
    	text = options.textTheme(text);
    	if (options.default) {
    		var def = options.defaultTheme(options.defaultPrefix + options.default + options.defaultSuffix);
    	}
    	if (options.suffix) {
    		options.suffix = options.suffixTheme(options.suffix);
    	}
    
    	return options.prefix + text + (def || '') + options.suffix;
    };
    
    // Just displays a prompt
    function displayPrompt(text, callback) {
    	read({
    		prompt: text,
    		input: this.options.stdin || process.stdin,
    		output: this.options.stdout || process.stdout,
    		terminal: false,
    		timeout: this.options.timeout
    	}, callback.bind(this));
    };
    
    // The actuall asking
    function askQuestion(question, options, callback, _attempt) {
    	if (!_attempt) _attempt = 0;
    	_attempt++;
    
    	if (options.attempts && _attempt > options.attempts) {
    		logError.call(this, options.attemptsError);
    		return callback(options.attemptsError, '');
    	}
    
    	displayPrompt.call(this, question, function(err, res) {
    
    		if (err) {
    			if (err.message == 'canceled')
    				return process.exit(err);
    			if (_attempt > 2)
    				return callback(err+'', '');
    			logError.call(this, options.inputError);
    			return askQuestion.call(this, question, options, callback, _attempt);
    		}
    
    		// Before filter
    		if (typeof options.before === 'function') {
    			res = options.before(res);
    		}
    
    		// If default, assign it if empty
    		if (typeof options.default !== 'undefined' && res == '') {
    			res = options.default;
    		}
    
    		// Required?
    		if (options.required && (typeof res === 'undefined' || res == '' || !res)) {
    			logError.call(this, options.requiredError);
    			return askQuestion.call(this, question, options, callback, _attempt);
    		}
    
    		// Do boolean check
    		if (options.boolean) {
    			if (!Prompt.isBool.test(res)) {
    				logError.call(this, options.invalidError + res);
    				return askQuestion.call(this, question, options, callback, _attempt);
    			}
    		}
    
    		// Custom validation function
    		if (typeof options.validate === 'function') {
    			if (!options.validate(res)) {
    				logError.call(this, options.invalidError + res);
    				return askQuestion.call(this, question, options, callback, _attempt);
    			}
    		} else if (options.validate instanceof RegExp) {
    			if (!options.validate.test(res)) {
    				logError.call(this, options.invalidError + res);
    				return askQuestion.call(this, question, options, callback, _attempt);
    			}
    		}
    
    		res = doAfterFilters(res, options);
    
    		return callback(null, res);
    	});
    };
    
    // Do the after filters
    function doAfterFilters(res, options) {
    	// After filter
    	if (typeof options.after === 'function') {
    		res = options.after(res);
    	}
    	// Do boolean filter
    	if (options.boolean) {
    		res = Prompt.filterBool(res);
    	}
    	return res;
    };
    
    // Standard error log format
    function logError(msg) {
    	if (this.options.stderr) {
    		this.options.stderr.write(chalk.red(msg));
    	} else {
    		console.error(chalk.red(msg));
    	}
    };
    
    // Standard confirmation log format
    function logConfirmation(key, val) {
    	var keyTheme = this.options.confirm.keyTheme || chalk.bold.grey;
    	var valTheme = this.options.confirm.valTheme || chalk.cyan;
    	var suffix = this.options.confirm.suffix || ': ';
    	switch (typeof val) {
    		case 'undefined': return;
    		case 'object': if(val === null) return;
    		case 'boolean': (val) ? val = 'Yes' : val = 'No'; break;
    	}
    	log.call(this, keyTheme(key + suffix) + valTheme(val));
    };
    
    // Log to console or stdout
    function log(out) {
    	if (this.options.stdout) {
    		this.options.stdout.write(out);
    	} else {
    		console.log(out);
    	}
    };
    
    // Export prompt
    module.exports = Prompt;
    
  provide("prompt-improved", module.exports);
}(global));